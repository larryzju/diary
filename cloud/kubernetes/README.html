<!DOCTYPE html>
<html>
	<head>
		<title>README.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="components">Components</h1>
<p>Split into <strong>master</strong> and <strong>node</strong> host depend on their functionality</p>
<h2 id="master-components">master components</h2>
<ul class="incremental">
<li>api server (restful service)</li>
<li>etcd (zookeeper like k/v storage)</li>
<li>controller manager (update resource object in etcd)</li>
<li>scheduler (which node to create pod)</li>
</ul>
<h2 id="node-components">node components</h2>
<ul class="incremental">
<li>kubelet (client for master)</li>
<li>kube-proxy (to implement pod network)</li>
<li>docker daemon (run container, <code>dockerd</code>)</li>
</ul>
<h1 id="resource-object">Resource Object</h1>
<p>Resource objects are stored in <code>etcd</code> database. And kubernetes is responsible for maintain the status to match the specification of the object.</p>
<h2 id="node">Node</h2>
<p>A worker machine in Kubernetes and is managed by the master components.</p>
<h3 id="status">Status</h3>
<dl class="incremental">
<dt>Address</dt>
<dd>host name, internal IP, external IP, internal DNS, etc
</dd>
<dt>Condition</dt>
<dd>latest resource health status (Ready, memory, pid, disk, network unavailable)
</dd>
<dt>Capacity</dt>
<dd>maximum number of pods can be scheduled, memory, ephemeral-storage
</dd>
<dt>Info</dt>
<dd>nodeInfo
</dd>
</dl>
<p>If the Status of the <strong>Ready</strong> condition remains <strong>Unknown</strong> or <strong>False</strong> for longer than the <strong>pod-eviction-timeout</strong> (5min by default), an argument is passed to the kube-controller-manager and all the Pods on the node are scheduled for deletion by the Node Controller.</p>
<p>The node is not managued by Kubernetes but the cloud providers. It's just a representation.</p>
<h2 id="pod">Pod</h2>
<ul class="incremental">
<li>Logical host (contains multiple containers)</li>
<li>allow containers visit each other (share PID, net, IPC, UTS, Volume)</li>
<li>Has its own IP address</li>
<li>Pod's name is used as addresss</li>
</ul>
<h2 id="label">Label</h2>
<p>Use to select</p>
<h2 id="annotation">Annotation</h2>
<p>Similar to Label, but contains opaque data</p>
<h2 id="namespace">Namespace</h2>
<p>isolate resources</p>
<h2 id="pv-pvc">PV &amp; PVC</h2>
<p>PV 之与 PVC 类似于 Golang 中的 Array 之与 Slice，Pod 之于 node resource</p>
<ul class="incremental">
<li>PV 对应于云运营商提供底层存储；PVC 相当于 Volume，可以被挂载到期 Pod 中</li>
<li>PVC 与 PV 一一对应，不存在一个 PV 对应多个 PVC 的情况，也不存在一个 PVC 跨越多个 PV 的情况</li>
<li>PV 中的 ClaimRef 反向引用 PVC, PVC 中 VolumeName 引用 PV</li>
</ul>
<h3 id="access-mode">Access Mode</h3>
<p>Both PV and PVC can be configured as subset access mode supported by the resource provider.</p>
<p>The access mode are:</p>
<ul class="incremental">
<li>ReadWriteOnce</li>
<li>ReadWriteMany</li>
<li>ReadOnlyMany</li>
</ul>
<h2 id="job">Job</h2>
<h3 id="reference">Reference</h3>
<ul class="incremental">
<li><a href="https://kubernetes.io/docs/tasks/job/parallel-processing-expansion/">Parallel Processing using Expansions</a></li>
<li><a href="https://kubernetes.io/docs/tasks/job/coarse-parallel-processing-work-queue/">Coarse Parallel Processing Using a Work Queue</a></li>
<li><a href="https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/">Fine Parallel Processing Using a Work Queue</a></li>
</ul>
<h2 id="volume">Volume</h2>
<ul class="incremental">
<li>Has the same lifespan with Pod</li>
<li>Shared by multiple containers</li>
<li>Has multiple implmenet, for example <code>hostPath</code></li>
</ul>
<h2 id="service">Service</h2>
<ul class="incremental">
<li>binding to selected endpoints (pods)</li>
<li>used to be accessed by external application, with <code>NodePort</code> or <code>LoadBalancer</code> configuraitons</li>
</ul>
<h2 id="replication-controller">Replication Controller</h2>
<ul class="incremental">
<li>manage Pod replications</li>
<li>can be used to scale or rolling update pods' containers</li>
</ul>
<h1 id="custom-resource">custom resource</h1>
<p>Extend kubernetes object type by definiting new resource object.</p>
<p>There're two methods to define custom resource:</p>
<ol class="incremental">
<li>CRD (Custom Resource Definition)</li>
<li>Aggregated API</li>
</ol>
<p>CR should be combined with Custom Controller to maintain the desire object states.</p>
<h2 id="cr-is-a-type-of-things-or-a-single-object"><span class="todo TODO">TODO</span> CR is a type of things? or a single object</h2>
<h2 id="k8s-api-convention-.spec-.status-.metadata"><span class="todo TODO">TODO</span> k8s API convention: <code>.spec</code>, <code>.status</code>, <code>.metadata</code></h2>
<h2 id="operator-pattern"><span class="todo TODO">TODO</span> Operator Pattern?</h2>
<h2 id="declarative-api-vs-imperative-api"><span class="todo TODO">TODO</span> declarative API vs imperative API</h2>
<h1 id="custom-controller">Custom Controller</h1>
<h1 id="customresourcedefinition">CustomResourceDefinition</h1>
<p>API to define new custom resources.</p>
<h2 id="note">Note</h2>
<ul class="incremental">
<li>define the group, version, name</li>
<li>can store any arbitary shaped objects</li>
<li>with <code>OpenAPIV3Schema</code> extension to constrain schema</li>
</ul>
<h2 id="how-to-combine-with-custom-controller"><span class="todo TODO">TODO</span> How to combine with Custom Controller?</h2>
<h2 id="scoped-but-not-namespaced"><span class="todo TODO">TODO</span> scoped but not namespaced?</h2>
<h1 id="operator">Operator</h1>
<p>An application-specific controller that extend Kubernetes API to create configure, and manage instances of complex stateful applications on behalf of a kubernetes user.</p>
<h2 id="what-is-operator"><span class="todo TODO">TODO</span> What is Operator?</h2>
<p>Implement of custom resource and its custom controller and will be built into docker image and deployed as a Deployment.</p>
<h1 id="kubernetes-object">Kubernetes Object</h1>
<h2 id="stored-in-etcd"><span class="todo TODO">TODO</span> stored in etcd?</h2>
<h2 id="basic-fields">basic fields</h2>
<ul class="incremental">
<li>apiVersion</li>
<li>kind</li>
<li>metadata
<ul class="incremental">
<li>name</li>
<li>UID</li>
<li>namespaces</li>
</ul></li>
<li>spec: desired status</li>
<li>status: actual status</li>
</ul>
<h2 id="control-plane-activate-manage"><span class="todo TODO">TODO</span> Control Plane activate manage?</h2>
<p>manage is equal to controller?</p>
<h1 id="namespace-1">Namespace</h1>
<h2 id="resource-quota"><span class="todo TODO">TODO</span> resource quota</h2>
<h2 id="non-namespaced-objects">Non-namespaced Objects</h2>
<ul class="incremental">
<li>use <code>api-resources</code> to check non-namespaced objects</li>
<li>for example, node, PV not in namespaces</li>
</ul>
<h1 id="question">Question</h1>
<h2 id="node-controller"><span class="todo TODO">TODO</span> Node controller</h2>
<div class="line-block">In versions of Kubernetes prior to 1.5, the node controller would<br />
force delete these unreachable pods from the apiserver. However, in<br />
1.5 and higher, the node controller does not force delete pods until<br />
it is confirmed that they have stopped running in the cluster. You can<br />
see the pods that might be running on an unreachable node as being in<br />
the Terminating or Unknown state.</div>
<p>Is node controller running on master node?</p>

			</div>
		</section>
	</body>
</html>
