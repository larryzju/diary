#+TITLE: Note on 80386 reference
#+AUTHOR: Zhao WenBin
#+OPTIONS: tex:t

* 寄存器

** 分类

有三类寄存器（对应用程序开发）

1. 通用目的寄存器，8个，32位
2. segment register，6个，16位
3. status and instruction register，两个，分别是 EFLAG 和 EIP

** 通用目的寄存器

- 8 个通用寄存器（32位）用于保存基地址和进行运算
- 分别是 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
- ESP 不能用于地址索引
- 兼容 8086 和 80286 处理器，后 16 位可以单独使用
- AX, BX, CX, DX 可进而拆分为高、低 8 位
- 部分指令要求使用到特定的寄存器（或使用特定寄存器能使指令更加紧凑）
- 某些字符串处理指令使用 ES 寄存器

** Segment Register

- 程序可能由不同部件组成
- 同一时刻只能有一部分段在使用
- 分段内存下，可以直接访问当下的段，并在有需求时访问其它的 segment
- CS 会在 CALL、JMP，interrupt 和 exception 中被隐式的切换
- DS,ES,FS,GS 寄存器可指定四个 data segments，有助于在不同的类型结构中进行切换

*** Stack Implements 

1. SS 寄存器。可以有多个栈，栈操作会自动引用 SS 中的段
2. ESP（ Stack Pointer ），指向栈底，栈向低地址增长
3. EBP（ Stack Base Pointer），栈的相对地址

** Status and Instruction Register

*** EFLAGS

- 32 位，标志处理器状态
- 低 16 位称为 FLAGS，用于兼容 8086 和 80286
- 分为三组标识
  1. status flag: OF,SF,ZF,AF,PF,CF
  2. control flag: DF（方向）
  3. system flags

*** EIP

- Extended Instruction Pointer
- 对程序员不可见，通过 control-transfer， interrupt 和 exception 进行修改



* 数据类型

** 基本类型

- 三种基本类型，分别是 byte, word, doubleword
- bit zero is the least significant bit
- 低字节（地址）中含有低有效位
- 字节度中位值随地址增大而增大，称为 little endian
- Intel 架构是小端字节序
- CPU 和内存之间是 32 位总线，内存不对齐会降低处理效率
- 数据结构尽可能保证内存对齐
- 指令因为 CPU 预取指机制而无需对齐

** Additional Data Type

- Integer，对应于 C 中的 char, short 和 int
- Ordinal, 无符号整型
- Near Pointer，指针类型，32 位，用于在 flat 或 segment model 中表示 offset
- Far Pointer，48 位地址，包括 segment selector(16位） 和 offset（32位） 两部分，只能在 segment 下使用
- String，最大 $(2^32)-1$ 字节
- Bit field，最大 32 位
- Bit String，最大 $(2^32)-1$ 位
- BCD，用后半字节表示 0到9 的数字
- Packed BCD，两个半字节来表示 0 到 99 的数字 

** 图示

[[file:80386/FIG2-4.GIF]]











* 内存管理

** 概述

- 从物理内存上看，最大有 4 个 GBytes 的空间，每个字节有唯一的线性物理地址
- 有 flat 和 segmented address space 两种看法
- flat 模式下处理器将 4G 空间通过地址转换映射到物理内存中
- segmented Model 将 16,383 个段映射到物理内存中，每个段最大有 4G 空间，最大寻址 64T
- 在段下内存寻址需要指定“段”和“偏移量”
- 段为内存空间提供了第二个维度，并提供了内存保护机制
- 16 位的段选择子，32 位的地址偏移，总共提供了 64T 的寻址空间

** Flat Model

** Segment Model

*** TODO 流程图

[[./80386/FIG5-1.GIF]]

Paging enabled 的连线是否标注有误??


*** 说明

- 进程中看到的内存是连续的、独立的，地址空间称为 logical address
- 实际上硬件内存称为 physical address
- logical address 到 physical address 的映射关系经过两种转换:segment translation, page translation
- segment translation 将 logical address 转换为 linear address
- page translation 将 linear address 转换为 physical address
- page translation 是可选的映射

*** 段寄存器

 - 6 个段寄存器（16位），分别是 CS,DS,SS,ES,FS,GS
 - 段寄存器中指定相应的段选择子
 - CS 指定代码段, =CS:[EIP]= 指向下一个要执行的指令地址，同一时刻只有一个代码段是可以寻址的
 - 引用 DS 寻址指令比其它 5 个短一个字节，开销相对低，用于安排寻址经常被使用的数据段
 - SS 段为堆栈段，使用 =SS:[ESP]= 来指示栈顶地址

*** 段偏移量

 - 包括三部分
   1. 基地址寄存器
   2. 比例因子
   3. 变址寄存器（位移）

*** TODO 分段的意义

 1. 内存保护
 2. 复用内存，将段交换到硬盘存储

*** Segment Translation

**** 概述

 - logical address 是多个分段下的连续地址, 分段以 base + limit 来指定
 - 要使用 logical address, 需要找到基地址，并指定偏移。即 base + offset
 - 基地址保存在　descriptor 结构中，系统维护有两张　descriptor 表，称为　GDT 和　LDT
 - selector　相当于一个索引，来从　descriptor table 中找到具体的 descriptor，进而找到相应的段
 - descriptor 由　compiler, linker, loader, os 等创建
 - 实际使用中，会大量的提取　descriptor。为了提高效率，segment register 缓存了 selector 到　descriptor 的关系

**** 转换流程图

 [[file:80386/FIG5-2.GIF]]

**** Descriptor

***** 分类

 分为两类

 1. for applications code and data segments
 2. for special system segments

***** 示意图

 [[file:80386/FIG5-3.GIF]]

***** 说明

 - base 保存基地址，由三部分构成，共 32 位
 - limit 由两部分构成，共 20 位
 - granularity 位是 Limit 长度标记，0 时 limit 单位为 1 字节，1 时 limit 单位为 4k 字节
 - type 用于区别两种格式 
 - segmentPresent 标记是否适用于地址转换
 - accessed 标记是否正在被使用
 - limit 最大长度为 4G（当 granularity 为 1 时）
 - 进程最大可以访问的 logical address 长度为 4G，达到虚拟进程访问空间的效果



**** Descriptor Tables

***** 说明

 - 分为 GDT 和 LDT 两类
 - 其中保存的是 descriptor 结构（8 个字节），长度可变，最长 8192 个 descriptor
 - 第一个 GDT 的 descriptor 不使用
 - GDTR 和 LDTR 寄存器，存储表的位置和长度
 - GDTR 的指令有： LGDT 和 SGDT
 - LDTR 的指令有： LLDT 和 SLDT


***** 示意

 [[file:80386/FIG5-5.GIF]]

**** Selector

***** 说明

 - selector 是到 descriptor table 的具体 descriptor 的索引
 - selector 的值一般由 linker 或 linking loader 来定义

***** 格式

 [[file:80386/FIG5-6.GIF]]


 - index 表示 8192 个 descriptor 的索引
 - Table Indicator 表示 GDT 或 LDT
 - RPL: Requested Privilege Level


**** Segment Registers

***** 图示

 [[file:80386/FIG5-7.GIF]]

***** 说明

 - segment register 包括了 CS, SS, DS，ES，FS，GS
 - 包括两部分，第一部分是可见的 16 位，保存 selector
 - program loads the visible part of the segment register with a 16-bit register
 - 处理器自动加载相应的 descriptor 到 segment register 的不可见部分
 - 本质是缓存 selector 与 descritpro 的关系


*** 补充
*** 问题

**** 为什么有 64T 寻址空间

 因为 selector 有 16 位，其中 descriptor table 的索引有 13 位，descriptor table 分为 GDT 和 LDT 两种，共 14 位，即 16K 空间。每个段内最大空间是 4G。因此最大可以寻址 64T 空间

**** TODO 操作系统如 Windows, Linux 看到的完整的 4G 空间，是否意味着使用 flat 模式？
**** 不同进程中是否通过代码段切换？是否受 64k 的限制
