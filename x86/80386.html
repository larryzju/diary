<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2017-06-10 Sat 23:36 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Note on 80386 reference</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Zhao WenBin">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/diary/style/style.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Note on 80386 reference</h1>
</header>
<div id="outline-container-org614e883" class="outline-2">
<h2 id="org614e883">寄存器</h2>
<div class="outline-text-2" id="text-org614e883">
</div><div id="outline-container-orgfda3f51" class="outline-3">
<h3 id="orgfda3f51">分类</h3>
<div class="outline-text-3" id="text-orgfda3f51">
<p>
有三类寄存器（对应用程序开发）
</p>

<ol class="org-ol">
<li>通用目的寄存器，8个，32位</li>
<li>segment register，6个，16位</li>
<li>status and instruction register，两个，分别是 EFLAG 和 EIP</li>
</ol>
</div>
</div>

<div id="outline-container-org62cb4f1" class="outline-3">
<h3 id="org62cb4f1">通用目的寄存器</h3>
<div class="outline-text-3" id="text-org62cb4f1">
<ul class="org-ul">
<li>8 个通用寄存器（32位）用于保存基地址和进行运算</li>
<li>分别是 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</li>
<li>ESP 不能用于地址索引</li>
<li>兼容 8086 和 80286 处理器，后 16 位可以单独使用</li>
<li>AX, BX, CX, DX 可进而拆分为高、低 8 位</li>
<li>部分指令要求使用到特定的寄存器（或使用特定寄存器能使指令更加紧凑）</li>
<li>某些字符串处理指令使用 ES 寄存器</li>
</ul>
</div>
</div>

<div id="outline-container-orgf5d477d" class="outline-3">
<h3 id="orgf5d477d">Segment Register</h3>
<div class="outline-text-3" id="text-orgf5d477d">
<ul class="org-ul">
<li>程序可能由不同部件组成</li>
<li>同一时刻只能有一部分段在使用</li>
<li>分段内存下，可以直接访问当下的段，并在有需求时访问其它的 segment</li>
<li>CS 会在 CALL、JMP，interrupt 和 exception 中被隐式的切换</li>
<li>DS,ES,FS,GS 寄存器可指定四个 data segments，有助于在不同的类型结构中进行切换</li>
</ul>
</div>

<div id="outline-container-org65c378e" class="outline-4">
<h4 id="org65c378e">Stack Implements</h4>
<div class="outline-text-4" id="text-org65c378e">
<ol class="org-ol">
<li>SS 寄存器。可以有多个栈，栈操作会自动引用 SS 中的段</li>
<li>ESP（ Stack Pointer ），指向栈底，栈向低地址增长</li>
<li>EBP（ Stack Base Pointer），栈的相对地址</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org7a6d5b2" class="outline-3">
<h3 id="org7a6d5b2">Status and Instruction Register</h3>
<div class="outline-text-3" id="text-org7a6d5b2">
</div><div id="outline-container-orgba50a29" class="outline-4">
<h4 id="orgba50a29">EFLAGS</h4>
<div class="outline-text-4" id="text-orgba50a29">
<ul class="org-ul">
<li>32 位，标志处理器状态</li>
<li>低 16 位称为 FLAGS，用于兼容 8086 和 80286</li>
<li>分为三组标识
<ol class="org-ol">
<li>status flag: OF,SF,ZF,AF,PF,CF</li>
<li>control flag: DF（方向）</li>
<li>system flags</li>
</ol></li>
</ul>
</div>
</div>

<div id="outline-container-org892387d" class="outline-4">
<h4 id="org892387d">EIP</h4>
<div class="outline-text-4" id="text-org892387d">
<ul class="org-ul">
<li>Extended Instruction Pointer</li>
<li>对程序员不可见，通过 control-transfer， interrupt 和 exception 进行修改</li>
</ul>
</div>
</div>
</div>
</div>



<div id="outline-container-org0ca1b4f" class="outline-2">
<h2 id="org0ca1b4f">数据类型</h2>
<div class="outline-text-2" id="text-org0ca1b4f">
</div><div id="outline-container-org8b7d913" class="outline-3">
<h3 id="org8b7d913">基本类型</h3>
<div class="outline-text-3" id="text-org8b7d913">
<ul class="org-ul">
<li>三种基本类型，分别是 byte, word, doubleword</li>
<li>bit zero is the least significant bit</li>
<li>低字节（地址）中含有低有效位</li>
<li>字节度中位值随地址增大而增大，称为 little endian</li>
<li>Intel 架构是小端字节序</li>
<li>CPU 和内存之间是 32 位总线，内存不对齐会降低处理效率</li>
<li>数据结构尽可能保证内存对齐</li>
<li>指令因为 CPU 预取指机制而无需对齐</li>
</ul>
</div>
</div>

<div id="outline-container-org3f2d552" class="outline-3">
<h3 id="org3f2d552">Additional Data Type</h3>
<div class="outline-text-3" id="text-org3f2d552">
<ul class="org-ul">
<li>Integer，对应于 C 中的 char, short 和 int</li>
<li>Ordinal, 无符号整型</li>
<li>Near Pointer，指针类型，32 位，用于在 flat 或 segment model 中表示 offset</li>
<li>Far Pointer，48 位地址，包括 segment selector(16位） 和 offset（32位） 两部分，只能在 segment 下使用</li>
<li>String，最大 \((2^32)-1\) 字节</li>
<li>Bit field，最大 32 位</li>
<li>Bit String，最大 \((2^32)-1\) 位</li>
<li>BCD，用后半字节表示 0到9 的数字</li>
<li>Packed BCD，两个半字节来表示 0 到 99 的数字</li>
</ul>
</div>
</div>

<div id="outline-container-org4d2c5d9" class="outline-3">
<h3 id="org4d2c5d9">图示</h3>
<div class="outline-text-3" id="text-org4d2c5d9">

<figure>
<img src="80386/FIG2-4.GIF" alt="FIG2-4.GIF">

</figure>
</div>
</div>
</div>











<div id="outline-container-org143e20b" class="outline-2">
<h2 id="org143e20b">指令格式</h2>
<div class="outline-text-2" id="text-org143e20b">
</div><div id="outline-container-org2fdb0b1" class="outline-3">
<h3 id="org2fdb0b1">概述</h3>
<div class="outline-text-3" id="text-org2fdb0b1">
<ul class="org-ul">
<li>指令中反映出操作类型、操作数类型、操作数位置；其中隐含有寻址的方式</li>
<li>指令有可变长个元素组成，由 opcode 个可选个其它参数组成（用于表示操作数类型和位置）</li>
</ul>
</div>
</div>

<div id="outline-container-orgbc642f2" class="outline-3">
<h3 id="orgbc642f2">元素</h3>
<div class="outline-text-3" id="text-orgbc642f2">
<dl class="org-dl">
<dt>Prefix</dt><dd>用于修饰指令操作数
<dl class="org-dl">
<dt>Segment override</dt><dd>用于显式地指定段寄存器（替换默认的段寄存器）</dd>
<dt>Address size</dt><dd>在 32 和 16 位地址类型之间切换</dd>
<dt>Operand size</dt><dd>在 32 和 16 位操作数类型之间切换</dd>
<dt>Repeat</dt><dd>循环对字符串的每个字进行操作</dd>
</dl></dd>
<dt>Opcode</dt><dd>指令操作类型，可多态</dd>
<dt>Register specifier</dt><dd>寄存器指定操作数</dd>
<dt>Address-Model Specifier</dt><dd>指定地址信息
<dl class="org-dl">
<dt>SIB(Scale, index, base)</dt><dd>通过基地址加偏移量指定位置</dd>
<dt>Displacement</dt><dd>通过偏移量指定位置</dd>
<dt>Immediate Operand</dt><dd>指定立即数，可用作地址或数值</dd>
</dl></dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-org51dd252" class="outline-2">
<h2 id="org51dd252">控制指令</h2>
<div class="outline-text-2" id="text-org51dd252">
</div><div id="outline-container-orgf234b9d" class="outline-3">
<h3 id="orgf234b9d">概述</h3>
<div class="outline-text-3" id="text-orgf234b9d">
<ul class="org-ul">
<li>包含两类跳转指令：有条件的和无条件的跳转指令</li>
<li>跳转与处理器状态标记有关</li>
<li>中断和异常也会触发跳转</li>
</ul>
</div>
</div>

<div id="outline-container-orgcc84b1c" class="outline-3">
<h3 id="orgcc84b1c">无条件跳转</h3>
<div class="outline-text-3" id="text-orgcc84b1c">
<ul class="org-ul">
<li>可将 CS 切换到另一个，称为 far control transfer</li>
<li>在同一个 segment 内跳转，称为 near control transfer</li>
</ul>
</div>

<div id="outline-container-org06df33f" class="outline-4">
<h4 id="org06df33f">Jump Instruction</h4>
<div class="outline-text-4" id="text-org06df33f">
<ul class="org-ul">
<li>直接跳转，不会压栈</li>
<li>地址可以是直接指定的，也可以是寄存器间接寻址的
<ul class="org-ul">
<li>Direct Near Jump： 使用相对偏移地址</li>
<li>Indirect Near Jump: 指定绝对地址
<ul class="org-ul">
<li>通用寄存器（除 ESP 之外）内容回填 EIP</li>
<li>memory operand specified</li>
<li>修改 memory pointer 地址</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org9fc2bbb" class="outline-4">
<h4 id="org9fc2bbb">Call Instruction</h4>
<div class="outline-text-4" id="text-org9fc2bbb">
<ul class="org-ul">
<li>Call Procedure，将 EIP 压栈，并在 RET 时弹出</li>
<li>地址有 relative, direct, indirect 三种</li>
<li>间接寻址有两种方式
<ul class="org-ul">
<li>通用寄存器内容回填 EIP</li>
<li>从 memory operand 中获取</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org9c2ff85" class="outline-4">
<h4 id="org9c2ff85">Return and Return-From-Interrupt Instruction</h4>
<div class="outline-text-4" id="text-org9c2ff85">
<dl class="org-dl">
<dt>RET</dt><dd>从栈中恢复 EIP 到前一个 CALL 的位置，可以指定一个返回值（立即数）</dd>
<dt>IRET</dt><dd>从中断处理中返回。不同于 RET，还会将栈上的 flags 恢复（中断时保存的现场）</dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-org2993573" class="outline-3">
<h3 id="org2993573">有条件跳转</h3>
<div class="outline-text-3" id="text-org2993573">
<p>
由 CPU 状态来决定是否跳转
</p>
</div>

<div id="outline-container-org012da82" class="outline-4">
<h4 id="org012da82">Conditional Jump Instruction</h4>
<div class="outline-text-4" id="text-org012da82">

<figure>
<img src="80386/TABLE3-2.PNG" alt="TABLE3-2.PNG">

</figure>

<ul class="org-ul">
<li>条件跳转指令对 EIP 进行偏移</li>
<li>偏移可以为负，即可以向前跳转</li>
</ul>
</div>
</div>

<div id="outline-container-org2e8ae44" class="outline-4">
<h4 id="org2e8ae44">Loop Instructions</h4>
<div class="outline-text-4" id="text-org2e8ae44">
<ul class="org-ul">
<li>loop 也是条件跳转，使用 ECX 的值作为循环次数</li>
<li>有五个循环指令： <code>LOOP</code>, <code>LOOPE</code>, <code>LOOPZ</code>, <code>LOOPNE</code>, <code>LOOPNZ</code></li>
<li>其中有四个通过 ZF 状态来判断是否结束循环</li>
</ul>
</div>

<ul class="org-ul"><li><a id="orgb6ef024"></a>LOOPE/LOOPZ<br><div class="outline-text-5" id="text-orgb6ef024">
<ul class="org-ul">
<li>LOOPE: Loop While Equal</li>
<li>LOOPZ: Loop While Zero</li>
<li>两个指令有相同的作用</li>
<li>当  <code>(ECX-- &amp;&amp; ZF==1)</code> 时，跳转到 LABEL 处</li>
</ul>
</div></li>

<li><a id="org7b08f9d"></a>LOOPNE/LOOPNZ<br><div class="outline-text-5" id="text-org7b08f9d">
<ul class="org-ul">
<li>当 <code>(ECX-- &amp;&amp; ZF==0)</code> 时，跳转到 LABEL 处</li>
</ul>
</div></li></ul>
</div>


<div id="outline-container-org6f61f59" class="outline-4">
<h4 id="org6f61f59"><span class="todo TODO">TODO</span> Executing a Loop or Repeat Zero Times</h4>
<div class="outline-text-4" id="text-org6f61f59">
<ul class="org-ul">
<li>JCXZ ( Jump If ECX Zero )</li>
<li>若 ECX 为 0，则跳转到 label 处</li>
<li>配合 LOOP 指令，用于 string scan 和比较操作</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-orgc54c798" class="outline-3">
<h3 id="orgc54c798">软件中断</h3>
<div class="outline-text-3" id="text-orgc54c798">
</div><div id="outline-container-org3604f6e" class="outline-4">
<h4 id="org3604f6e">INT n</h4>
<div class="outline-text-4" id="text-org3604f6e">
<ul class="org-ul">
<li><code>INT n</code> 和 <code>BOUND</code> 允许跳转到配置的 interrupt service routine</li>
<li><code>INT n</code> 调用第 n 号软件中断，可以指定 interrupt type</li>
<li>中断号 0 到 31 被 intel 保留，用于内部异常</li>
<li>中断通过 <code>IRET</code> 来返回</li>
</ul>
</div>
</div>

<div id="outline-container-org89f7f7d" class="outline-4">
<h4 id="org89f7f7d">INT0</h4>
<div class="outline-text-4" id="text-org89f7f7d">
<ul class="org-ul">
<li>Interrupt on Overflow</li>
<li>若 OF 被置位，则调用中断 4</li>
</ul>
</div>
</div>

<div id="outline-container-orgd1b2fcb" class="outline-4">
<h4 id="orgd1b2fcb">BOUND</h4>
<div class="outline-text-4" id="text-orgd1b2fcb">
<ul class="org-ul">
<li>Detect Value Out of Range</li>
<li>检查特定寄存器中的有符号值是否在范围内</li>
<li>若不在范围内，则铖中断 5</li>
<li>BOUND 每一个参数是要被检查的寄存器</li>
<li>第二个是相对地址，指向高与低两个上下限</li>
<li>BOUND 可用于检查数组边界</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org1f9be57" class="outline-2">
<h2 id="org1f9be57">内存管理</h2>
<div class="outline-text-2" id="text-org1f9be57">
</div><div id="outline-container-org53eca2b" class="outline-3">
<h3 id="org53eca2b">概述</h3>
<div class="outline-text-3" id="text-org53eca2b">
<ul class="org-ul">
<li>从物理内存上看，最大有 4 个 GBytes 的空间，每个字节有唯一的线性物理地址</li>
<li>有 flat 和 segmented address space 两种看法</li>
<li>flat 模式下处理器将 4G 空间通过地址转换映射到物理内存中</li>
<li>segmented Model 将 16,383 个段映射到物理内存中，每个段最大有 4G 空间，最大寻址 64T</li>
<li>在段下内存寻址需要指定“段”和“偏移量”</li>
<li>段为内存空间提供了第二个维度，并提供了内存保护机制</li>
<li>16 位的段选择子，32 位的地址偏移，总共提供了 64T 的寻址空间</li>
</ul>
</div>
</div>

<div id="outline-container-orgb8a4510" class="outline-3">
<h3 id="orgb8a4510">Flat Model</h3>
</div>

<div id="outline-container-org3123a1a" class="outline-3">
<h3 id="org3123a1a">Segment Model</h3>
<div class="outline-text-3" id="text-org3123a1a">
</div><div id="outline-container-orgec12b6c" class="outline-4">
<h4 id="orgec12b6c"><span class="todo TODO">TODO</span> 流程图</h4>
<div class="outline-text-4" id="text-orgec12b6c">

<figure>
<img src="./80386/FIG5-1.GIF" alt="FIG5-1.GIF">

</figure>

<p>
Paging enabled 的连线是否标注有误??
</p>
</div>
</div>


<div id="outline-container-org23c049a" class="outline-4">
<h4 id="org23c049a">说明</h4>
<div class="outline-text-4" id="text-org23c049a">
<ul class="org-ul">
<li>进程中看到的内存是连续的、独立的，地址空间称为 logical address</li>
<li>实际上硬件内存称为 physical address</li>
<li>logical address 到 physical address 的映射关系经过两种转换:segment translation, page translation</li>
<li>segment translation 将 logical address 转换为 linear address</li>
<li>page translation 将 linear address 转换为 physical address</li>
<li>page translation 是可选的映射</li>
</ul>
</div>
</div>

<div id="outline-container-orgc8294a4" class="outline-4">
<h4 id="orgc8294a4">段寄存器</h4>
<div class="outline-text-4" id="text-orgc8294a4">
<ul class="org-ul">
<li>6 个段寄存器（16位），分别是 CS,DS,SS,ES,FS,GS</li>
<li>段寄存器中指定相应的段选择子</li>
<li>CS 指定代码段, <code>CS:[EIP]</code> 指向下一个要执行的指令地址，同一时刻只有一个代码段是可以寻址的</li>
<li>引用 DS 寻址指令比其它 5 个短一个字节，开销相对低，用于安排寻址经常被使用的数据段</li>
<li>SS 段为堆栈段，使用 <code>SS:[ESP]</code> 来指示栈顶地址</li>
</ul>
</div>
</div>

<div id="outline-container-orgdd463bd" class="outline-4">
<h4 id="orgdd463bd">段偏移量</h4>
<div class="outline-text-4" id="text-orgdd463bd">
<ul class="org-ul">
<li>包括三部分
<ol class="org-ol">
<li>基地址寄存器</li>
<li>比例因子</li>
<li>变址寄存器（位移）</li>
</ol></li>
</ul>
</div>
</div>

<div id="outline-container-orgf895b63" class="outline-4">
<h4 id="orgf895b63"><span class="todo TODO">TODO</span> 分段的意义</h4>
<div class="outline-text-4" id="text-orgf895b63">
<ol class="org-ol">
<li>内存保护</li>
<li>复用内存，将段交换到硬盘存储</li>
</ol>
</div>
</div>

<div id="outline-container-orgeae606a" class="outline-4">
<h4 id="orgeae606a">Segment Translation</h4>
<div class="outline-text-4" id="text-orgeae606a">
</div><ul class="org-ul"><li><a id="org1b84a3f"></a>概述<br><div class="outline-text-5" id="text-org1b84a3f">
<ul class="org-ul">
<li>logical address 是多个分段下的连续地址, 分段以 base + limit 来指定</li>
<li>要使用 logical address, 需要找到基地址，并指定偏移。即 base + offset</li>
<li>基地址保存在　descriptor 结构中，系统维护有两张　descriptor 表，称为　GDT 和　LDT</li>
<li>selector　相当于一个索引，来从　descriptor table 中找到具体的 descriptor，进而找到相应的段</li>
<li>descriptor 由　compiler, linker, loader, os 等创建</li>
<li>实际使用中，会大量的提取　descriptor。为了提高效率，segment register 缓存了 selector 到　descriptor 的关系</li>
</ul>
</div></li>

<li><a id="org0d83452"></a>转换流程图<br><div class="outline-text-5" id="text-org0d83452">

<figure>
<img src="80386/FIG5-2.GIF" alt="FIG5-2.GIF">

</figure>
</div></li>

<li><a id="org69af503"></a>Descriptor<br><ul class="org-ul"><li><a id="org2078ea8"></a>分类<br><div class="outline-text-6" id="text-org2078ea8">
<p>
分为两类
</p>

<ol class="org-ol">
<li>for applications code and data segments</li>
<li>for special system segments</li>
</ol>
</div></li>

<li><a id="org7ea0f5d"></a>示意图<br><div class="outline-text-6" id="text-org7ea0f5d">

<figure>
<img src="80386/FIG5-3.GIF" alt="FIG5-3.GIF">

</figure>
</div></li>

<li><a id="orgdf25422"></a>说明<br><div class="outline-text-6" id="text-orgdf25422">
<ul class="org-ul">
<li>base 保存基地址，由三部分构成，共 32 位</li>
<li>limit 由两部分构成，共 20 位</li>
<li>granularity 位是 Limit 长度标记，0 时 limit 单位为 1 字节，1 时 limit 单位为 4k 字节</li>
<li>type 用于区别两种格式</li>
<li>segmentPresent 标记是否适用于地址转换</li>
<li>accessed 标记是否正在被使用</li>
<li>limit 最大长度为 4G（当 granularity 为 1 时）</li>
<li>进程最大可以访问的 logical address 长度为 4G，达到虚拟进程访问空间的效果</li>
</ul>
</div></li></ul></li>



<li><a id="orgc31789f"></a>Descriptor Tables<br><ul class="org-ul"><li><a id="org2de8340"></a>说明<br><div class="outline-text-6" id="text-org2de8340">
<ul class="org-ul">
<li>分为 GDT 和 LDT 两类</li>
<li>其中保存的是 descriptor 结构（8 个字节），长度可变，最长 8192 个 descriptor</li>
<li>第一个 GDT 的 descriptor 不使用</li>
<li>GDTR 和 LDTR 寄存器，存储表的位置和长度</li>
<li>GDTR 的指令有： LGDT 和 SGDT</li>
<li>LDTR 的指令有： LLDT 和 SLDT</li>
</ul>
</div></li>


<li><a id="org10611a4"></a>示意<br><div class="outline-text-6" id="text-org10611a4">

<figure>
<img src="80386/FIG5-5.GIF" alt="FIG5-5.GIF">

</figure>
</div></li></ul></li>

<li><a id="org419d604"></a>Selector<br><ul class="org-ul"><li><a id="org5a77868"></a>说明<br><div class="outline-text-6" id="text-org5a77868">
<ul class="org-ul">
<li>selector 是到 descriptor table 的具体 descriptor 的索引</li>
<li>selector 的值一般由 linker 或 linking loader 来定义</li>
</ul>
</div></li>

<li><a id="orgbe9b241"></a>格式<br><div class="outline-text-6" id="text-orgbe9b241">

<figure>
<img src="80386/FIG5-6.GIF" alt="FIG5-6.GIF">

</figure>


<ul class="org-ul">
<li>index 表示 8192 个 descriptor 的索引</li>
<li>Table Indicator 表示 GDT 或 LDT</li>
<li>RPL: Requested Privilege Level</li>
</ul>
</div></li></ul></li>


<li><a id="orgb262f5c"></a>Segment Registers<br><ul class="org-ul"><li><a id="org1e68474"></a>图示<br><div class="outline-text-6" id="text-org1e68474">

<figure>
<img src="80386/FIG5-7.GIF" alt="FIG5-7.GIF">

</figure>
</div></li>

<li><a id="org0e8de79"></a>说明<br><div class="outline-text-6" id="text-org0e8de79">
<ul class="org-ul">
<li>segment register 包括了 CS, SS, DS，ES，FS，GS</li>
<li>包括两部分，第一部分是可见的 16 位，保存 selector</li>
<li>program loads the visible part of the segment register with a 16-bit register</li>
<li>处理器自动加载相应的 descriptor 到 segment register 的不可见部分</li>
<li>本质是缓存 selector 与 descritpro 的关系</li>
</ul>
</div></li></ul></li></ul>
</div>


<div id="outline-container-org6cc9d43" class="outline-4">
<h4 id="org6cc9d43">补充</h4>
</div>
<div id="outline-container-orgb3b36fd" class="outline-4">
<h4 id="orgb3b36fd">问题</h4>
<div class="outline-text-4" id="text-orgb3b36fd">
</div><ul class="org-ul"><li><a id="org4662abc"></a>为什么有 64T 寻址空间<br><div class="outline-text-5" id="text-org4662abc">
<p>
因为 selector 有 16 位，其中 descriptor table 的索引有 13 位，descriptor table 分为 GDT 和 LDT 两种，共 14 位，即 16K 空间。每个段内最大空间是 4G。因此最大可以寻址 64T 空间
</p>
</div></li>

<li><a id="org548b2f2"></a><span class="todo TODO">TODO</span> 操作系统如 Windows, Linux 看到的完整的 4G 空间，是否意味着使用 flat 模式？<br></li>
<li><a id="orgbe06f72"></a>不同进程中是否通过代码段切换？是否受 64k 的限制<br></li></ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Zhao WenBin</p>
<p class="date">Created: 2017-06-10 Sat 23:36</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
