<!DOCTYPE html>
<html>
	<head>
		<title>80386.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="寄存器">寄存器</h1>
<h2 id="分类">分类</h2>
<p>有三类寄存器（对应用程序开发）</p>
<ol class="incremental">
<li>通用目的寄存器，8个，32位</li>
<li>segment register，6个，16位</li>
<li>status and instruction register，两个，分别是 EFLAG 和 EIP</li>
</ol>
<h2 id="通用目的寄存器">通用目的寄存器</h2>
<ul class="incremental">
<li>8 个通用寄存器（32位）用于保存基地址和进行运算</li>
<li>分别是 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</li>
<li>ESP 不能用于地址索引</li>
<li>兼容 8086 和 80286 处理器，后 16 位可以单独使用</li>
<li>AX, BX, CX, DX 可进而拆分为高、低 8 位</li>
<li>部分指令要求使用到特定的寄存器（或使用特定寄存器能使指令更加紧凑）</li>
<li>某些字符串处理指令使用 ES 寄存器</li>
</ul>
<h2 id="segment-register">Segment Register</h2>
<ul class="incremental">
<li>程序可能由不同部件组成</li>
<li>同一时刻只能有一部分段在使用</li>
<li>分段内存下，可以直接访问当下的段，并在有需求时访问其它的 segment</li>
<li>CS 会在 CALL、JMP，interrupt 和 exception 中被隐式的切换</li>
<li>DS,ES,FS,GS 寄存器可指定四个 data segments，有助于在不同的类型结构中进行切换</li>
</ul>
<h3 id="stack-implements">Stack Implements</h3>
<ol class="incremental">
<li>SS 寄存器。可以有多个栈，栈操作会自动引用 SS 中的段</li>
<li>ESP（ Stack Pointer ），指向栈底，栈向低地址增长</li>
<li>EBP（ Stack Base Pointer），栈的相对地址</li>
</ol>
<h2 id="status-and-instruction-register">Status and Instruction Register</h2>
<h3 id="eflags">EFLAGS</h3>
<ul class="incremental">
<li>32 位，标志处理器状态</li>
<li>低 16 位称为 FLAGS，用于兼容 8086 和 80286</li>
<li>分为三组标识
<ol class="incremental">
<li>status flag: OF,SF,ZF,AF,PF,CF</li>
<li>control flag: DF（方向）</li>
<li>system flags</li>
</ol></li>
</ul>
<h3 id="eip">EIP</h3>
<ul class="incremental">
<li>Extended Instruction Pointer</li>
<li>对程序员不可见，通过 control-transfer， interrupt 和 exception 进行修改</li>
</ul>
<h1 id="数据类型">数据类型</h1>
<h2 id="基本类型">基本类型</h2>
<ul class="incremental">
<li>三种基本类型，分别是 byte, word, doubleword</li>
<li>bit zero is the least significant bit</li>
<li>低字节（地址）中含有低有效位</li>
<li>字节度中位值随地址增大而增大，称为 little endian</li>
<li>Intel 架构是小端字节序</li>
<li>CPU 和内存之间是 32 位总线，内存不对齐会降低处理效率</li>
<li>数据结构尽可能保证内存对齐</li>
<li>指令因为 CPU 预取指机制而无需对齐</li>
</ul>
<h2 id="additional-data-type">Additional Data Type</h2>
<ul class="incremental">
<li>Integer，对应于 C 中的 char, short 和 int</li>
<li>Ordinal, 无符号整型</li>
<li>Near Pointer，指针类型，32 位，用于在 flat 或 segment model 中表示 offset</li>
<li>Far Pointer，48 位地址，包括 segment selector(16位） 和 offset（32位） 两部分，只能在 segment 下使用</li>
<li>String，最大 <span class="math inline">(2<sup>32</sup>)−1</span> 字节</li>
<li>Bit field，最大 32 位</li>
<li>Bit String，最大 <span class="math inline">(2<sup>32</sup>)−1</span> 位</li>
<li>BCD，用后半字节表示 0到9 的数字</li>
<li>Packed BCD，两个半字节来表示 0 到 99 的数字</li>
</ul>
<h2 id="图示">图示</h2>
<p><a href="80386/FIG2-4.GIF">file:80386/FIG2-4.GIF</a></p>
<h1 id="指令格式">指令格式</h1>
<h2 id="概述">概述</h2>
<ul class="incremental">
<li>指令中反映出操作类型、操作数类型、操作数位置；其中隐含有寻址的方式</li>
<li>指令有可变长个元素组成，由 opcode 个可选个其它参数组成（用于表示操作数类型和位置）</li>
</ul>
<h2 id="元素">元素</h2>
<dl class="incremental">
<dt>Prefix</dt>
<dd><p>用于修饰指令操作数</p>
<dl class="incremental">
<dt>Segment override</dt>
<dd>用于显式地指定段寄存器（替换默认的段寄存器）
</dd>
<dt>Address size</dt>
<dd>在 32 和 16 位地址类型之间切换
</dd>
<dt>Operand size</dt>
<dd>在 32 和 16 位操作数类型之间切换
</dd>
<dt>Repeat</dt>
<dd>循环对字符串的每个字进行操作
</dd>
</dl>
</dd>
<dt>Opcode</dt>
<dd>指令操作类型，可多态
</dd>
<dt>Register specifier</dt>
<dd>寄存器指定操作数
</dd>
<dt>Address-Model Specifier</dt>
<dd><p>指定地址信息</p>
<dl class="incremental">
<dt>SIB(Scale, index, base)</dt>
<dd>通过基地址加偏移量指定位置
</dd>
<dt>Displacement</dt>
<dd>通过偏移量指定位置
</dd>
<dt>Immediate Operand</dt>
<dd>指定立即数，可用作地址或数值
</dd>
</dl>
</dd>
</dl>
<h1 id="控制指令">控制指令</h1>
<h2 id="概述-1">概述</h2>
<ul class="incremental">
<li>包含两类跳转指令：有条件的和无条件的跳转指令</li>
<li>跳转与处理器状态标记有关</li>
<li>中断和异常也会触发跳转</li>
</ul>
<h2 id="无条件跳转">无条件跳转</h2>
<ul class="incremental">
<li>可将 CS 切换到另一个，称为 far control transfer</li>
<li>在同一个 segment 内跳转，称为 near control transfer</li>
</ul>
<h3 id="jump-instruction">Jump Instruction</h3>
<ul class="incremental">
<li>直接跳转，不会压栈</li>
<li>地址可以是直接指定的，也可以是寄存器间接寻址的
<ul class="incremental">
<li>Direct Near Jump： 使用相对偏移地址</li>
<li>Indirect Near Jump: 指定绝对地址
<ul class="incremental">
<li>通用寄存器（除 ESP 之外）内容回填 EIP</li>
<li>memory operand specified</li>
<li>修改 memory pointer 地址</li>
</ul></li>
</ul></li>
</ul>
<h3 id="call-instruction">Call Instruction</h3>
<ul class="incremental">
<li>Call Procedure，将 EIP 压栈，并在 RET 时弹出</li>
<li>地址有 relative, direct, indirect 三种</li>
<li>间接寻址有两种方式
<ul class="incremental">
<li>通用寄存器内容回填 EIP</li>
<li>从 memory operand 中获取</li>
</ul></li>
</ul>
<h3 id="return-and-return-from-interrupt-instruction">Return and Return-From-Interrupt Instruction</h3>
<dl class="incremental">
<dt>RET</dt>
<dd>从栈中恢复 EIP 到前一个 CALL 的位置，可以指定一个返回值（立即数）
</dd>
<dt>IRET</dt>
<dd>从中断处理中返回。不同于 RET，还会将栈上的 flags 恢复（中断时保存的现场）
</dd>
</dl>
<h2 id="有条件跳转">有条件跳转</h2>
<p>由 CPU 状态来决定是否跳转</p>
<h3 id="conditional-jump-instruction">Conditional Jump Instruction</h3>
<p><a href="80386/TABLE3-2.PNG">file:80386/TABLE3-2.PNG</a></p>
<ul class="incremental">
<li>条件跳转指令对 EIP 进行偏移</li>
<li>偏移可以为负，即可以向前跳转</li>
</ul>
<h3 id="loop-instructions">Loop Instructions</h3>
<ul class="incremental">
<li>loop 也是条件跳转，使用 ECX 的值作为循环次数</li>
<li>有五个循环指令： <code>LOOP</code>, <code>LOOPE</code>, <code>LOOPZ</code>, <code>LOOPNE</code>, <code>LOOPNZ</code></li>
<li>其中有四个通过 ZF 状态来判断是否结束循环</li>
</ul>
<ol class="incremental">
<li><p>LOOPE/LOOPZ</p>
<ul class="incremental">
<li>LOOPE: Loop While Equal</li>
<li>LOOPZ: Loop While Zero</li>
<li>两个指令有相同的作用</li>
<li>当 <code>(ECX-- &amp;&amp; ZF==1)</code> 时，跳转到 LABEL 处</li>
</ul></li>
<li><p>LOOPNE/LOOPNZ</p>
<ul class="incremental">
<li>当 <code>(ECX-- &amp;&amp; ZF==0)</code> 时，跳转到 LABEL 处</li>
</ul></li>
</ol>
<h3 id="executing-a-loop-or-repeat-zero-times"><span class="todo TODO">TODO</span> Executing a Loop or Repeat Zero Times</h3>
<ul class="incremental">
<li>JCXZ ( Jump If ECX Zero )</li>
<li>若 ECX 为 0，则跳转到 label 处</li>
<li>配合 LOOP 指令，用于 string scan 和比较操作</li>
</ul>
<h2 id="软件中断">软件中断</h2>
<h3 id="int-n">INT n</h3>
<ul class="incremental">
<li><code>INT n</code> 和 <code>BOUND</code> 允许跳转到配置的 interrupt service routine</li>
<li><code>INT n</code> 调用第 n 号软件中断，可以指定 interrupt type</li>
<li>中断号 0 到 31 被 intel 保留，用于内部异常</li>
<li>中断通过 <code>IRET</code> 来返回</li>
</ul>
<h3 id="int0">INT0</h3>
<ul class="incremental">
<li>Interrupt on Overflow</li>
<li>若 OF 被置位，则调用中断 4</li>
</ul>
<h3 id="bound">BOUND</h3>
<ul class="incremental">
<li>Detect Value Out of Range</li>
<li>检查特定寄存器中的有符号值是否在范围内</li>
<li>若不在范围内，则铖中断 5</li>
<li>BOUND 每一个参数是要被检查的寄存器</li>
<li>第二个是相对地址，指向高与低两个上下限</li>
<li>BOUND 可用于检查数组边界</li>
</ul>
<h1 id="内存管理">内存管理</h1>
<h2 id="概述-2">概述</h2>
<p>地址空间有三种视图：</p>
<ol class="incremental">
<li>physical address，32位最大寻址 4GB 空间</li>
<li>logical address，应用程序看到的地址空间，可以超过 4GB</li>
<li>linear address，经过段转换形成的空间，是 physical 和 logical 的中间态</li>
</ol>
<p>地址有两次转换，对应两种内存管理机制：分页和分段：</p>
<ol class="incremental">
<li>分段，内存访问对应于某个段空间，有长度限制</li>
<li>分页，分为 4k 的小段空间，映射到物理内存或虚拟内存中</li>
</ol>
<p>内存管理主要的任务有两个：</p>
<ol class="incremental">
<li>虚拟化内存（不同的进程看到独立的内存空间）</li>
<li>提供保护机制</li>
</ol>
<p>地址空间使用有多种范式，page model 是可选的。</p>
<ol class="incremental">
<li>flat model，所有的段都指向 0，直接访问 4GB 线性地址</li>
<li>segment model</li>
<li>segment + page model</li>
</ol>
<p>相比之下，paging 更为有用，segment 机制则深入 x86 设计的各方面，不可避免。</p>
<p>另外，segment 机制较 paging 优势在于，提供了 ring level 机制（即四个不同的运行级别，操作系统为 0，应用程序为 3），能更好的保护隐私信息。</p>
<h2 id="流程图"><span class="todo TODO">TODO</span> 流程图</h2>
<p><a href="./80386/FIG5-1.GIF" class="uri">./80386/FIG5-1.GIF</a></p>
<p>Paging enabled 的连线是否标注有误??</p>
<h2 id="segment-机制">segment 机制</h2>
<p>提供二维地址访问方式，将 logical 地址转换为 linear 地址，并提供内存保护机制。</p>
<p>核心的结构有四个：</p>
<ol class="incremental">
<li>Descriptor 定义每个段的基本属性</li>
<li>Descriptor Tables，保存系统定义的所有的段描述</li>
<li>Selector，段选择器，从段表中取出需要的段描述</li>
<li>Segment Register，缓存 selector 与 descritor 的对应关系</li>
</ol>
<p>段描述符的主要字段有</p>
<ol class="incremental">
<li>base 32bit，段的起始位置</li>
<li>limit 20bit，段的长度</li>
<li>granlarity, 长度度量：1字节或1page(4kB)</li>
<li>type, descriptor 类型</li>
<li>dpl，保护级别</li>
<li>segment-present，启用禁用</li>
<li>accessed，是否正加载到 segment register</li>
</ol>
<p>segment descriptor 分为两种 Global 和 Local。</p>
<ul class="incremental">
<li>系统有多个（8192个）descriptor，通过 GDT 和 LDT 来管理。</li>
<li>Interrupt Descriptor Table 与之类似</li>
<li>GDT 和 LDT 的位置（32bit）和长度（16bit）由 GDTR 和 LDTR 伪寄存器来保存</li>
<li><code>GDT[0]</code> 未被处理器使用</li>
</ul>
<p>程序使用时，需要指定要使用的段（通过段表的索引，称为选择器）。同时有 6 个寄存器用于缓存常用的段选择器与段描述符的对应关系，提高性能。</p>
<p>6 个段寄存器分别是 CS,DS,SS,ES,FS,GS。包括 16 位的可见选择器和 64 位不可见的缓存</p>
<ul class="incremental">
<li>CS 指定代码段, <code>CS:[EIP]</code> 指向下一个要执行的指令地址，同一时刻只有一个代码段可以寻址</li>
<li>DS 寻址指令比其它 5 个短一个字节，开销相对低，用于安排寻址经常被使用的数据段</li>
<li>SS 段为堆栈段，使用 <code>SS:[ESP]</code> 来指示栈顶地址</li>
</ul>
<h3 id="段偏移量">段偏移量</h3>
<ul class="incremental">
<li>包括三部分
<ol class="incremental">
<li>基地址寄存器</li>
<li>比例因子</li>
<li>变址寄存器（位移）</li>
</ol></li>
</ul>
<h3 id="分段的意义"><span class="todo TODO">TODO</span> 分段的意义</h3>
<ol class="incremental">
<li>内存保护</li>
<li>复用内存，将段交换到硬盘存储</li>
</ol>
<h3 id="segment-translation">Segment Translation</h3>
<ol class="incremental">
<li><p>概述</p>
<ul class="incremental">
<li>logical address 是多个分段下的连续地址, 分段以 base + limit 来指定</li>
<li>要使用 logical address, 需要找到基地址，并指定偏移。即 base + offset</li>
<li>基地址保存在　descriptor 结构中，系统维护有两张　descriptor 表，称为　GDT 和　LDT</li>
<li>selector　相当于一个索引，来从　descriptor table 中找到具体的 descriptor，进而找到相应的段</li>
<li>descriptor 由　compiler, linker, loader, os 等创建</li>
<li>实际使用中，会大量的提取　descriptor。为了提高效率，segment register 缓存了 selector 到　descriptor 的关系</li>
</ul></li>
<li><p>转换流程图</p>
<p><a href="80386/FIG5-2.GIF">file:80386/FIG5-2.GIF</a></p></li>
<li><p>Descriptor</p>
<ol class="incremental">
<li><p>分类</p>
<p>分为两类</p>
<ol class="incremental">
<li>for applications code and data segments</li>
<li>for special system segments</li>
</ol></li>
<li><p>示意图</p>
<p><a href="80386/FIG5-3.GIF">file:80386/FIG5-3.GIF</a></p></li>
<li><p>说明</p>
<ul class="incremental">
<li>base 保存基地址，由三部分构成，共 32 位</li>
<li>limit 由两部分构成，共 20 位</li>
<li>granularity 位是 Limit 长度标记，0 时 limit 单位为 1 字节，1 时 limit 单位为 4k 字节</li>
<li>type 用于区别两种格式</li>
<li>segmentPresent 标记是否适用于地址转换</li>
<li>accessed 标记是否正在被使用</li>
<li>limit 最大长度为 4G（当 granularity 为 1 时）</li>
<li>进程最大可以访问的 logical address 长度为 4G，达到虚拟进程访问空间的效果</li>
</ul></li>
</ol></li>
<li><p>Descriptor Tables</p>
<ol class="incremental">
<li><p>说明</p>
<ul class="incremental">
<li>分为 GDT 和 LDT 两类</li>
<li>其中保存的是 descriptor 结构（8 个字节），长度可变，最长 8192 个 descriptor</li>
<li>第一个 GDT 的 descriptor 不使用</li>
<li>GDTR 和 LDTR 寄存器，存储表的位置和长度</li>
<li>GDTR 的指令有： LGDT 和 SGDT</li>
<li>LDTR 的指令有： LLDT 和 SLDT</li>
</ul></li>
<li><p>示意</p>
<p><a href="80386/FIG5-5.GIF">file:80386/FIG5-5.GIF</a></p></li>
</ol></li>
<li><p>Selector</p>
<ol class="incremental">
<li><p>说明</p>
<ul class="incremental">
<li>selector 是到 descriptor table 的具体 descriptor 的索引</li>
<li>selector 的值一般由 linker 或 linking loader 来定义</li>
</ul></li>
<li><p>格式</p>
<p><a href="80386/FIG5-6.GIF">file:80386/FIG5-6.GIF</a></p>
<ul class="incremental">
<li>index 表示 8192 个 descriptor 的索引</li>
<li>Table Indicator 表示 GDT 或 LDT</li>
<li>RPL: Requested Privilege Level</li>
</ul></li>
</ol></li>
<li><p>Segment Registers</p>
<ol class="incremental">
<li><p>图示</p>
<p><a href="80386/FIG5-7.GIF">file:80386/FIG5-7.GIF</a></p></li>
<li><p>说明</p>
<ul class="incremental">
<li>segment register 包括了 CS, SS, DS，ES，FS，GS</li>
<li>包括两部分，第一部分是可见的 16 位，保存 selector</li>
<li>program loads the visible part of the segment register with a 16-bit register</li>
<li>处理器自动加载相应的 descriptor 到 segment register 的不可见部分</li>
<li>本质是缓存 selector 与 descritpro 的关系</li>
</ul></li>
</ol></li>
</ol>
<h3 id="补充">补充</h3>
<h3 id="问题">问题</h3>
<ol class="incremental">
<li><p>为什么有 64T 寻址空间</p>
<p>因为 selector 有 16 位，其中 descriptor table 的索引有 13 位，descriptor table 分为 GDT 和 LDT 两种，共 14 位，即 16K 空间。每个段内最大空间是 4G。因此最大可以寻址 64T 空间</p></li>
<li><p><span class="todo TODO">TODO</span> 操作系统如 Windows, Linux 看到的完整的 4G 空间，是否意味着使用 flat 模式？</p></li>
<li><p>不同进程中是否通过代码段切换？是否受 64k 的限制</p>
<ul class="incremental">
<li>segmented Model 将 16,383 个段映射到物理内存中，每个段最大有 4G 空间，最大寻址 64T</li>
<li>16 位的段选择子，32 位的地址偏移，总共提供了 64T 的寻址空间</li>
</ul></li>
</ol>

			</div>
		</section>
	</body>
</html>
