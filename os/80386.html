<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2017-08-26 六 09:10 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Note on 80386 reference</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Zhao WenBin">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Note on 80386 reference</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf3070fc">寄存器</a></li>
<li><a href="#org5c0c142">数据类型</a></li>
<li><a href="#orge3489a0">指令格式</a></li>
<li><a href="#org60bdd81">控制指令</a></li>
<li><a href="#org9d3d280">内存管理</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orgf3070fc" class="outline-2">
<h2 id="orgf3070fc">寄存器</h2>
<div class="outline-text-2" id="text-orgf3070fc">
</div><div id="outline-container-org744e86c" class="outline-3">
<h3 id="org744e86c">分类</h3>
<div class="outline-text-3" id="text-org744e86c">
<p>
有三类寄存器（对应用程序开发）
</p>

<ol class="org-ol">
<li>通用目的寄存器，8个，32位</li>
<li>segment register，6个，16位</li>
<li>status and instruction register，两个，分别是 EFLAG 和 EIP</li>
</ol>
</div>
</div>

<div id="outline-container-orgb4b48bc" class="outline-3">
<h3 id="orgb4b48bc">通用目的寄存器</h3>
<div class="outline-text-3" id="text-orgb4b48bc">
<ul class="org-ul">
<li>8 个通用寄存器（32位）用于保存基地址和进行运算</li>
<li>分别是 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI</li>
<li>ESP 不能用于地址索引</li>
<li>兼容 8086 和 80286 处理器，后 16 位可以单独使用</li>
<li>AX, BX, CX, DX 可进而拆分为高、低 8 位</li>
<li>部分指令要求使用到特定的寄存器（或使用特定寄存器能使指令更加紧凑）</li>
<li>某些字符串处理指令使用 ES 寄存器</li>
</ul>
</div>
</div>

<div id="outline-container-orgdc58519" class="outline-3">
<h3 id="orgdc58519">Segment Register</h3>
<div class="outline-text-3" id="text-orgdc58519">
<ul class="org-ul">
<li>程序可能由不同部件组成</li>
<li>同一时刻只能有一部分段在使用</li>
<li>分段内存下，可以直接访问当下的段，并在有需求时访问其它的 segment</li>
<li>CS 会在 CALL、JMP，interrupt 和 exception 中被隐式的切换</li>
<li>DS,ES,FS,GS 寄存器可指定四个 data segments，有助于在不同的类型结构中进行切换</li>
</ul>
</div>

<div id="outline-container-orge3341c5" class="outline-4">
<h4 id="orge3341c5">Stack Implements</h4>
<div class="outline-text-4" id="text-orge3341c5">
<ol class="org-ol">
<li>SS 寄存器。可以有多个栈，栈操作会自动引用 SS 中的段</li>
<li>ESP（ Stack Pointer ），指向栈底，栈向低地址增长</li>
<li>EBP（ Stack Base Pointer），栈的相对地址</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org9abd33b" class="outline-3">
<h3 id="org9abd33b">Status and Instruction Register</h3>
<div class="outline-text-3" id="text-org9abd33b">
</div><div id="outline-container-org4d9d977" class="outline-4">
<h4 id="org4d9d977">EFLAGS</h4>
<div class="outline-text-4" id="text-org4d9d977">
<ul class="org-ul">
<li>32 位，标志处理器状态</li>
<li>低 16 位称为 FLAGS，用于兼容 8086 和 80286</li>
<li>分为三组标识
<ol class="org-ol">
<li>status flag: OF,SF,ZF,AF,PF,CF</li>
<li>control flag: DF（方向）</li>
<li>system flags</li>
</ol></li>
</ul>
</div>
</div>

<div id="outline-container-org6df88b2" class="outline-4">
<h4 id="org6df88b2">EIP</h4>
<div class="outline-text-4" id="text-org6df88b2">
<ul class="org-ul">
<li>Extended Instruction Pointer</li>
<li>对程序员不可见，通过 control-transfer， interrupt 和 exception 进行修改</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-org5c0c142" class="outline-2">
<h2 id="org5c0c142">数据类型</h2>
<div class="outline-text-2" id="text-org5c0c142">
</div><div id="outline-container-orgf2d7dee" class="outline-3">
<h3 id="orgf2d7dee">基本类型</h3>
<div class="outline-text-3" id="text-orgf2d7dee">
<ul class="org-ul">
<li>三种基本类型，分别是 byte, word, doubleword</li>
<li>bit zero is the least significant bit</li>
<li>低字节（地址）中含有低有效位</li>
<li>字节度中位值随地址增大而增大，称为 little endian</li>
<li>Intel 架构是小端字节序</li>
<li>CPU 和内存之间是 32 位总线，内存不对齐会降低处理效率</li>
<li>数据结构尽可能保证内存对齐</li>
<li>指令因为 CPU 预取指机制而无需对齐</li>
</ul>
</div>
</div>

<div id="outline-container-org9f1bea0" class="outline-3">
<h3 id="org9f1bea0">Additional Data Type</h3>
<div class="outline-text-3" id="text-org9f1bea0">
<ul class="org-ul">
<li>Integer，对应于 C 中的 char, short 和 int</li>
<li>Ordinal, 无符号整型</li>
<li>Near Pointer，指针类型，32 位，用于在 flat 或 segment model 中表示 offset</li>
<li>Far Pointer，48 位地址，包括 segment selector(16位） 和 offset（32位） 两部分，只能在 segment 下使用</li>
<li>String，最大 \((2^32)-1\) 字节</li>
<li>Bit field，最大 32 位</li>
<li>Bit String，最大 \((2^32)-1\) 位</li>
<li>BCD，用后半字节表示 0到9 的数字</li>
<li>Packed BCD，两个半字节来表示 0 到 99 的数字</li>
</ul>
</div>
</div>

<div id="outline-container-org05303b0" class="outline-3">
<h3 id="org05303b0">图示</h3>
<div class="outline-text-3" id="text-org05303b0">

<figure>
<img src="80386/FIG2-4.GIF" alt="FIG2-4.GIF">

</figure>
</div>
</div>
</div>










<div id="outline-container-orge3489a0" class="outline-2">
<h2 id="orge3489a0">指令格式</h2>
<div class="outline-text-2" id="text-orge3489a0">
</div><div id="outline-container-org5ee9f0e" class="outline-3">
<h3 id="org5ee9f0e">概述</h3>
<div class="outline-text-3" id="text-org5ee9f0e">
<ul class="org-ul">
<li>指令中反映出操作类型、操作数类型、操作数位置；其中隐含有寻址的方式</li>
<li>指令有可变长个元素组成，由 opcode 个可选个其它参数组成（用于表示操作数类型和位置）</li>
</ul>
</div>
</div>

<div id="outline-container-orgf31e8f6" class="outline-3">
<h3 id="orgf31e8f6">元素</h3>
<div class="outline-text-3" id="text-orgf31e8f6">
<dl class="org-dl">
<dt>Prefix</dt><dd>用于修饰指令操作数
<dl class="org-dl">
<dt>Segment override</dt><dd>用于显式地指定段寄存器（替换默认的段寄存器）</dd>
<dt>Address size</dt><dd>在 32 和 16 位地址类型之间切换</dd>
<dt>Operand size</dt><dd>在 32 和 16 位操作数类型之间切换</dd>
<dt>Repeat</dt><dd>循环对字符串的每个字进行操作</dd>
</dl></dd>
<dt>Opcode</dt><dd>指令操作类型，可多态</dd>
<dt>Register specifier</dt><dd>寄存器指定操作数</dd>
<dt>Address-Model Specifier</dt><dd>指定地址信息
<dl class="org-dl">
<dt>SIB(Scale, index, base)</dt><dd>通过基地址加偏移量指定位置</dd>
<dt>Displacement</dt><dd>通过偏移量指定位置</dd>
<dt>Immediate Operand</dt><dd>指定立即数，可用作地址或数值</dd>
</dl></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org60bdd81" class="outline-2">
<h2 id="org60bdd81">控制指令</h2>
<div class="outline-text-2" id="text-org60bdd81">
</div><div id="outline-container-org2172116" class="outline-3">
<h3 id="org2172116">概述</h3>
<div class="outline-text-3" id="text-org2172116">
<ul class="org-ul">
<li>包含两类跳转指令：有条件的和无条件的跳转指令</li>
<li>跳转与处理器状态标记有关</li>
<li>中断和异常也会触发跳转</li>
</ul>
</div>
</div>

<div id="outline-container-orga80c28f" class="outline-3">
<h3 id="orga80c28f">无条件跳转</h3>
<div class="outline-text-3" id="text-orga80c28f">
<ul class="org-ul">
<li>可将 CS 切换到另一个，称为 far control transfer</li>
<li>在同一个 segment 内跳转，称为 near control transfer</li>
</ul>
</div>

<div id="outline-container-org3ac4867" class="outline-4">
<h4 id="org3ac4867">Jump Instruction</h4>
<div class="outline-text-4" id="text-org3ac4867">
<ul class="org-ul">
<li>直接跳转，不会压栈</li>
<li>地址可以是直接指定的，也可以是寄存器间接寻址的
<ul class="org-ul">
<li>Direct Near Jump： 使用相对偏移地址</li>
<li>Indirect Near Jump: 指定绝对地址
<ul class="org-ul">
<li>通用寄存器（除 ESP 之外）内容回填 EIP</li>
<li>memory operand specified</li>
<li>修改 memory pointer 地址</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgbaf53c9" class="outline-4">
<h4 id="orgbaf53c9">Call Instruction</h4>
<div class="outline-text-4" id="text-orgbaf53c9">
<ul class="org-ul">
<li>Call Procedure，将 EIP 压栈，并在 RET 时弹出</li>
<li>地址有 relative, direct, indirect 三种</li>
<li>间接寻址有两种方式
<ul class="org-ul">
<li>通用寄存器内容回填 EIP</li>
<li>从 memory operand 中获取</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org1a72ad2" class="outline-4">
<h4 id="org1a72ad2">Return and Return-From-Interrupt Instruction</h4>
<div class="outline-text-4" id="text-org1a72ad2">
<dl class="org-dl">
<dt>RET</dt><dd>从栈中恢复 EIP 到前一个 CALL 的位置，可以指定一个返回值（立即数）</dd>
<dt>IRET</dt><dd>从中断处理中返回。不同于 RET，还会将栈上的 flags 恢复（中断时保存的现场）</dd>
</dl>
</div>
</div>
</div>


<div id="outline-container-org458643d" class="outline-3">
<h3 id="org458643d">有条件跳转</h3>
<div class="outline-text-3" id="text-org458643d">
<p>
由 CPU 状态来决定是否跳转
</p>
</div>

<div id="outline-container-orgd7b09ab" class="outline-4">
<h4 id="orgd7b09ab">Conditional Jump Instruction</h4>
<div class="outline-text-4" id="text-orgd7b09ab">

<figure>
<img src="80386/TABLE3-2.PNG" alt="TABLE3-2.PNG">

</figure>

<ul class="org-ul">
<li>条件跳转指令对 EIP 进行偏移</li>
<li>偏移可以为负，即可以向前跳转</li>
</ul>
</div>
</div>

<div id="outline-container-org13adf0f" class="outline-4">
<h4 id="org13adf0f">Loop Instructions</h4>
<div class="outline-text-4" id="text-org13adf0f">
<ul class="org-ul">
<li>loop 也是条件跳转，使用 ECX 的值作为循环次数</li>
<li>有五个循环指令： <code>LOOP</code>, <code>LOOPE</code>, <code>LOOPZ</code>, <code>LOOPNE</code>, <code>LOOPNZ</code></li>
<li>其中有四个通过 ZF 状态来判断是否结束循环</li>
</ul>
</div>

<ul class="org-ul"><li><a id="org92c820d"></a>LOOPE/LOOPZ<br><div class="outline-text-5" id="text-org92c820d">
<ul class="org-ul">
<li>LOOPE: Loop While Equal</li>
<li>LOOPZ: Loop While Zero</li>
<li>两个指令有相同的作用</li>
<li>当  <code>(ECX-- &amp;&amp; ZF==1)</code> 时，跳转到 LABEL 处</li>
</ul>
</div></li>

<li><a id="orga6cedd8"></a>LOOPNE/LOOPNZ<br><div class="outline-text-5" id="text-orga6cedd8">
<ul class="org-ul">
<li>当 <code>(ECX-- &amp;&amp; ZF==0)</code> 时，跳转到 LABEL 处</li>
</ul>
</div></li></ul>
</div>


<div id="outline-container-orgaf32d1b" class="outline-4">
<h4 id="orgaf32d1b"><span class="todo TODO">TODO</span> Executing a Loop or Repeat Zero Times</h4>
<div class="outline-text-4" id="text-orgaf32d1b">
<ul class="org-ul">
<li>JCXZ ( Jump If ECX Zero )</li>
<li>若 ECX 为 0，则跳转到 label 处</li>
<li>配合 LOOP 指令，用于 string scan 和比较操作</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-org01626fb" class="outline-3">
<h3 id="org01626fb">软件中断</h3>
<div class="outline-text-3" id="text-org01626fb">
</div><div id="outline-container-orgd902a44" class="outline-4">
<h4 id="orgd902a44">INT n</h4>
<div class="outline-text-4" id="text-orgd902a44">
<ul class="org-ul">
<li><code>INT n</code> 和 <code>BOUND</code> 允许跳转到配置的 interrupt service routine</li>
<li><code>INT n</code> 调用第 n 号软件中断，可以指定 interrupt type</li>
<li>中断号 0 到 31 被 intel 保留，用于内部异常</li>
<li>中断通过 <code>IRET</code> 来返回</li>
</ul>
</div>
</div>

<div id="outline-container-orgd4d10c9" class="outline-4">
<h4 id="orgd4d10c9">INT0</h4>
<div class="outline-text-4" id="text-orgd4d10c9">
<ul class="org-ul">
<li>Interrupt on Overflow</li>
<li>若 OF 被置位，则调用中断 4</li>
</ul>
</div>
</div>

<div id="outline-container-org1cbae92" class="outline-4">
<h4 id="org1cbae92">BOUND</h4>
<div class="outline-text-4" id="text-org1cbae92">
<ul class="org-ul">
<li>Detect Value Out of Range</li>
<li>检查特定寄存器中的有符号值是否在范围内</li>
<li>若不在范围内，则铖中断 5</li>
<li>BOUND 每一个参数是要被检查的寄存器</li>
<li>第二个是相对地址，指向高与低两个上下限</li>
<li>BOUND 可用于检查数组边界</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org9d3d280" class="outline-2">
<h2 id="org9d3d280">内存管理</h2>
<div class="outline-text-2" id="text-org9d3d280">
</div><div id="outline-container-orgfdbc8ba" class="outline-3">
<h3 id="orgfdbc8ba">概述</h3>
<div class="outline-text-3" id="text-orgfdbc8ba">
<p>
地址空间有三种视图：
</p>

<ol class="org-ol">
<li>physical address，32位最大寻址 4GB 空间</li>
<li>logical address，应用程序看到的地址空间，可以超过 4GB</li>
<li>linear address，经过段转换形成的空间，是 physical 和 logical 的中间态</li>
</ol>

<p>
地址有两次转换，对应两种内存管理机制：分页和分段：
</p>

<ol class="org-ol">
<li>分段，内存访问对应于某个段空间，有长度限制</li>
<li>分页，分为 4k 的小段空间，映射到物理内存或虚拟内存中</li>
</ol>

<p>
内存管理主要的任务有两个：
</p>

<ol class="org-ol">
<li>虚拟化内存（不同的进程看到独立的内存空间）</li>
<li>提供保护机制</li>
</ol>

<p>
地址空间使用有多种范式，page model 是可选的。
</p>

<ol class="org-ol">
<li>flat model，所有的段都指向 0，直接访问 4GB 线性地址</li>
<li>segment model</li>
<li>segment + page model</li>
</ol>

<p>
相比之下，paging 更为有用，segment 机制则深入 x86 设计的各方面，不可避免。
</p>

<p>
另外，segment 机制较 paging 优势在于，提供了 ring level 机制（即四个不同的运行级别，操作系统为 0，应用程序为 3），能更好的保护隐私信息。
</p>
</div>
</div>

<div id="outline-container-orgeeaa8ea" class="outline-3">
<h3 id="orgeeaa8ea"><span class="todo TODO">TODO</span> 流程图</h3>
<div class="outline-text-3" id="text-orgeeaa8ea">

<figure>
<img src="./80386/FIG5-1.GIF" alt="FIG5-1.GIF">

</figure>

<p>
Paging enabled 的连线是否标注有误??
</p>
</div>
</div>

<div id="outline-container-org0ccbdaf" class="outline-3">
<h3 id="org0ccbdaf">segment 机制</h3>
<div class="outline-text-3" id="text-org0ccbdaf">
<p>
提供二维地址访问方式，将 logical 地址转换为 linear 地址，并提供内存保护机制。
</p>

<p>
核心的结构有四个：
</p>

<ol class="org-ol">
<li>Descriptor 定义每个段的基本属性</li>
<li>Descriptor Tables，保存系统定义的所有的段描述</li>
<li>Selector，段选择器，从段表中取出需要的段描述</li>
<li>Segment Register，缓存 selector 与 descritor 的对应关系</li>
</ol>

<p>
段描述符的主要字段有
</p>

<ol class="org-ol">
<li>base 32bit，段的起始位置</li>
<li>limit 20bit，段的长度</li>
<li>granlarity, 长度度量：1字节或1page(4kB)</li>
<li>type, descriptor 类型</li>
<li>dpl，保护级别</li>
<li>segment-present，启用禁用</li>
<li>accessed，是否正加载到 segment register</li>
</ol>

<p>
segment descriptor 分为两种 Global 和 Local。
</p>

<ul class="org-ul">
<li>系统有多个（8192个）descriptor，通过 GDT 和 LDT 来管理。</li>
<li>Interrupt Descriptor Table 与之类似</li>
<li>GDT 和 LDT 的位置（32bit）和长度（16bit）由 GDTR 和 LDTR 伪寄存器来保存</li>
<li><code>GDT[0]</code> 未被处理器使用</li>
</ul>

<p>
程序使用时，需要指定要使用的段（通过段表的索引，称为选择器）。同时有 6 个寄存器用于缓存常用的段选择器与段描述符的对应关系，提高性能。
</p>

<p>
6 个段寄存器分别是 CS,DS,SS,ES,FS,GS。包括 16 位的可见选择器和 64 位不可见的缓存
</p>

<ul class="org-ul">
<li>CS 指定代码段, <code>CS:[EIP]</code> 指向下一个要执行的指令地址，同一时刻只有一个代码段可以寻址</li>
<li>DS 寻址指令比其它 5 个短一个字节，开销相对低，用于安排寻址经常被使用的数据段</li>
<li>SS 段为堆栈段，使用 <code>SS:[ESP]</code> 来指示栈顶地址</li>
</ul>
</div>


<div id="outline-container-org733a9ee" class="outline-4">
<h4 id="org733a9ee">段偏移量</h4>
<div class="outline-text-4" id="text-org733a9ee">
<ul class="org-ul">
<li>包括三部分
<ol class="org-ol">
<li>基地址寄存器</li>
<li>比例因子</li>
<li>变址寄存器（位移）</li>
</ol></li>
</ul>
</div>
</div>

<div id="outline-container-org95b8286" class="outline-4">
<h4 id="org95b8286"><span class="todo TODO">TODO</span> 分段的意义</h4>
<div class="outline-text-4" id="text-org95b8286">
<ol class="org-ol">
<li>内存保护</li>
<li>复用内存，将段交换到硬盘存储</li>
</ol>
</div>
</div>

<div id="outline-container-org7de46e0" class="outline-4">
<h4 id="org7de46e0">Segment Translation</h4>
<div class="outline-text-4" id="text-org7de46e0">
</div><ul class="org-ul"><li><a id="orga7ed0b9"></a>概述<br><div class="outline-text-5" id="text-orga7ed0b9">
<ul class="org-ul">
<li>logical address 是多个分段下的连续地址, 分段以 base + limit 来指定</li>
<li>要使用 logical address, 需要找到基地址，并指定偏移。即 base + offset</li>
<li>基地址保存在　descriptor 结构中，系统维护有两张　descriptor 表，称为　GDT 和　LDT</li>
<li>selector　相当于一个索引，来从　descriptor table 中找到具体的 descriptor，进而找到相应的段</li>
<li>descriptor 由　compiler, linker, loader, os 等创建</li>
<li>实际使用中，会大量的提取　descriptor。为了提高效率，segment register 缓存了 selector 到　descriptor 的关系</li>
</ul>
</div></li>

<li><a id="org52b723a"></a>转换流程图<br><div class="outline-text-5" id="text-org52b723a">

<figure>
<img src="80386/FIG5-2.GIF" alt="FIG5-2.GIF">

</figure>
</div></li>

<li><a id="org6d6594e"></a>Descriptor<br><ul class="org-ul"><li><a id="org3e38e2c"></a>分类<br><div class="outline-text-6" id="text-org3e38e2c">
<p>
分为两类
</p>

<ol class="org-ol">
<li>for applications code and data segments</li>
<li>for special system segments</li>
</ol>
</div></li>

<li><a id="org72161b0"></a>示意图<br><div class="outline-text-6" id="text-org72161b0">

<figure>
<img src="80386/FIG5-3.GIF" alt="FIG5-3.GIF">

</figure>
</div></li>

<li><a id="orgb8510e1"></a>说明<br><div class="outline-text-6" id="text-orgb8510e1">
<ul class="org-ul">
<li>base 保存基地址，由三部分构成，共 32 位</li>
<li>limit 由两部分构成，共 20 位</li>
<li>granularity 位是 Limit 长度标记，0 时 limit 单位为 1 字节，1 时 limit 单位为 4k 字节</li>
<li>type 用于区别两种格式</li>
<li>segmentPresent 标记是否适用于地址转换</li>
<li>accessed 标记是否正在被使用</li>
<li>limit 最大长度为 4G（当 granularity 为 1 时）</li>
<li>进程最大可以访问的 logical address 长度为 4G，达到虚拟进程访问空间的效果</li>
</ul>
</div></li></ul></li>



<li><a id="org2053086"></a>Descriptor Tables<br><ul class="org-ul"><li><a id="org8823c02"></a>说明<br><div class="outline-text-6" id="text-org8823c02">
<ul class="org-ul">
<li>分为 GDT 和 LDT 两类</li>
<li>其中保存的是 descriptor 结构（8 个字节），长度可变，最长 8192 个 descriptor</li>
<li>第一个 GDT 的 descriptor 不使用</li>
<li>GDTR 和 LDTR 寄存器，存储表的位置和长度</li>
<li>GDTR 的指令有： LGDT 和 SGDT</li>
<li>LDTR 的指令有： LLDT 和 SLDT</li>
</ul>
</div></li>


<li><a id="org1becff8"></a>示意<br><div class="outline-text-6" id="text-org1becff8">

<figure>
<img src="80386/FIG5-5.GIF" alt="FIG5-5.GIF">

</figure>
</div></li></ul></li>

<li><a id="orgcb8eb04"></a>Selector<br><ul class="org-ul"><li><a id="orgfe069c2"></a>说明<br><div class="outline-text-6" id="text-orgfe069c2">
<ul class="org-ul">
<li>selector 是到 descriptor table 的具体 descriptor 的索引</li>
<li>selector 的值一般由 linker 或 linking loader 来定义</li>
</ul>
</div></li>

<li><a id="org374df13"></a>格式<br><div class="outline-text-6" id="text-org374df13">

<figure>
<img src="80386/FIG5-6.GIF" alt="FIG5-6.GIF">

</figure>


<ul class="org-ul">
<li>index 表示 8192 个 descriptor 的索引</li>
<li>Table Indicator 表示 GDT 或 LDT</li>
<li>RPL: Requested Privilege Level</li>
</ul>
</div></li></ul></li>


<li><a id="orgc6d1b7c"></a>Segment Registers<br><ul class="org-ul"><li><a id="orgb317150"></a>图示<br><div class="outline-text-6" id="text-orgb317150">

<figure>
<img src="80386/FIG5-7.GIF" alt="FIG5-7.GIF">

</figure>
</div></li>

<li><a id="orgd45b163"></a>说明<br><div class="outline-text-6" id="text-orgd45b163">
<ul class="org-ul">
<li>segment register 包括了 CS, SS, DS，ES，FS，GS</li>
<li>包括两部分，第一部分是可见的 16 位，保存 selector</li>
<li>program loads the visible part of the segment register with a 16-bit register</li>
<li>处理器自动加载相应的 descriptor 到 segment register 的不可见部分</li>
<li>本质是缓存 selector 与 descritpro 的关系</li>
</ul>
</div></li></ul></li></ul>
</div>

<div id="outline-container-orgd1bddca" class="outline-4">
<h4 id="orgd1bddca">补充</h4>
</div>
<div id="outline-container-org53c0150" class="outline-4">
<h4 id="org53c0150">问题</h4>
<div class="outline-text-4" id="text-org53c0150">
</div><ul class="org-ul"><li><a id="orgf2cbb4f"></a>为什么有 64T 寻址空间<br><div class="outline-text-5" id="text-orgf2cbb4f">
<p>
因为 selector 有 16 位，其中 descriptor table 的索引有 13 位，descriptor table 分为 GDT 和 LDT 两种，共 14 位，即 16K 空间。每个段内最大空间是 4G。因此最大可以寻址 64T 空间
</p>
</div></li>

<li><a id="org66b6d06"></a><span class="todo TODO">TODO</span> 操作系统如 Windows, Linux 看到的完整的 4G 空间，是否意味着使用 flat 模式？<br></li>
<li><a id="orgf1f2b6a"></a>不同进程中是否通过代码段切换？是否受 64k 的限制<br><div class="outline-text-5" id="text-orgf1f2b6a">
<ul class="org-ul">
<li>segmented Model 将 16,383 个段映射到物理内存中，每个段最大有 4G 空间，最大寻址 64T</li>
<li>16 位的段选择子，32 位的地址偏移，总共提供了 64T 的寻址空间</li>
</ul>
</div></li></ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Zhao WenBin</p>
<p class="date">Created: 2017-08-26 六 09:10</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
