#+TITLE: 无闻 Go 视频教程笔记
#+AUTHOR: Zhao WenBin

* Go 开发环境搭建

** Go 基本介绍

- 类型安全，内存安全
- 支持并发
- 垃圾回收
- 快速编译（严格要示，不能有未被使用的导入，未使用的变量，不需要头文件）
- 快速编译
- UTF8 支持

** 安装，环境变量，目录

go 通过环境变量来设置参数，常见的有

- GOROOT
- GOPATH: 开发目录，其中包括 bin, pkg, src 等
- GOARCH
- GOHOSTARCH

其中 =${GOPATH}/bin= 保存生成的可执行文件， =${GOPATH}/pkg= 下保存生成的具体平台的库文件

** 命令

常见命令有

- build <main-src>
- install
- test
- doc
- fmt

* Go 基础知识

** 关键字

其有 25 个关键字，其中特殊的如 type, go, defer, interface, chan, default, fallthrough

** 注释方法

与 C++ 相同

** 代码文件的一般结构

1. package
2. import
3. const
4. var
5. type 定义 struct 或 interface
6. func

** import 小技巧

1. 别名： =import std "fmt"=
2. 省略调用： =import . "fmt"= ，类似于 python 中 =from fmt import *= ，慎用!

** 可见性规则

通过首字母大写来判定可见性

** import, var, const 简写

对于多个 import, var, const 可以合并，写在圆括号内（并可以用一条注释整体）

* 类型与变量

** 基本类型

- 布尔型: bool，取值只能是 true 或者 false
- 整型: uint/int（平台相关大小），uint/int{8,16,32,64} 指定范围
- 字节型: byte，是 uint8 的别名
- rune 型: 是 int32 的别名
- 浮点型: float32/float64
- 复数: complex64/complex128
- 指针: uintptr（与平台有关）

** 复合类型

- array
- struct
- string
- slice
- map
- chan
- interface
- func: 第一类成员

** 零值

每种类型都有默认零值，如 0, false, ""

** 类型别名

- 用 =type= 来定义别名
- 使用单独的类型，使逻辑更清晰（也可以定义不同方法）
- =type= 可以同 import, var, const 使用圆括号一次定义多个
- 别名类型之间需要显式的转换（但 uint8 与 byte, int32 与 rune 之间不需要）

** math

math 模块中有 MaxXX 与 MinXX，表示了不同类型的取值范围

** 变量的声明与赋值

- =var= 声明变量，需要指定类型
- ~=~ 进行赋值，可以对多个变量赋值
- 声明与赋值可以放在一起进行，这时编译器会自动推导类型，因此类型标注可以省略
- 在函数内可以用 ~:=~ 语法来进行声明与赋值
- 函数内可以用 =var()= 定义多个变量 （但不建议使用）
- 全局不能使用 ~:=~ 语法

** 空白符号

=_= 用于捕获无用的变量

** 类型转换

- 只能在兼容的类型之间进行

* 常量与运算符

** 常量

- 常量的值在编译时确定
- 常量定义时，右值为常量（字面）或常量表达式（使用内置函数进行计算）
- 如果未指定右值，则使用上行表达式
- 通过 const 组与 iota 计数器模拟枚举类型（iota 在组内，每定义一个常量增大一）
- 常量一般命名成全大写（加下划线）或骆驼写法

** 范式

#+BEGIN_SRC go
const (
        Readble = 1 << iota
        Writable
        Executable
)

const (
        B float64 = 1 << (iota * 10)
        KB
        MB
        GB
        TB
        PB
        ZB
        EB
)
#+END_SRC

** 运算符

Go 中的运算符统一从左向右结合

下面举例说明

- 一元取反 =^=
- =<<=, =>>= 左右移
- 二元位运算符 =&= =|= =^= =&^= (AND NOT, bit clean，反向取 mask 作用，可以将 =a&^b= 看作 =a&(^b)=)
- =<-= channel 专用

* 控制语句

** 指针

- 不支持指针运算
- 没有 =->= 操作符
- 默认指针空值为 =nil=
- 用 =&= 取址，用 =*= 解引用
- =++=, =--= 为语句（statement），而非表达式（expression）


** 判断 if

- 条件不用加括号
- 支持一个初始化表达式（值作用域限定在 if 块中）
- ={= 必须与 if 放在同一行

** 循环语句

1. ~for {}~
2. ~for a < 3 {}~
3. ~for i := 0; i < 10; i++~

** switch 语句

- 可以用任何类型和表达式作分支
- 支持初始化表达式（同 if）
- 不用为每个 case 作 break，相反应该加入 fallthrough 如果不需要跳出

例子如下

#+BEGIN_SRC go
switch a {
  case 0: fmt.Println("0")
  case 1: fmt.Println("1")
  default: fmt.Println("other")
}

switch {
  case a < 0: fmt.Println("invalid")
  case a < 10: fmt.Println("good")
  default: fmt.Println("too large")
}
#+END_SRC

** 跳转语句（goto, continue, break)

continue 和 break 均支持标签（label），将跳转到与标签同级的循环中

* 数组 Array

Go 的数组类型由元素类型（type）和长度（n）构成。不同于 C 或其它语言，Go 的数组是值类型，意味着做为参数传递时，会进行拷贝。

同类型数组对象，可以用 ~==~ 和 ~!=~ 进行比较，可以用 ~=~ 进行赋值（拷贝）

** 数组指针

- 可以用 =new([10]int)= 来创建一个指向数组的指针
- 也可以引用数组的地址，生成一个数组的指针： ~var p *[100]int = &a~
- 无论数组本身，还是数组指针，都可以使用下标来索引内容，如 =p[99]= 或 =a[10]=

** 指针的数组

表示数组的内容为指针

#+BEGIN_SRC go
a := 10
b := 10
c := [...]*int{&a, &b}
#+END_SRC

** 字面量

#+BEGIN_SRC go
a := [2]int{1}
b := [2]int{1,2}
c := [20]int{19:1}
d := [...]int{99:1}
e := [2][3]int{
  {1:1},
  {2:2},
}
// 多维数组第一维可以自动推导
f := [...][3]int{
  {1:1},
  {2:2},
}
#+END_SRC


* 切片 Slice

- 切片是对底层数组结构的引用类型（可以建立对同一数组的多个引用，也可以对切片建立新的引用切片）
- 做为变长数组的替代方案，关联到底层数组的全部或局部
- 对 slice 作切片（reslice），以 slice 切片为准，不能超出 cap 索引，否则会越界错误
- 除了类型和长度外，还有 cap 属性
- 通过 =make([]type, len, cap)= 来创建一个 slice
- =append(slice, e1, e2, ..., en)= 向 slice 添加元素，如果需要将扩容（一倍）
- 扩容将生成新的底层数组，涉及数据的拷贝，如果已经确定大小，可以预先放大 cap 容量
- =copy(dst, src []type)= 对索引进行拷贝
- 使用 ~c := a[:]~ 来生成完全的索引

* 常用库

** strconv

- Itoa 转换数字到字符串

** math

- MaxXX, MinXX 记录类型的取值范围

* 问题

** TODO 类型转换是静态的？还是动态的？有没有开销

** TODO =string= 与 =[]byte= 与 =[]rune= 的关系

** TODO =[10]int= 与 =[]int= 的区别

** TODO =[...]int{1,2,3}= 与 =[]int{1,2,3}= 的区别
** TODO ~for i := 0; i < len(a); i++~ 中 =len(a)= 是否会造成额外的开销

* 外部链接

- Go 在谷歌：以软件工程为目的的语言设计
