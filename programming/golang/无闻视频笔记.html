<!DOCTYPE html>
<html>
	<head>
		<title>无闻视频笔记.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="go-开发环境搭建">Go 开发环境搭建</h1>
<h2 id="go-基本介绍">Go 基本介绍</h2>
<ul class="incremental">
<li>类型安全，内存安全</li>
<li>支持并发</li>
<li>垃圾回收</li>
<li>快速编译（严格要示，不能有未被使用的导入，未使用的变量，不需要头文件）</li>
<li>快速编译</li>
<li>UTF8 支持</li>
</ul>
<h2 id="安装环境变量目录">安装，环境变量，目录</h2>
<p>go 通过环境变量来设置参数，常见的有</p>
<ul class="incremental">
<li>GOROOT</li>
<li>GOPATH: 开发目录，其中包括 bin, pkg, src 等</li>
<li>GOARCH</li>
<li>GOHOSTARCH</li>
</ul>
<p>其中 <code>${GOPATH}/bin</code> 保存生成的可执行文件， <code>${GOPATH}/pkg</code> 下保存生成的具体平台的库文件</p>
<h2 id="命令">命令</h2>
<p>常见命令有</p>
<ul class="incremental">
<li>build &lt;main-src&gt;</li>
<li>install</li>
<li>test</li>
<li>doc</li>
<li>fmt</li>
</ul>
<h1 id="go-基础知识">Go 基础知识</h1>
<h2 id="关键字">关键字</h2>
<p>其有 25 个关键字，其中特殊的如 type, go, defer, interface, chan, default, fallthrough</p>
<h2 id="注释方法">注释方法</h2>
<p>与 C++ 相同</p>
<h2 id="代码文件的一般结构">代码文件的一般结构</h2>
<ol class="incremental">
<li>package</li>
<li>import</li>
<li>const</li>
<li>var</li>
<li>type 定义 struct 或 interface</li>
<li>func</li>
</ol>
<h2 id="import-小技巧">import 小技巧</h2>
<ol class="incremental">
<li>别名： =import std &quot;fmt&quot;=</li>
<li>省略调用： <code>import . &quot;fmt&quot;= ，类似于 python 中 =from fmt import *</code> ，慎用!</li>
</ol>
<h2 id="可见性规则">可见性规则</h2>
<p>通过首字母大写来判定可见性</p>
<h2 id="import-var-const-简写">import, var, const 简写</h2>
<p>对于多个 import, var, const 可以合并，写在圆括号内（并可以用一条注释整体）</p>
<h1 id="类型与变量">类型与变量</h1>
<h2 id="基本类型">基本类型</h2>
<ul class="incremental">
<li>布尔型: bool，取值只能是 true 或者 false</li>
<li>整型: uint/int（平台相关大小），uint/int{8,16,32,64} 指定范围</li>
<li>字节型: byte，是 uint8 的别名</li>
<li>rune 型: 是 int32 的别名</li>
<li>浮点型: float32/float64</li>
<li>复数: complex64/complex128</li>
<li>指针: uintptr（与平台有关）</li>
</ul>
<h2 id="复合类型">复合类型</h2>
<ul class="incremental">
<li>array</li>
<li>struct</li>
<li>string</li>
<li>slice</li>
<li>map</li>
<li>chan</li>
<li>interface</li>
<li>func: 第一类成员</li>
</ul>
<h2 id="零值">零值</h2>
<p>每种类型都有默认零值，如 0, false, &quot;&quot;</p>
<h2 id="类型别名">类型别名</h2>
<ul class="incremental">
<li>用 <code>type</code> 来定义别名</li>
<li>使用单独的类型，使逻辑更清晰（也可以定义不同方法）</li>
<li><code>type</code> 可以同 import, var, const 使用圆括号一次定义多个</li>
<li>别名类型之间需要显式的转换（但 uint8 与 byte, int32 与 rune 之间不需要）</li>
</ul>
<h2 id="math">math</h2>
<p>math 模块中有 MaxXX 与 MinXX，表示了不同类型的取值范围</p>
<h2 id="变量的声明与赋值">变量的声明与赋值</h2>
<ul class="incremental">
<li><code>var</code> 声明变量，需要指定类型</li>
<li><code>=</code> 进行赋值，可以对多个变量赋值</li>
<li>声明与赋值可以放在一起进行，这时编译器会自动推导类型，因此类型标注可以省略</li>
<li>在函数内可以用 <code>:=</code> 语法来进行声明与赋值</li>
<li>函数内可以用 <code>var()</code> 定义多个变量 （但不建议使用）</li>
<li>全局不能使用 <code>:=</code> 语法</li>
</ul>
<h2 id="空白符号">空白符号</h2>
<p><code>_</code> 用于捕获无用的变量</p>
<h2 id="类型转换">类型转换</h2>
<ul class="incremental">
<li>只能在兼容的类型之间进行</li>
</ul>
<h1 id="常量与运算符">常量与运算符</h1>
<h2 id="常量">常量</h2>
<ul class="incremental">
<li>常量的值在编译时确定</li>
<li>常量定义时，右值为常量（字面）或常量表达式（使用内置函数进行计算）</li>
<li>如果未指定右值，则使用上行表达式</li>
<li>通过 const 组与 iota 计数器模拟枚举类型（iota 在组内，每定义一个常量增大一）</li>
<li>常量一般命名成全大写（加下划线）或骆驼写法</li>
</ul>
<h2 id="范式">范式</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">const</span> (
        Readble = <span class="dv">1</span> &lt;&lt; <span class="ot">iota</span>
        Writable
        Executable
)

<span class="kw">const</span> (
        B <span class="dt">float64</span> = <span class="dv">1</span> &lt;&lt; (<span class="ot">iota</span> * <span class="dv">10</span>)
        KB
        MB
        GB
        TB
        PB
        ZB
        EB
)</code></pre></div>
<h2 id="运算符">运算符</h2>
<p>Go 中的运算符统一从左向右结合</p>
<p>下面举例说明</p>
<ul class="incremental">
<li>一元取反 <code>^</code></li>
<li><code>&lt;&lt;</code>, <code>&gt;&gt;</code> 左右移</li>
<li>二元位运算符 <code>&amp;</code> <code>|</code> <code>^</code> <code>&amp;^</code> (AND NOT, bit clean，反向取 mask 作用，可以将 <code>a&amp;^b</code> 看作 <code>a&amp;(^b)</code>)</li>
<li><code>&lt;-</code> channel 专用</li>
</ul>
<h1 id="控制语句">控制语句</h1>
<h2 id="指针">指针</h2>
<ul class="incremental">
<li>不支持指针运算</li>
<li>没有 <code>-&gt;</code> 操作符</li>
<li>默认指针空值为 <code>nil</code></li>
<li>用 <code>&amp;</code> 取址，用 <code>*</code> 解引用</li>
<li><code>++</code>, <code>--</code> 为语句（statement），而非表达式（expression）</li>
</ul>
<h2 id="判断-if">判断 if</h2>
<ul class="incremental">
<li>条件不用加括号</li>
<li>支持一个初始化表达式（值作用域限定在 if 块中）</li>
<li><code>{</code> 必须与 if 放在同一行</li>
</ul>
<h2 id="循环语句">循环语句</h2>
<ol class="incremental">
<li><code>for {}</code></li>
<li><code>for a &lt; 3 {}</code></li>
<li><code>for i := 0; i &lt; 10; i++</code></li>
</ol>
<h2 id="switch-语句">switch 语句</h2>
<ul class="incremental">
<li>可以用任何类型和表达式作分支</li>
<li>支持初始化表达式（同 if）</li>
<li>不用为每个 case 作 break，相反应该加入 fallthrough 如果不需要跳出</li>
</ul>
<p>例子如下</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">switch</span> a {
  <span class="kw">case</span> <span class="dv">0</span>: fmt.Println(<span class="st">&quot;0&quot;</span>)
  <span class="kw">case</span> <span class="dv">1</span>: fmt.Println(<span class="st">&quot;1&quot;</span>)
  <span class="kw">default</span>: fmt.Println(<span class="st">&quot;other&quot;</span>)
}

<span class="kw">switch</span> {
  <span class="kw">case</span> a &lt; <span class="dv">0</span>: fmt.Println(<span class="st">&quot;invalid&quot;</span>)
  <span class="kw">case</span> a &lt; <span class="dv">10</span>: fmt.Println(<span class="st">&quot;good&quot;</span>)
  <span class="kw">default</span>: fmt.Println(<span class="st">&quot;too large&quot;</span>)
}</code></pre></div>
<h2 id="跳转语句goto-continue-break">跳转语句（goto, continue, break)</h2>
<p>continue 和 break 均支持标签（label），将跳转到与标签同级的循环中</p>
<h1 id="数组-array">数组 Array</h1>
<p>Go 的数组类型由元素类型（type）和长度（n）构成。不同于 C 或其它语言，Go 的数组是值类型，意味着做为参数传递时，会进行拷贝。</p>
<p>同类型数组对象，可以用 <code>==</code> 和 <code>!=</code> 进行比较，可以用 <code>=</code> 进行赋值（拷贝）</p>
<h2 id="数组指针">数组指针</h2>
<ul class="incremental">
<li>可以用 <code>new([10]int)</code> 来创建一个指向数组的指针</li>
<li>也可以引用数组的地址，生成一个数组的指针： <code>var p *[100]int = &amp;a</code></li>
<li>无论数组本身，还是数组指针，都可以使用下标来索引内容，如 <code>p[99]</code> 或 <code>a[10]</code></li>
</ul>
<h2 id="指针的数组">指针的数组</h2>
<p>表示数组的内容为指针</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">a := <span class="dv">10</span>
b := <span class="dv">10</span>
c := [...]*<span class="dt">int</span>{&amp;a, &amp;b}</code></pre></div>
<h2 id="字面量">字面量</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">a := [<span class="dv">2</span>]<span class="dt">int</span>{<span class="dv">1</span>}
b := [<span class="dv">2</span>]<span class="dt">int</span>{<span class="dv">1</span>,<span class="dv">2</span>}
c := [<span class="dv">20</span>]<span class="dt">int</span>{<span class="dv">19</span>:<span class="dv">1</span>}
d := [...]<span class="dt">int</span>{<span class="dv">99</span>:<span class="dv">1</span>}
e := [<span class="dv">2</span>][<span class="dv">3</span>]<span class="dt">int</span>{
  {<span class="dv">1</span>:<span class="dv">1</span>},
  {<span class="dv">2</span>:<span class="dv">2</span>},
}
<span class="co">// 多维数组第一维可以自动推导</span>
f := [...][<span class="dv">3</span>]<span class="dt">int</span>{
  {<span class="dv">1</span>:<span class="dv">1</span>},
  {<span class="dv">2</span>:<span class="dv">2</span>},
}</code></pre></div>
<h1 id="切片-slice">切片 Slice</h1>
<ul class="incremental">
<li>切片是对底层数组结构的引用类型（可以建立对同一数组的多个引用，也可以对切片建立新的引用切片）</li>
<li>做为变长数组的替代方案，关联到底层数组的全部或局部</li>
<li>对 slice 作切片（reslice），以 slice 切片为准，不能超出 cap 索引，否则会越界错误</li>
<li>除了类型和长度外，还有 cap 属性</li>
<li>通过 <code>make([]type, len, cap)</code> 来创建一个 slice</li>
<li><code>append(slice, e1, e2, ..., en)</code> 向 slice 添加元素，如果需要将扩容（一倍）</li>
<li>扩容将生成新的底层数组，涉及数据的拷贝，如果已经确定大小，可以预先放大 cap 容量</li>
<li><code>copy(dst, src []type)</code> 对索引进行拷贝</li>
<li>使用 <code>c := a[:]</code> 来生成完全的索引</li>
<li>指向同一个底层数组的的 slices 会相互影响，应小心 append 对底层数组的修改</li>
</ul>
<h1 id="map">Map</h1>
<p>类比于 python 中的 dict，要求 key 类型支持 <code>==</code> 和 <code>!=</code> 比较操作</p>
<h2 id="创建方式">创建方式</h2>
<ol class="incremental">
<li><code>var m map[int]string = map[int]string{}</code></li>
<li><code>m := make(map[int]string)</code></li>
<li><code>m := map[int]string{1:&quot;a&quot;}</code></li>
</ol>
<h2 id="访问与操作">访问与操作</h2>
<ul class="incremental">
<li>通过 <code>m[k] = x</code> 来赋值</li>
<li>通过 <code>a := m[k]</code> 来取值，如果 k 不存在，返回空值</li>
<li>为了判定空值，有第二个返回值 <code>a, ok := m[k]</code> ，键不存在时，ok 返回 false</li>
<li>map 的空值为 nil，要特别小心复杂类型的初始化，如 <code>map[int]map[int]string</code> 或 <code>[]map[int]string</code> 等</li>
</ul>
<h2 id="for-range">for range</h2>
<ul class="incremental">
<li>对于 slice，返回 index, <code>for i, v := range slice</code></li>
<li>对于 map, 返回 k, v, <code>for k, v := range map</code></li>
<li>注意 v 值是拷贝类型，在循环内修改 v 的内容是无效的</li>
</ul>
<h2 id="对-map-按-key-排序">对 map 按 key 排序</h2>
<p>思路是将 map 的 key 拷贝到相同长度的 slice 中，再用 sort.Ints 对 slice 排序（索引）</p>
<h2 id="交换-key-和-value">交换 key 和 value</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">m := <span class="kw">map</span>[<span class="dt">int</span>]<span class="dt">string</span>{<span class="dv">1</span>:<span class="st">&quot;a&quot;</span>, <span class="dv">2</span>:<span class="st">&quot;b&quot;</span>, <span class="dv">3</span>:<span class="st">&quot;c&quot;</span>, <span class="dv">4</span>:<span class="st">&quot;d&quot;</span>, <span class="dv">5</span>:<span class="st">&quot;e&quot;</span>}
n := <span class="kw">map</span>[<span class="dt">string</span>]<span class="dt">int</span>{}
<span class="kw">for</span> k, v := <span class="kw">range</span> m {
    n[v] = k
}</code></pre></div>
<h1 id="函数-function">函数 function</h1>
<h2 id="特点">特点</h2>
<ul class="incremental">
<li>不支持嵌套、重载和默认参数</li>
<li>无需声明原型</li>
<li>不定长度变参（例如 <code>func(a ...int){}</code> ）</li>
<li>多返回值</li>
<li>命名返回值参数（例如 <code>func (a, b int, others ...int) (res int)</code> ）</li>
<li>匿名函数（不能作为顶级函数）</li>
<li>闭包</li>
</ul>
<h2 id="值类型与引用类型">值类型与引用类型</h2>
<p>函数的参数分为值类型与引用类型，在函数内对引用类型进行修改，会影响到外界</p>
<p>常见的修改外界参数类型有：</p>
<ol class="incremental">
<li>指针</li>
<li>map</li>
<li>slice</li>
<li>chan</li>
</ol>
<h2 id="defer-与-panicrecover">defer 与 panic/recover</h2>
<p>Go 中没有 Java 一样的异常机制，使用 panic/recover 原语来处理错误</p>
<p>panic 可以在任何地方触发，而 recover 只有在 defer 中才能调用</p>
<p>defer 相当于 OO 中的析构函数，有以下特点：</p>
<ul class="incremental">
<li>按调用的相反顺序执行</li>
<li>常用于资源清理和 panic recover</li>
<li>调用时生成闭包，保存当前变量</li>
<li>即使发生严重错误 (panic) 也会执行</li>
</ul>
<p>panic/recover 的例子如下</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> main() {
        a()
        b()
        c()
}

<span class="kw">func</span> a() {
        fmt.Println(<span class="st">&quot;a&quot;</span>)
}

<span class="kw">func</span> b() {
        <span class="kw">defer</span> <span class="kw">func</span>() {
                <span class="kw">if</span> err := <span class="bu">recover</span>(); err != <span class="ot">nil</span> {
                        fmt.Println(<span class="st">&quot;recover in b&quot;</span>)
                }
        }()
        <span class="bu">panic</span>(<span class="st">&quot;panic in b&quot;</span>)
}

<span class="kw">func</span> c() {
        fmt.Println(<span class="st">&quot;c&quot;</span>)
}</code></pre></div>
<h2 id="闭包">闭包</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> main() {
        <span class="kw">var</span> fs = [<span class="dv">4</span>]<span class="kw">func</span>(){}

        <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">4</span>; i++ {
                <span class="kw">defer</span> fmt.Println(<span class="st">&quot;defer i = &quot;</span>, i) <span class="co">// 0,1,2,3 ?</span>
                <span class="kw">defer</span> <span class="kw">func</span>() { fmt.Println(<span class="st">&quot;defer_closure i = &quot;</span>, i) }() <span class="co">// 为 4</span>
                fs[i] = <span class="kw">func</span>() { fmt.Println(<span class="st">&quot;closure i = &quot;</span>, i) }
        }

        <span class="kw">for</span> _, f := <span class="kw">range</span> fs {
                f()  <span class="co">// 首先打印，闭包中引用 i 对象，值为 4</span>
        }
}</code></pre></div>
<p><code>defer i</code> 能正常输出，因为在定义 defer 时求值，对 i 按值进行拷贝</p>
<p>与之相反，闭包保留了 i 变量的地址，因此最后其值为 4</p>
<h1 id="结构-struct">结构 struct</h1>
<ul class="incremental">
<li>与 C 相似，go 中没有 class</li>
<li>支持指向自身的指针类型成员</li>
<li>支持匿名结构，可以在结构定义中嵌套定义结构</li>
<li>为值类型，可以进行 <code>==</code> 和 <code>!=</code> 比较</li>
<li>可以使用字面量进行初始化</li>
<li><code>(*a).x</code> 等价于 <code>a.x</code> ，即允许直接通过指针来读写结构成员</li>
<li>相同类型的成员可以进行直接拷贝赋值</li>
<li>结构中可以嵌入匿名字字段或结构，但字面量初始化需要小心</li>
<li>通过嵌入模拟继承，若嵌套结构中有同名，则不会提升该字段</li>
<li>多个同级嵌套结构中不能有同名字段</li>
</ul>
<h2 id="示例">示例</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> main() {
        t2 := Teacher{Person{<span class="st">&quot;haah&quot;</span>, <span class="dv">19</span>}, <span class="st">&quot;math&quot;</span>, <span class="dv">30</span>}
        t3 := Teacher{Person: Person{<span class="st">&quot;haa&quot;</span>, <span class="dv">18</span>}}
        fmt.Println(t2, t3, t2.Age, t2.Person.Age)
}

<span class="kw">type</span> Person <span class="kw">struct</span> {
        Name <span class="dt">string</span>
        Age  <span class="dt">int</span>
}

<span class="kw">type</span> Teacher <span class="kw">struct</span> {
        Person
        Title <span class="dt">string</span>
        Age   <span class="dt">int</span>
}</code></pre></div>
<h1 id="方法-method">方法 method</h1>
<ul class="incremental">
<li>语法上类似于函数定义，多了一个 Receiver 对象</li>
<li>Receiver 对象可以按指针（引用）传递，也可以按值传递。看是否要修改，或是否为了减少拷贝</li>
<li>任何类型都可以添加方法，但方法必须和类型定义位于同一个包（实际上不能为 int 添加方法）</li>
<li>别名定义不会复制方法</li>
<li>方法也可以写成 method express 形式，如 <code>(*TZ)Print(&amp;z)</code></li>
<li>方法也有嵌套提升特性，同结构体嵌套</li>
<li>方法内可以访问私有变量（因为位于同一 package 内，可见性由 package 和控制）</li>
</ul>
<h1 id="接口-interface">接口 interface</h1>
<ul class="incremental">
<li>定义了一组函数的签名集合，没有实现</li>
<li>相对于 Java/C++ 中的继承实现，称为 structural typing</li>
<li>类似于动态语言中的鸭子类型</li>
<li>同 struct 一样，支持嵌入接口，支持匿名字段</li>
<li>可以使用空接口 ( <code>interface{}</code> ) 来实现通用容器</li>
<li>对象可以被转换为接口（拷贝）</li>
<li>接口之间可以由具体向抽象转换</li>
<li>在函数调用时，不需要显式转换，只要对象符合 interface 即可</li>
<li>在函数内，可以进行类型判断，如 <code>if pc,ok := usb.(PhoneConnector); ok {...}</code></li>
<li>type switch 语法，提供了更简单的类型多态处理方式： <code>switch v := usb.(type) {case Type: xxx; ...}</code></li>
<li>空接口，只有其存储类型和对象均为 nil 时，才等于 nil</li>
<li>Go 接口称为非入侵式接口，无有 Java/C++ 中的继承关系</li>
</ul>
<h1 id="反射-reflect">反射 reflect</h1>
<p>reflect 库提供了相关函数，可以从对象中获取相关的结构类型信息。常配合 <code>interface{}</code> 来使用。在不确定类型的情况下使用对象，或提供更复杂的对象社会问题</p>
<h2 id="常用方法">常用方法</h2>
<ul class="incremental">
<li><code>TypeOf</code> : 取类型</li>
<li><code>ValueOf</code></li>
<li><code>TypeOf().Kind()</code></li>
<li><code>Elem()</code></li>
<li><code>Elem().SetInt()</code></li>
<li><code>reflect.Ptr</code></li>
<li><code>Elem().CanSet()</code></li>
<li><code>FieldByIndex</code> （相当于 clojure <code>get-in</code> ）, <code>FieldByName</code>, <code>MethodByIndex</code>, <code>MethodByName</code></li>
<li><code>reflect.Value()</code></li>
</ul>
<h2 id="示例-1"><span class="todo TODO">TODO</span> 示例</h2>
<h1 id="常用库">常用库</h1>
<h2 id="strconv">strconv</h2>
<ul class="incremental">
<li>Itoa 转换数字到字符串</li>
</ul>
<h2 id="math-1">math</h2>
<ul class="incremental">
<li>MaxXX, MinXX 记录类型的取值范围</li>
</ul>
<h2 id="sort">sort</h2>
<ul class="incremental">
<li><code>sort.Ints</code></li>
</ul>
<h1 id="问题">问题</h1>
<h2 id="类型转换是静态的还是动态的有没有开销"><span class="todo TODO">TODO</span> 类型转换是静态的？还是动态的？有没有开销</h2>
<h2 id="string-与-byte-与-rune-的关系"><span class="todo TODO">TODO</span> =string= 与 <code>[]byte</code> 与 <code>[]rune</code> 的关系</h2>
<h2 id="int-与-int-的区别"><span class="todo TODO">TODO</span> =[10]int= 与 <code>[]int</code> 的区别</h2>
<h2 id="int123-与-int123-的区别"><span class="todo TODO">TODO</span> =[...]int{1,2,3}= 与 <code>[]int{1,2,3}</code> 的区别</h2>
<h2 id="for-i-0-i-lena-i-中-lena-是否会造成额外的开销"><span class="todo TODO">TODO</span> ~for i := 0; i &lt; len(a); i++~ 中 <code>len(a)</code> 是否会造成额外的开销</h2>
<h1 id="外部链接">外部链接</h1>
<ul class="incremental">
<li>Go 在谷歌：以软件工程为目的的语言设计</li>
</ul>

			</div>
		</section>
	</body>
</html>
