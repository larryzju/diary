<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2018-03-26 一 20:15 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>无闻 Go 视频教程笔记</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Zhao WenBin">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">无闻 Go 视频教程笔记</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org6404d29">Go 开发环境搭建</a></li>
<li><a href="#org64bead5">Go 基础知识</a></li>
<li><a href="#org994be23">类型与变量</a></li>
<li><a href="#orgee16d8d">常量与运算符</a></li>
<li><a href="#org1e701b3">控制语句</a></li>
<li><a href="#org433ed9f">数组 Array</a></li>
<li><a href="#org9d02fa9">切片 Slice</a></li>
<li><a href="#org7bbdbdd">Map</a></li>
<li><a href="#orgf2b6eea">函数 function</a></li>
<li><a href="#org50d1081">结构 struct</a></li>
<li><a href="#org0bf37f9">方法 method</a></li>
<li><a href="#org94952f1">接口 interface</a></li>
<li><a href="#orgd3297f8">反射 reflect</a></li>
<li><a href="#orgaa37ead">常用库</a></li>
<li><a href="#org69a4827">问题</a></li>
<li><a href="#org7b160c0">外部链接</a></li>
</ul>
</div>
</nav>

<div id="outline-container-org6404d29" class="outline-2">
<h2 id="org6404d29">Go 开发环境搭建</h2>
<div class="outline-text-2" id="text-org6404d29">
</div><div id="outline-container-orgabaa4a5" class="outline-3">
<h3 id="orgabaa4a5">Go 基本介绍</h3>
<div class="outline-text-3" id="text-orgabaa4a5">
<ul class="org-ul">
<li>类型安全，内存安全</li>
<li>支持并发</li>
<li>垃圾回收</li>
<li>快速编译（严格要示，不能有未被使用的导入，未使用的变量，不需要头文件）</li>
<li>快速编译</li>
<li>UTF8 支持</li>
</ul>
</div>
</div>

<div id="outline-container-orgc1b4116" class="outline-3">
<h3 id="orgc1b4116">安装，环境变量，目录</h3>
<div class="outline-text-3" id="text-orgc1b4116">
<p>
go 通过环境变量来设置参数，常见的有
</p>

<ul class="org-ul">
<li>GOROOT</li>
<li>GOPATH: 开发目录，其中包括 bin, pkg, src 等</li>
<li>GOARCH</li>
<li>GOHOSTARCH</li>
</ul>

<p>
其中 <code>${GOPATH}/bin</code> 保存生成的可执行文件， <code>${GOPATH}/pkg</code> 下保存生成的具体平台的库文件
</p>
</div>
</div>

<div id="outline-container-orgee39300" class="outline-3">
<h3 id="orgee39300">命令</h3>
<div class="outline-text-3" id="text-orgee39300">
<p>
常见命令有
</p>

<ul class="org-ul">
<li>build &lt;main-src&gt;</li>
<li>install</li>
<li>test</li>
<li>doc</li>
<li>fmt</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org64bead5" class="outline-2">
<h2 id="org64bead5">Go 基础知识</h2>
<div class="outline-text-2" id="text-org64bead5">
</div><div id="outline-container-orgc188d47" class="outline-3">
<h3 id="orgc188d47">关键字</h3>
<div class="outline-text-3" id="text-orgc188d47">
<p>
其有 25 个关键字，其中特殊的如 type, go, defer, interface, chan, default, fallthrough
</p>
</div>
</div>

<div id="outline-container-orgca1164a" class="outline-3">
<h3 id="orgca1164a">注释方法</h3>
<div class="outline-text-3" id="text-orgca1164a">
<p>
与 C++ 相同
</p>
</div>
</div>

<div id="outline-container-org5f61fec" class="outline-3">
<h3 id="org5f61fec">代码文件的一般结构</h3>
<div class="outline-text-3" id="text-org5f61fec">
<ol class="org-ol">
<li>package</li>
<li>import</li>
<li>const</li>
<li>var</li>
<li>type 定义 struct 或 interface</li>
<li>func</li>
</ol>
</div>
</div>

<div id="outline-container-org7c224c4" class="outline-3">
<h3 id="org7c224c4">import 小技巧</h3>
<div class="outline-text-3" id="text-org7c224c4">
<ol class="org-ol">
<li>别名： <code>import std "fmt"</code></li>
<li>省略调用： <code>import . "fmt"</code> ，类似于 python 中 <code>from fmt import *</code> ，慎用!</li>
</ol>
</div>
</div>

<div id="outline-container-org27869db" class="outline-3">
<h3 id="org27869db">可见性规则</h3>
<div class="outline-text-3" id="text-org27869db">
<p>
通过首字母大写来判定可见性
</p>
</div>
</div>

<div id="outline-container-org43eed05" class="outline-3">
<h3 id="org43eed05">import, var, const 简写</h3>
<div class="outline-text-3" id="text-org43eed05">
<p>
对于多个 import, var, const 可以合并，写在圆括号内（并可以用一条注释整体）
</p>
</div>
</div>
</div>

<div id="outline-container-org994be23" class="outline-2">
<h2 id="org994be23">类型与变量</h2>
<div class="outline-text-2" id="text-org994be23">
</div><div id="outline-container-orgc42a89d" class="outline-3">
<h3 id="orgc42a89d">基本类型</h3>
<div class="outline-text-3" id="text-orgc42a89d">
<ul class="org-ul">
<li>布尔型: bool，取值只能是 true 或者 false</li>
<li>整型: uint/int（平台相关大小），uint/int{8,16,32,64} 指定范围</li>
<li>字节型: byte，是 uint8 的别名</li>
<li>rune 型: 是 int32 的别名</li>
<li>浮点型: float32/float64</li>
<li>复数: complex64/complex128</li>
<li>指针: uintptr（与平台有关）</li>
</ul>
</div>
</div>

<div id="outline-container-org77a00fd" class="outline-3">
<h3 id="org77a00fd">复合类型</h3>
<div class="outline-text-3" id="text-org77a00fd">
<ul class="org-ul">
<li>array</li>
<li>struct</li>
<li>string</li>
<li>slice</li>
<li>map</li>
<li>chan</li>
<li>interface</li>
<li>func: 第一类成员</li>
</ul>
</div>
</div>

<div id="outline-container-orgf6e99ce" class="outline-3">
<h3 id="orgf6e99ce">零值</h3>
<div class="outline-text-3" id="text-orgf6e99ce">
<p>
每种类型都有默认零值，如 0, false, ""
</p>
</div>
</div>

<div id="outline-container-orgde7a46a" class="outline-3">
<h3 id="orgde7a46a">类型别名</h3>
<div class="outline-text-3" id="text-orgde7a46a">
<ul class="org-ul">
<li>用 <code>type</code> 来定义别名</li>
<li>使用单独的类型，使逻辑更清晰（也可以定义不同方法）</li>
<li><code>type</code> 可以同 import, var, const 使用圆括号一次定义多个</li>
<li>别名类型之间需要显式的转换（但 uint8 与 byte, int32 与 rune 之间不需要）</li>
</ul>
</div>
</div>

<div id="outline-container-orgd3034ec" class="outline-3">
<h3 id="orgd3034ec">math</h3>
<div class="outline-text-3" id="text-orgd3034ec">
<p>
math 模块中有 MaxXX 与 MinXX，表示了不同类型的取值范围
</p>
</div>
</div>

<div id="outline-container-org4f4eda3" class="outline-3">
<h3 id="org4f4eda3">变量的声明与赋值</h3>
<div class="outline-text-3" id="text-org4f4eda3">
<ul class="org-ul">
<li><code>var</code> 声明变量，需要指定类型</li>
<li><code>=</code> 进行赋值，可以对多个变量赋值</li>
<li>声明与赋值可以放在一起进行，这时编译器会自动推导类型，因此类型标注可以省略</li>
<li>在函数内可以用 <code>:=</code> 语法来进行声明与赋值</li>
<li>函数内可以用 <code>var()</code> 定义多个变量 （但不建议使用）</li>
<li>全局不能使用 <code>:=</code> 语法</li>
</ul>
</div>
</div>

<div id="outline-container-org165a95d" class="outline-3">
<h3 id="org165a95d">空白符号</h3>
<div class="outline-text-3" id="text-org165a95d">
<p>
<code>_</code> 用于捕获无用的变量
</p>
</div>
</div>

<div id="outline-container-orgd015b3f" class="outline-3">
<h3 id="orgd015b3f">类型转换</h3>
<div class="outline-text-3" id="text-orgd015b3f">
<ul class="org-ul">
<li>只能在兼容的类型之间进行</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgee16d8d" class="outline-2">
<h2 id="orgee16d8d">常量与运算符</h2>
<div class="outline-text-2" id="text-orgee16d8d">
</div><div id="outline-container-org7acb5af" class="outline-3">
<h3 id="org7acb5af">常量</h3>
<div class="outline-text-3" id="text-org7acb5af">
<ul class="org-ul">
<li>常量的值在编译时确定</li>
<li>常量定义时，右值为常量（字面）或常量表达式（使用内置函数进行计算）</li>
<li>如果未指定右值，则使用上行表达式</li>
<li>通过 const 组与 iota 计数器模拟枚举类型（iota 在组内，每定义一个常量增大一）</li>
<li>常量一般命名成全大写（加下划线）或骆驼写法</li>
</ul>
</div>
</div>

<div id="outline-container-org4e45ab3" class="outline-3">
<h3 id="org4e45ab3">范式</h3>
<div class="outline-text-3" id="text-org4e45ab3">
<div class="org-src-container">
<pre class="src src-go">const (
	Readble = 1 &lt;&lt; iota
	Writable
	Executable
)

const (
	B float64 = 1 &lt;&lt; (iota * 10)
	KB
	MB
	GB
	TB
	PB
	ZB
	EB
)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcac2ad5" class="outline-3">
<h3 id="orgcac2ad5">运算符</h3>
<div class="outline-text-3" id="text-orgcac2ad5">
<p>
Go 中的运算符统一从左向右结合
</p>

<p>
下面举例说明
</p>

<ul class="org-ul">
<li>一元取反 <code>^</code></li>
<li><code>&lt;&lt;</code>, <code>&gt;&gt;</code> 左右移</li>
<li>二元位运算符 <code>&amp;</code> <code>|</code> <code>^</code> <code>&amp;^</code> (AND NOT, bit clean，反向取 mask 作用，可以将 <code>a&amp;^b</code> 看作 <code>a&amp;(^b)</code>)</li>
<li><code>&lt;-</code> channel 专用</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org1e701b3" class="outline-2">
<h2 id="org1e701b3">控制语句</h2>
<div class="outline-text-2" id="text-org1e701b3">
</div><div id="outline-container-org8943d37" class="outline-3">
<h3 id="org8943d37">指针</h3>
<div class="outline-text-3" id="text-org8943d37">
<ul class="org-ul">
<li>不支持指针运算</li>
<li>没有 <code>-&gt;</code> 操作符</li>
<li>默认指针空值为 <code>nil</code></li>
<li>用 <code>&amp;</code> 取址，用 <code>*</code> 解引用</li>
<li><code>++</code>, <code>--</code> 为语句（statement），而非表达式（expression）</li>
</ul>
</div>
</div>


<div id="outline-container-orgc73b84a" class="outline-3">
<h3 id="orgc73b84a">判断 if</h3>
<div class="outline-text-3" id="text-orgc73b84a">
<ul class="org-ul">
<li>条件不用加括号</li>
<li>支持一个初始化表达式（值作用域限定在 if 块中）</li>
<li><code>{</code> 必须与 if 放在同一行</li>
</ul>
</div>
</div>

<div id="outline-container-orgaae3788" class="outline-3">
<h3 id="orgaae3788">循环语句</h3>
<div class="outline-text-3" id="text-orgaae3788">
<ol class="org-ol">
<li><code>for {}</code></li>
<li><code>for a &lt; 3 {}</code></li>
<li><code>for i := 0; i &lt; 10; i++</code></li>
</ol>
</div>
</div>

<div id="outline-container-orgc154f26" class="outline-3">
<h3 id="orgc154f26">switch 语句</h3>
<div class="outline-text-3" id="text-orgc154f26">
<ul class="org-ul">
<li>可以用任何类型和表达式作分支</li>
<li>支持初始化表达式（同 if）</li>
<li>不用为每个 case 作 break，相反应该加入 fallthrough 如果不需要跳出</li>
</ul>

<p>
例子如下
</p>

<div class="org-src-container">
<pre class="src src-go">switch a {
  case 0: fmt.Println("0")
  case 1: fmt.Println("1")
  default: fmt.Println("other")
}

switch {
  case a &lt; 0: fmt.Println("invalid")
  case a &lt; 10: fmt.Println("good")
  default: fmt.Println("too large")
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org32925da" class="outline-3">
<h3 id="org32925da">跳转语句（goto, continue, break)</h3>
<div class="outline-text-3" id="text-org32925da">
<p>
continue 和 break 均支持标签（label），将跳转到与标签同级的循环中
</p>
</div>
</div>
</div>

<div id="outline-container-org433ed9f" class="outline-2">
<h2 id="org433ed9f">数组 Array</h2>
<div class="outline-text-2" id="text-org433ed9f">
<p>
Go 的数组类型由元素类型（type）和长度（n）构成。不同于 C 或其它语言，Go 的数组是值类型，意味着做为参数传递时，会进行拷贝。
</p>

<p>
同类型数组对象，可以用 <code>==</code> 和 <code>!=</code> 进行比较，可以用 <code>=</code> 进行赋值（拷贝）
</p>
</div>

<div id="outline-container-orgc12ef15" class="outline-3">
<h3 id="orgc12ef15">数组指针</h3>
<div class="outline-text-3" id="text-orgc12ef15">
<ul class="org-ul">
<li>可以用 <code>new([10]int)</code> 来创建一个指向数组的指针</li>
<li>也可以引用数组的地址，生成一个数组的指针： <code>var p *[100]int = &amp;a</code></li>
<li>无论数组本身，还是数组指针，都可以使用下标来索引内容，如 <code>p[99]</code> 或 <code>a[10]</code></li>
</ul>
</div>
</div>

<div id="outline-container-org904b318" class="outline-3">
<h3 id="org904b318">指针的数组</h3>
<div class="outline-text-3" id="text-org904b318">
<p>
表示数组的内容为指针
</p>

<div class="org-src-container">
<pre class="src src-go">a := 10
b := 10
c := [...]*int{&amp;a, &amp;b}
</pre>
</div>
</div>
</div>

<div id="outline-container-org51bd704" class="outline-3">
<h3 id="org51bd704">字面量</h3>
<div class="outline-text-3" id="text-org51bd704">
<div class="org-src-container">
<pre class="src src-go">a := [2]int{1}
b := [2]int{1,2}
c := [20]int{19:1}
d := [...]int{99:1}
e := [2][3]int{
  {1:1},
  {2:2},
}
// 多维数组第一维可以自动推导
f := [...][3]int{
  {1:1},
  {2:2},
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9d02fa9" class="outline-2">
<h2 id="org9d02fa9">切片 Slice</h2>
<div class="outline-text-2" id="text-org9d02fa9">
<ul class="org-ul">
<li>切片是对底层数组结构的引用类型（可以建立对同一数组的多个引用，也可以对切片建立新的引用切片）</li>
<li>做为变长数组的替代方案，关联到底层数组的全部或局部</li>
<li>对 slice 作切片（reslice），以 slice 切片为准，不能超出 cap 索引，否则会越界错误</li>
<li>除了类型和长度外，还有 cap 属性</li>
<li>通过 <code>make([]type, len, cap)</code> 来创建一个 slice</li>
<li><code>append(slice, e1, e2, ..., en)</code> 向 slice 添加元素，如果需要将扩容（一倍）</li>
<li>扩容将生成新的底层数组，涉及数据的拷贝，如果已经确定大小，可以预先放大 cap 容量</li>
<li><code>copy(dst, src []type)</code> 对索引进行拷贝</li>
<li>使用 <code>c := a[:]</code> 来生成完全的索引</li>
<li>指向同一个底层数组的的 slices 会相互影响，应小心 append 对底层数组的修改</li>
</ul>
</div>
</div>

<div id="outline-container-org7bbdbdd" class="outline-2">
<h2 id="org7bbdbdd">Map</h2>
<div class="outline-text-2" id="text-org7bbdbdd">
<p>
类比于 python 中的 dict，要求 key 类型支持 <code>==</code> 和 <code>!=</code> 比较操作
</p>
</div>

<div id="outline-container-org40c8be1" class="outline-3">
<h3 id="org40c8be1">创建方式</h3>
<div class="outline-text-3" id="text-org40c8be1">
<ol class="org-ol">
<li><code>var m map[int]string = map[int]string{}</code></li>
<li><code>m := make(map[int]string)</code></li>
<li><code>m := map[int]string{1:"a"}</code></li>
</ol>
</div>
</div>

<div id="outline-container-org47eae22" class="outline-3">
<h3 id="org47eae22">访问与操作</h3>
<div class="outline-text-3" id="text-org47eae22">
<ul class="org-ul">
<li>通过 <code>m[k] = x</code> 来赋值</li>
<li>通过 <code>a := m[k]</code> 来取值，如果 k 不存在，返回空值</li>
<li>为了判定空值，有第二个返回值 <code>a, ok := m[k]</code> ，键不存在时，ok 返回 false</li>
<li>map 的空值为 nil，要特别小心复杂类型的初始化，如 <code>map[int]map[int]string</code> 或 <code>[]map[int]string</code> 等</li>
</ul>
</div>
</div>

<div id="outline-container-orga2d2905" class="outline-3">
<h3 id="orga2d2905">for range</h3>
<div class="outline-text-3" id="text-orga2d2905">
<ul class="org-ul">
<li>对于 slice，返回 index, <code>for i, v := range slice</code></li>
<li>对于 map, 返回 k, v, <code>for k, v := range map</code></li>
<li>注意 v 值是拷贝类型，在循环内修改 v 的内容是无效的</li>
</ul>
</div>
</div>

<div id="outline-container-orgb1cd3c3" class="outline-3">
<h3 id="orgb1cd3c3">对 map 按 key 排序</h3>
<div class="outline-text-3" id="text-orgb1cd3c3">
<p>
思路是将 map 的 key 拷贝到相同长度的 slice 中，再用 sort.Ints 对 slice 排序（索引）
</p>
</div>
</div>

<div id="outline-container-org9ca9a02" class="outline-3">
<h3 id="org9ca9a02">交换 key 和 value</h3>
<div class="outline-text-3" id="text-org9ca9a02">
<div class="org-src-container">
<pre class="src src-go">m := map[int]string{1:"a", 2:"b", 3:"c", 4:"d", 5:"e"}
n := map[string]int{}
for k, v := range m {
    n[v] = k
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf2b6eea" class="outline-2">
<h2 id="orgf2b6eea">函数 function</h2>
<div class="outline-text-2" id="text-orgf2b6eea">
</div><div id="outline-container-org4a99bdb" class="outline-3">
<h3 id="org4a99bdb">特点</h3>
<div class="outline-text-3" id="text-org4a99bdb">
<ul class="org-ul">
<li>不支持嵌套、重载和默认参数</li>
<li>无需声明原型</li>
<li>不定长度变参（例如 <code>func(a ...int){}</code> ）</li>
<li>多返回值</li>
<li>命名返回值参数（例如 <code>func (a, b int, others ...int) (res int)</code> ）</li>
<li>匿名函数（不能作为顶级函数）</li>
<li>闭包</li>
</ul>
</div>
</div>

<div id="outline-container-org9a603dc" class="outline-3">
<h3 id="org9a603dc">值类型与引用类型</h3>
<div class="outline-text-3" id="text-org9a603dc">
<p>
函数的参数分为值类型与引用类型，在函数内对引用类型进行修改，会影响到外界
</p>

<p>
常见的修改外界参数类型有：
</p>

<ol class="org-ol">
<li>指针</li>
<li>map</li>
<li>slice</li>
<li>chan</li>
</ol>
</div>
</div>

<div id="outline-container-org5dff9a2" class="outline-3">
<h3 id="org5dff9a2">defer 与 panic/recover</h3>
<div class="outline-text-3" id="text-org5dff9a2">
<p>
Go 中没有 Java 一样的异常机制，使用 panic/recover 原语来处理错误
</p>

<p>
panic 可以在任何地方触发，而 recover 只有在 defer 中才能调用
</p>

<p>
defer 相当于 OO 中的析构函数，有以下特点：
</p>
<ul class="org-ul">
<li>按调用的相反顺序执行</li>
<li>常用于资源清理和 panic recover</li>
<li>调用时生成闭包，保存当前变量</li>
<li>即使发生严重错误 (panic) 也会执行</li>
</ul>

<p>
panic/recover 的例子如下
</p>

<div class="org-src-container">
<pre class="src src-go">func main() {
	a()
	b()
	c()
}

func a() {
	fmt.Println("a")
}

func b() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("recover in b")
		}
	}()
	panic("panic in b")
}

func c() {
	fmt.Println("c")
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcf47847" class="outline-3">
<h3 id="orgcf47847">闭包</h3>
<div class="outline-text-3" id="text-orgcf47847">
<div class="org-src-container">
<pre class="src src-go">func main() {
	var fs = [4]func(){}

	for i := 0; i &lt; 4; i++ {
		defer fmt.Println("defer i = ", i) // 0,1,2,3 ?
		defer func() { fmt.Println("defer_closure i = ", i) }() // 为 4
		fs[i] = func() { fmt.Println("closure i = ", i) }
	}

	for _, f := range fs {
		f()  // 首先打印，闭包中引用 i 对象，值为 4
	}
}
</pre>
</div>

<p>
<code>defer i</code> 能正常输出，因为在定义 defer 时求值，对 i 按值进行拷贝
</p>

<p>
与之相反，闭包保留了 i 变量的地址，因此最后其值为 4
</p>
</div>
</div>
</div>

<div id="outline-container-org50d1081" class="outline-2">
<h2 id="org50d1081">结构 struct</h2>
<div class="outline-text-2" id="text-org50d1081">
<ul class="org-ul">
<li>与 C 相似，go 中没有 class</li>
<li>支持指向自身的指针类型成员</li>
<li>支持匿名结构，可以在结构定义中嵌套定义结构</li>
<li>为值类型，可以进行 <code>==</code> 和 <code>!=</code> 比较</li>
<li>可以使用字面量进行初始化</li>
<li><code>(*a).x</code> 等价于 <code>a.x</code> ，即允许直接通过指针来读写结构成员</li>
<li>相同类型的成员可以进行直接拷贝赋值</li>
<li>结构中可以嵌入匿名字字段或结构，但字面量初始化需要小心</li>
<li>通过嵌入模拟继承，若嵌套结构中有同名，则不会提升该字段</li>
<li>多个同级嵌套结构中不能有同名字段</li>
</ul>
</div>

<div id="outline-container-org271d992" class="outline-3">
<h3 id="org271d992">示例</h3>
<div class="outline-text-3" id="text-org271d992">
<div class="org-src-container">
<pre class="src src-go">func main() {
	t2 := Teacher{Person{"haah", 19}, "math", 30}
	t3 := Teacher{Person: Person{"haa", 18}}
	fmt.Println(t2, t3, t2.Age, t2.Person.Age)
}

type Person struct {
	Name string
	Age  int
}

type Teacher struct {
	Person
	Title string
	Age   int
}
</pre>
</div>
</div>
</div>
</div>





<div id="outline-container-org0bf37f9" class="outline-2">
<h2 id="org0bf37f9">方法 method</h2>
<div class="outline-text-2" id="text-org0bf37f9">
<ul class="org-ul">
<li>语法上类似于函数定义，多了一个 Receiver 对象</li>
<li>Receiver 对象可以按指针（引用）传递，也可以按值传递。看是否要修改，或是否为了减少拷贝</li>
<li>任何类型都可以添加方法，但方法必须和类型定义位于同一个包（实际上不能为 int 添加方法）</li>
<li>别名定义不会复制方法</li>
<li>方法也可以写成 method express 形式，如 <code>(*TZ)Print(&amp;z)</code></li>
<li>方法也有嵌套提升特性，同结构体嵌套</li>
<li>方法内可以访问私有变量（因为位于同一 package 内，可见性由 package 和控制）</li>
</ul>
</div>
</div>

<div id="outline-container-org94952f1" class="outline-2">
<h2 id="org94952f1">接口 interface</h2>
<div class="outline-text-2" id="text-org94952f1">
<ul class="org-ul">
<li>定义了一组函数的签名集合，没有实现</li>
<li>相对于 Java/C++ 中的继承实现，称为 structural typing</li>
<li>类似于动态语言中的鸭子类型</li>
<li>同 struct 一样，支持嵌入接口，支持匿名字段</li>
<li>可以使用空接口 ( <code>interface{}</code> ) 来实现通用容器</li>
<li>对象可以被转换为接口（拷贝）</li>
<li>接口之间可以由具体向抽象转换</li>
<li>在函数调用时，不需要显式转换，只要对象符合 interface 即可</li>
<li>在函数内，可以进行类型判断，如 <code>if pc,ok := usb.(PhoneConnector); ok {...}</code></li>
<li>type switch 语法，提供了更简单的类型多态处理方式： <code>switch v := usb.(type) {case Type: xxx; ...}</code></li>
<li>空接口，只有其存储类型和对象均为 nil 时，才等于 nil</li>
<li>Go 接口称为非入侵式接口，无有 Java/C++ 中的继承关系</li>
</ul>
</div>
</div>

<div id="outline-container-orgd3297f8" class="outline-2">
<h2 id="orgd3297f8">反射 reflect</h2>
<div class="outline-text-2" id="text-orgd3297f8">
<p>
reflect 库提供了相关函数，可以从对象中获取相关的结构类型信息。常配合 <code>interface{}</code> 来使用。在不确定类型的情况下使用对象，或提供更复杂的对象社会问题
</p>
</div>

<div id="outline-container-org3982b13" class="outline-3">
<h3 id="org3982b13">常用方法</h3>
<div class="outline-text-3" id="text-org3982b13">
<ul class="org-ul">
<li><code>TypeOf</code> : 取类型</li>
<li><code>ValueOf</code></li>
<li><code>TypeOf().Kind()</code></li>
<li><code>Elem()</code></li>
<li><code>Elem().SetInt()</code></li>
<li><code>reflect.Ptr</code></li>
<li><code>Elem().CanSet()</code></li>
<li><code>FieldByIndex</code> （相当于 clojure <code>get-in</code> ）, <code>FieldByName</code>, <code>MethodByIndex</code>, <code>MethodByName</code></li>
<li><code>reflect.Value()</code></li>
</ul>
</div>
</div>

<div id="outline-container-org821b83c" class="outline-3">
<h3 id="org821b83c"><span class="todo TODO">TODO</span> 示例</h3>
</div>
</div>

<div id="outline-container-orgaa37ead" class="outline-2">
<h2 id="orgaa37ead">常用库</h2>
<div class="outline-text-2" id="text-orgaa37ead">
</div><div id="outline-container-org1fd6933" class="outline-3">
<h3 id="org1fd6933">strconv</h3>
<div class="outline-text-3" id="text-org1fd6933">
<ul class="org-ul">
<li>Itoa 转换数字到字符串</li>
</ul>
</div>
</div>

<div id="outline-container-orgfc0faa4" class="outline-3">
<h3 id="orgfc0faa4">math</h3>
<div class="outline-text-3" id="text-orgfc0faa4">
<ul class="org-ul">
<li>MaxXX, MinXX 记录类型的取值范围</li>
</ul>
</div>
</div>

<div id="outline-container-org4846b92" class="outline-3">
<h3 id="org4846b92">sort</h3>
<div class="outline-text-3" id="text-org4846b92">
<ul class="org-ul">
<li><code>sort.Ints</code></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org69a4827" class="outline-2">
<h2 id="org69a4827">问题</h2>
<div class="outline-text-2" id="text-org69a4827">
</div><div id="outline-container-org978f195" class="outline-3">
<h3 id="org978f195"><span class="todo TODO">TODO</span> 类型转换是静态的？还是动态的？有没有开销</h3>
</div>

<div id="outline-container-org7f5761e" class="outline-3">
<h3 id="org7f5761e"><span class="todo TODO">TODO</span> <code>string</code> 与 <code>[]byte</code> 与 <code>[]rune</code> 的关系</h3>
</div>

<div id="outline-container-orga53e83f" class="outline-3">
<h3 id="orga53e83f"><span class="todo TODO">TODO</span> <code>[10]int</code> 与 <code>[]int</code> 的区别</h3>
</div>

<div id="outline-container-org88d75ea" class="outline-3">
<h3 id="org88d75ea"><span class="todo TODO">TODO</span> <code>[...]int{1,2,3}</code> 与 <code>[]int{1,2,3}</code> 的区别</h3>
</div>
<div id="outline-container-org95eb61c" class="outline-3">
<h3 id="org95eb61c"><span class="todo TODO">TODO</span> <code>for i := 0; i &lt; len(a); i++</code> 中 <code>len(a)</code> 是否会造成额外的开销</h3>
</div>
</div>

<div id="outline-container-org7b160c0" class="outline-2">
<h2 id="org7b160c0">外部链接</h2>
<div class="outline-text-2" id="text-org7b160c0">
<ul class="org-ul">
<li>Go 在谷歌：以软件工程为目的的语言设计</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Zhao WenBin</p>
<p class="date">Created: 2018-03-26 一 20:15</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
