<!DOCTYPE html>
<html>
	<head>
		<title>effective-go.org</title>
		<link rel="stylesheet" href="/diary/_resources/css/main.css" />
		<script src="/diary/_resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/_resources/js/swgen.js"></script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="commentary">Commentary</h1>
<ul class="incremental">
<li>注释有行注释和块注释两种</li>
<li>godoc 命令会根据注释内容生成文档</li>
<li>文档注释分为 package comment 和 doc comment</li>
<li>对于多文件的包，包注释只应出现在其中一个文件中</li>
<li>注释文档不会被进行格式化处理</li>
<li>每个导出的名称都应予以 doc comment 注释</li>
<li>var 或 const 分组只注释一次</li>
</ul>
<h1 id="names">Names</h1>
<ul class="incremental">
<li>首字母大小写决定包外的可见性</li>
<li>骆驼命名法</li>
</ul>
<h2 id="package-names">Package names</h2>
<ul class="incremental">
<li>包名即变量的引用名</li>
<li>要求：short, concise, evocative</li>
<li>由小写字母构成</li>
<li>在使用时可以起别名，但在定义时不要求严格的唯一</li>
<li>习惯上，package name 与源目录一致</li>
<li>导入的名称是完整路径</li>
<li>函数名不必再重复 package name</li>
<li>Long names don't automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name.</li>
</ul>
<h2 id="getter">Getter</h2>
<ul class="incremental">
<li>Go 不自动提供 getter 和 setter</li>
<li>习惯以 <code>Owner</code> 而非 <code>GetOwner</code> 表示 getter</li>
<li>以 <code>SetOwner</code> 来表示 setter</li>
</ul>
<h2 id="interface-name">Interface name</h2>
<ul class="incremental">
<li>单方法接口以方法名加 'er' 后缀来命名</li>
<li>接口名不应与常用函数（Read，Writer，Close，Flush）重名</li>
</ul>
<h1 id="分号">分号</h1>
<ul class="incremental">
<li>Go 理论上用分号来分隔语句，但一般不写在源码里</li>
<li>lexer 会自动插入分号</li>
<li>在行结尾为 newline, number 或 string 常量，或符号 <code>break</code>, <code>continue</code>, <code>fallthrough</code>, <code>return</code>, <code>++</code>, <code>--</code>, <code>)</code>, <code>}</code> 被插入分号</li>
<li>if the newline comes after a token that could end a statement, insert a semicolon.</li>
<li>Go 中的分号一般只出现在 for 循环中，会用分隔三个条件</li>
<li>一行内的多个 statement 可以用分号来分隔</li>
<li>不能将 '(' 放在新的一行</li>
</ul>
<h1 id="控制结构">控制结构</h1>
<h2 id="基础">基础</h2>
<ul class="incremental">
<li>没有 <code>do .. while</code> 循环</li>
<li>通用的 <code>for</code></li>
<li>更有弹性的 <code>switch</code></li>
<li><code>if</code> 和 <code>switch</code> 包含一个可选的初始化</li>
<li><code>break</code> 和 <code>continue</code> 可以指定一个 label</li>
<li>新的 type switch 控制结构</li>
<li>select 控制结构</li>
</ul>
<h2 id="for-range">for range</h2>
<ul class="incremental">
<li>range 用于迭代 array, slice, string, map 及 channel</li>
<li>若只需要迭代 key 或 index，则 for 中只带一个迭代参数</li>
<li>若只需要第二个值，可以使用 <code>_</code></li>
<li>对 string 迭代，返回 rune (UTF8) 和 pos</li>
<li>对于无法识别的字符，返回 <code>U+FFFD</code> 特殊字符</li>
</ul>
<h2 id="swtich">swtich</h2>
<ul class="incremental">
<li>不加条件，可以构造 <code>if-elsif-else</code> 分支</li>
<li>case 中可以写多条件（用逗号分隔）</li>
<li>可以使用 break, 默认为每个 case 加入 break</li>
</ul>
<h2 id="type-switch">type switch</h2>
<ul class="incremental">
<li>discover the dynamic type of an interface variable</li>
<li>语法是 <code>t.(type)</code></li>
</ul>
<h2 id="其它">其它</h2>
<h3 id="redeclaration-and-reassignment">Redeclaration and reassignment</h3>
<ul class="incremental">
<li>通过 <code>:=</code> 来进行申明时，变量 v 可以多次出现</li>
<li>但至少在申明列表中有一个新的变量</li>
<li>用于简化赋值与申明的语法切换</li>
</ul>
<h3 id="与-c-的不同">与 C 的不同</h3>
<ul class="incremental">
<li>Go 中没有 <code>++</code> 和 <code>--</code> 操作</li>
<li>Go 中没有 comma operator，但可以进行多赋值</li>
</ul>
<h1 id="函数">函数</h1>
<h2 id="多返回值">多返回值</h2>
<ul class="incremental">
<li>避免像 C 中通过返回 -1，并修改指针内容来表示错误，和错误信息</li>
<li>多个返回值中可以设计上下文缓存，模拟 python yield</li>
</ul>
<h2 id="具名返回参数">具名返回参数</h2>
<ul class="incremental">
<li>函数初始化时，返回参数被初始化为零值</li>
<li>在裸 return 时，返回当时返回参数的值</li>
<li>可以作为手册，说明返回参数的信息</li>
</ul>
<h2 id="defer">Defer</h2>
<ul class="incremental">
<li>用于保证资源被释放</li>
<li>在有多个 return 分支时，常会忘记释放的情况</li>
<li>在打开处进行关闭注册，代码更加清晰</li>
<li>defer 函数参数立即被展开</li>
<li>defer 可以多次调用，函数按 FILO 执行</li>
</ul>
<h1 id="data">Data</h1>
<h2 id="new">New</h2>
<ul class="incremental">
<li>申请空间有两个原语 <code>new</code> 和 <code>make</code></li>
<li>new 仅用于申请空间并赋零值 ，但不会调用初始化过程</li>
<li>返回类型为 <code>*T</code> ，表示指向 T 类型变量所在的位置</li>
<li>设计类型时，尽可能让零值有意义</li>
</ul>
<h2 id="make">Make</h2>
<ul class="incremental">
<li>只用于创建 slice, map 和 channel</li>
<li>返回一个被初始化的值（类型为 T）</li>
<li>与 new 进行区别，是因为有些类型变量需要进行初始化</li>
<li><code>make([]int, 10, 100)</code> 返回一个 slice, 容量为 100，长度为 10</li>
<li>可以忽略长度： <code>v := make([]int, 100)</code></li>
</ul>
<h2 id="构造字面量">构造字面量</h2>
<ul class="incremental">
<li>composite literal</li>
<li>可以指定局部成员，可以乱序，如 <code>&amp;File{fd:fd, name:name}</code></li>
<li>可以完全不写成员值，以初始化空值</li>
<li>可以用于初始化 array, slice, map</li>
<li>数组类初始化，field 名称直接被忽略</li>
</ul>
<h2 id="arrays">Arrays</h2>
<ul class="incremental">
<li>与 C 的数组不同，在 Go 中
<ul class="incremental">
<li>Array are value, 赋值相当于拷贝</li>
<li>将 array 作为函数的参数，会对值进行拷贝</li>
<li>The size of an array is part of its type: <code>[10]int</code></li>
</ul></li>
<li>为了提高效率，函数参数需要以指针传入，避免拷贝</li>
<li>一般用 slice 来替代直接使用 array</li>
</ul>
<h2 id="slices">Slices</h2>
<ul class="incremental">
<li>对 arrays 的封装</li>
<li>更通用，功能更强，接口更方便</li>
<li>大部分应用场景下都应使用 slice 来替代 array</li>
<li>slice 是引用，赋值不会拷贝</li>
<li>slice 隐含有长度（和容量）信息</li>
<li>slice 的长度可以扩展，受底层 array 容量的限制</li>
<li>要改变 slice 长度，只需要对其切片赋值到新的 slice</li>
<li>内置有 append 函数</li>
</ul>
<h2 id="two-dimensional-slices">Two-dimensional slices</h2>
<ul class="incremental">
<li>例如 <code>type linesOfText [][]byte</code></li>
<li>slice 是变长的，所以内部（第二维） slice 可以是变长的</li>
<li>二维数组实现有两种方式
<ol class="incremental">
<li>独立申请第二维 slice，类似 C 中指针数组</li>
<li>对一维数组中切片，适用于固定长度</li>
</ol></li>
</ul>
<h2 id="maps">Maps</h2>
<ul class="incremental">
<li>key 可以是定义了 equality operator 的任意类型</li>
<li>key 可以是 interface 类型的</li>
<li>slice 不可以作为 key</li>
<li>map 是引用类型，会被函数修改</li>
<li>？？copy, deepcopy</li>
<li>类型写作 <code>map[string]int</code> ，表示 string 类的键指向 int 类的值</li>
<li>取不存在的键，返回零值</li>
<li>返回两个值，后一个作为是否存在的标志</li>
<li>delete 删除 map 中的成员，不存在也不会报错</li>
</ul>
<h2 id="printing">Printing</h2>
<ul class="incremental">
<li>常用的函数有 <code>fmt.{Printf,Fprintf,Sprintf}</code></li>
<li>Println 插入空格和换行， Print 插入空格</li>
<li>Fprint 等函数的文件对象需要实现 <code>io.Writer</code> 接口</li>
<li>常用文件如 <code>os.Stdout</code> 或 <code>os.Stderr</code></li>
<li><code>%d</code> 不能像 C 一样带修饰符</li>
<li><code>%v</code> 作 default conversion，可打印复合结构，如 array, slice, struct, map</li>
<li>对于结构体, <code>%v</code> 显示值， <code>%+v</code> 显示键和值， <code>%#v</code> 以 Go 语法来显示键和值</li>
<li><code>%q</code>, 指 quote，用于 <code>string</code> 或 <code>[]byte</code></li>
<li><code>%#q</code> 使用 backquote 来作为引用符</li>
<li><code>%x</code> 可应用于 <code>string</code>, <code>[]byte</code></li>
<li><code>% x</code> 可以在 hex 中插入空格</li>
<li><code>%T</code> 打印变量的类型</li>
<li>通过实现 <code>T.String()</code> 方法来提供默认的格式化方法</li>
<li><code>func Printf( format string, v ...interface{} )(n int, err error)</code></li>
<li>v 是可变长参数列表，使用 <code>v...</code> 来展开（类似于 lisp apply）</li>
</ul>
<h2 id="append">Append</h2>
<ul class="incremental">
<li>示意如下 <code>func append( slice []T, elements ...T)[]T</code></li>
<li>Go 不能实现对泛型的函数定义，因此 append 以内置函数实现</li>
<li><code>append( x, y... )</code> ，类似于 lisp 中的 <code>(append* a b)</code></li>
</ul>
<h2 id="注意">注意</h2>
<ul class="incremental">
<li>It's perfect OK to return the address of a local variable（涉及内存堆与栈的切换，以及 GC 的优化）</li>
</ul>
<h1 id="初始化">初始化</h1>
<p>Go 比 C 或 C++ 更加强大，体现在：</p>
<ol class="incremental">
<li>复杂结构的构造</li>
<li>构造顺序问题</li>
</ol>
<h2 id="constants">Constants</h2>
<ul class="incremental">
<li>在编译期被创建</li>
<li>只能是 number, rune, string, boolean 类型</li>
<li>必须是 constant expression （编译需要）</li>
<li>使用 <code>iota</code> 生成枚举， iota 是表达式</li>
</ul>
<h2 id="variables">variables</h2>
<ul class="incremental">
<li>与 constant 语法类似</li>
<li>但在 run time 被初始化</li>
</ul>
<h2 id="init-function">init function</h2>
<ul class="incremental">
<li>每个源文件可以有自己的 <code>init</code> 函数</li>
<li>在所有变量初始化完成后，包被初始化后才会执行</li>
<li>常用于验证和修改状态</li>
</ul>
<h1 id="methods">Methods</h1>
<h2 id="pointers-vs.-values">Pointers vs. Values</h2>
<ul class="incremental">
<li>methods can be defined for any named type ( except a pointer or an interface )</li>
<li>使用指针，方法可以直接修改 caller 本身</li>
<li>value methods can be invoked on pointers and values; but pointers methods can only be invoked on pointers</li>
<li>对于可取地址的值，对其进行方法调用时，编译器用自动进行地址引用。因此 <code>(&amp;b).Write</code> 可以简写为 <code>b.write</code></li>
</ul>
<h1 id="interfaces-and-other-types">Interfaces and other types</h1>
<h2 id="interfaces">Interfaces</h2>
<ul class="incremental">
<li>provider a way to specify the behavior of an object: <strong>If something can do this, then it can be used there.</strong></li>
<li>只有一到两个方法的 interface 属于常见</li>
<li>一个类型可以实现多个 interface 的方法，但不指定显示的继承实现路径</li>
</ul>
<h2 id="conversions">Conversions</h2>
<ul class="incremental">
<li>两个底层构造一致的对象可以相互转换</li>
<li>转换并不是要创建新的对象，而仅是类型（及方法）的转换说明</li>
<li>可以将对象的类型进行转换，以使用不同接口中的方法</li>
</ul>
<h2 id="interface-conversions-and-type-assertions">Interface conversions and type assertions</h2>
<ul class="incremental">
<li>type switch 有个常用的方式，对 interface 取 switch，在每个 case 中转换为相应的类型，进行具体的操作</li>
<li>switch 条件为 <code>value.(type)</code></li>
<li>通过 <code>value.(typeName)</code> 进行类型断言或转换</li>
<li>若无法转换，则会 crash with a run-time error</li>
<li>使用 &quot;val, ok&quot; 来测试是否能够正常转换</li>
</ul>
<h2 id="generality">Generality</h2>
<ul class="incremental">
<li>若无 interface 以外的方法实现，类型便无意义</li>
<li>构造函数可以返回一个 interface 而非具体实现</li>
<li>通过对 interface 提供的接口进行开发，以实现抽象编程</li>
</ul>
<h2 id="interface-and-methods">Interface and methods</h2>
<p><strong>Almost anything can have methods attached, almost anythin can santisfy an interface</strong></p>
<h1 id="the-blank-identifier">The Blank Identifier</h1>
<ul class="incremental">
<li>can be assigned or declared with any value of any type, with the value discarded harmlessly</li>
<li>用于 multiple assignment</li>
<li>用于 unused imports and variables，引用未使用的包或变量，以避免编译错误</li>
<li>用于 import for side effect，如 =import _ &quot;net/http/pprof&quot;=</li>
<li>用于 interface check，如 <code>var _ json.Marshaler = (*RamMessage)(nil)</code></li>
<li>类型无需指出它具体实现了哪些接口，而去具体实现相应的方法，大部分转换都在编译时进行的</li>
<li>使用 <code>value.(type)</code> 进行 check，会在运行时进行</li>
</ul>
<h1 id="errors">Errors</h1>
<ul class="incremental">
<li>正常情况通过多返回值来描述错误信息</li>
<li>错误类型为 <code>error</code> ，是一个内置的 interface，其中有 <code>Error()</code> 方法</li>
<li>除了简单的报错外，还可以提供一些上下文环境记录</li>
<li>调用者通过 type switch 或 type assertion 来区分 error 的具体类型</li>
</ul>
<h2 id="panic">Panic</h2>
<ul class="incremental">
<li>对不可恢复的错误，使用 <code>panic</code> 来创建 runtime error，并停止程序执行</li>
<li>panic 后可以跟任意类型，一般是字符串，会打印其错误信息</li>
<li>多场景都不应使用 panic</li>
</ul>
<h2 id="recover">Recover</h2>
<ul class="incremental">
<li>当 panic 触发后，会立即停止当前函数的执行，展开 goroutine 的栈，执行 defer 注册的函数，栈处理完成后停止程序</li>
<li>panic 流程中途用 recover 来恢复正常执行流程，recover 停下 goroutine 栈的展开</li>
<li>recover 只可写在 deferred 函数的内部</li>
</ul>

			</div>
		</section>
	</body>
</html>
