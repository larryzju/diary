<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2017-06-11 Sun 11:52 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Note on "Effective Go"</title>
<meta name="generator" content="Org mode">
<meta name="author" content="赵文彬">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">Note on "Effective Go"</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc39bc6f">Commentary</a></li>
<li><a href="#orgaf7f680">Names</a></li>
<li><a href="#org9bf1230">分号</a></li>
<li><a href="#org5af6f22">控制结构</a></li>
<li><a href="#org4c90632">函数</a></li>
<li><a href="#orgd9298ee">Data</a></li>
<li><a href="#org1e4779b">初始化</a></li>
<li><a href="#org732f770">Methods</a></li>
<li><a href="#orgb9177ef">Interfaces and other types</a></li>
<li><a href="#org8fe17b0">The Blank Identifier</a></li>
<li><a href="#orgd07261a">Errors</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orgc39bc6f" class="outline-2">
<h2 id="orgc39bc6f">Commentary</h2>
<div class="outline-text-2" id="text-orgc39bc6f">
<ul class="org-ul">
<li>注释有行注释和块注释两种</li>
<li>godoc 命令会根据注释内容生成文档</li>
<li>文档注释分为 package comment 和 doc comment</li>
<li>对于多文件的包，包注释只应出现在其中一个文件中</li>
<li>注释文档不会被进行格式化处理</li>
<li>每个导出的名称都应予以 doc comment 注释</li>
<li>var 或 const 分组只注释一次</li>
</ul>
</div>
</div>

<div id="outline-container-orgaf7f680" class="outline-2">
<h2 id="orgaf7f680">Names</h2>
<div class="outline-text-2" id="text-orgaf7f680">
<ul class="org-ul">
<li>首字母大小写决定包外的可见性</li>
<li>骆驼命名法</li>
</ul>
</div>

<div id="outline-container-orgaf903fd" class="outline-3">
<h3 id="orgaf903fd">Package names</h3>
<div class="outline-text-3" id="text-orgaf903fd">
<ul class="org-ul">
<li>包名即变量的引用名</li>
<li>要求：short, concise, evocative</li>
<li>由小写字母构成</li>
<li>在使用时可以起别名，但在定义时不要求严格的唯一</li>
<li>习惯上，package name 与源目录一致</li>
<li>导入的名称是完整路径</li>
<li>函数名不必再重复 package name</li>
<li>Long names don't automatically make things more readable. A helpful doc comment can often be more valuable than an extra long name.</li>
</ul>
</div>
</div>

<div id="outline-container-org342b07e" class="outline-3">
<h3 id="org342b07e">Getter</h3>
<div class="outline-text-3" id="text-org342b07e">
<ul class="org-ul">
<li>Go 不自动提供 getter 和 setter</li>
<li>习惯以 <code>Owner</code> 而非 <code>GetOwner</code> 表示 getter</li>
<li>以 <code>SetOwner</code> 来表示 setter</li>
</ul>
</div>
</div>

<div id="outline-container-orgb7cd409" class="outline-3">
<h3 id="orgb7cd409">Interface name</h3>
<div class="outline-text-3" id="text-orgb7cd409">
<ul class="org-ul">
<li>单方法接口以方法名加 'er' 后缀来命名</li>
<li>接口名不应与常用函数（Read，Writer，Close，Flush）重名</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org9bf1230" class="outline-2">
<h2 id="org9bf1230">分号</h2>
<div class="outline-text-2" id="text-org9bf1230">
<ul class="org-ul">
<li>Go 理论上用分号来分隔语句，但一般不写在源码里</li>
<li>lexer 会自动插入分号</li>
<li>在行结尾为 newline, number 或 string 常量，或符号 <code>break</code>, <code>continue</code>, <code>fallthrough</code>, <code>return</code>, <code>++</code>, <code>--</code>, <code>)</code>, <code>}</code> 被插入分号</li>
<li>if the newline comes after a token that could end a statement, insert a semicolon.</li>
<li>Go 中的分号一般只出现在 for 循环中，会用分隔三个条件</li>
<li>一行内的多个 statement 可以用分号来分隔</li>
<li>不能将 '(' 放在新的一行</li>
</ul>
</div>
</div>

<div id="outline-container-org5af6f22" class="outline-2">
<h2 id="org5af6f22">控制结构</h2>
<div class="outline-text-2" id="text-org5af6f22">
</div><div id="outline-container-orgecea828" class="outline-3">
<h3 id="orgecea828">基础</h3>
<div class="outline-text-3" id="text-orgecea828">
<ul class="org-ul">
<li>没有 <code>do .. while</code> 循环</li>
<li>通用的 <code>for</code></li>
<li>更有弹性的 <code>switch</code></li>
<li><code>if</code> 和 <code>switch</code> 包含一个可选的初始化</li>
<li><code>break</code> 和 <code>continue</code> 可以指定一个 label</li>
<li>新的 type switch 控制结构</li>
<li>select 控制结构</li>
</ul>
</div>
</div>


<div id="outline-container-org40fdc2f" class="outline-3">
<h3 id="org40fdc2f">for range</h3>
<div class="outline-text-3" id="text-org40fdc2f">
<ul class="org-ul">
<li>range 用于迭代 array, slice, string, map 及 channel</li>
<li>若只需要迭代 key 或 index，则 for 中只带一个迭代参数</li>
<li>若只需要第二个值，可以使用 <code>_</code></li>
<li>对 string 迭代，返回 rune (UTF8) 和 pos</li>
<li>对于无法识别的字符，返回 <code>U+FFFD</code> 特殊字符</li>
</ul>
</div>
</div>






<div id="outline-container-org17e7271" class="outline-3">
<h3 id="org17e7271">swtich</h3>
<div class="outline-text-3" id="text-org17e7271">
<ul class="org-ul">
<li>不加条件，可以构造 <code>if-elsif-else</code> 分支</li>
<li>case 中可以写多条件（用逗号分隔）</li>
<li>可以使用 break, 默认为每个 case 加入 break</li>
</ul>
</div>
</div>

<div id="outline-container-orge1775cd" class="outline-3">
<h3 id="orge1775cd">type switch</h3>
<div class="outline-text-3" id="text-orge1775cd">
<ul class="org-ul">
<li>discover the dynamic type of an interface variable</li>
<li>语法是 <code>t.(type)</code></li>
</ul>
</div>
</div>

<div id="outline-container-org39a70d4" class="outline-3">
<h3 id="org39a70d4">其它</h3>
<div class="outline-text-3" id="text-org39a70d4">
</div><div id="outline-container-org5c3db98" class="outline-4">
<h4 id="org5c3db98">Redeclaration and reassignment</h4>
<div class="outline-text-4" id="text-org5c3db98">
<ul class="org-ul">
<li>通过 <code>:=</code> 来进行申明时，变量 v 可以多次出现</li>
<li>但至少在申明列表中有一个新的变量</li>
<li>用于简化赋值与申明的语法切换</li>
</ul>
</div>
</div>

<div id="outline-container-orgf19d62d" class="outline-4">
<h4 id="orgf19d62d">与 C 的不同</h4>
<div class="outline-text-4" id="text-orgf19d62d">
<ul class="org-ul">
<li>Go 中没有 <code>++</code> 和 <code>--</code> 操作</li>
<li>Go 中没有 comma operator，但可以进行多赋值</li>
</ul>
</div>
</div>
</div>
</div>





<div id="outline-container-org4c90632" class="outline-2">
<h2 id="org4c90632">函数</h2>
<div class="outline-text-2" id="text-org4c90632">
</div><div id="outline-container-orgd042b7b" class="outline-3">
<h3 id="orgd042b7b">多返回值</h3>
<div class="outline-text-3" id="text-orgd042b7b">
<ul class="org-ul">
<li>避免像 C 中通过返回 -1，并修改指针内容来表示错误，和错误信息</li>
<li>多个返回值中可以设计上下文缓存，模拟 python yield</li>
</ul>
</div>
</div>

<div id="outline-container-org6e74da2" class="outline-3">
<h3 id="org6e74da2">具名返回参数</h3>
<div class="outline-text-3" id="text-org6e74da2">
<ul class="org-ul">
<li>函数初始化时，返回参数被初始化为零值</li>
<li>在裸 return 时，返回当时返回参数的值</li>
<li>可以作为手册，说明返回参数的信息</li>
</ul>
</div>
</div>

<div id="outline-container-orgc25b42b" class="outline-3">
<h3 id="orgc25b42b">Defer</h3>
<div class="outline-text-3" id="text-orgc25b42b">
<ul class="org-ul">
<li>用于保证资源被释放</li>
<li>在有多个 return 分支时，常会忘记释放的情况</li>
<li>在打开处进行关闭注册，代码更加清晰</li>
<li>defer 函数参数立即被展开</li>
<li>defer 可以多次调用，函数按 FILO 执行</li>
</ul>
</div>
</div>
</div>





<div id="outline-container-orgd9298ee" class="outline-2">
<h2 id="orgd9298ee">Data</h2>
<div class="outline-text-2" id="text-orgd9298ee">
</div><div id="outline-container-orgf2b119c" class="outline-3">
<h3 id="orgf2b119c">New</h3>
<div class="outline-text-3" id="text-orgf2b119c">
<ul class="org-ul">
<li>申请空间有两个原语 <code>new</code> 和 <code>make</code></li>
<li>new 仅用于申请空间并赋零值 ，但不会调用初始化过程</li>
<li>返回类型为 <code>*T</code> ，表示指向 T 类型变量所在的位置</li>
<li>设计类型时，尽可能让零值有意义</li>
</ul>
</div>
</div>



<div id="outline-container-org75dffb7" class="outline-3">
<h3 id="org75dffb7">Make</h3>
<div class="outline-text-3" id="text-org75dffb7">
<ul class="org-ul">
<li>只用于创建 slice, map 和 channel</li>
<li>返回一个被初始化的值（类型为 T）</li>
<li>与 new 进行区别，是因为有些类型变量需要进行初始化</li>
<li><code>make([]int, 10, 100)</code> 返回一个 slice, 容量为 100，长度为 10</li>
<li>可以忽略长度： <code>v := make([]int, 100)</code></li>
</ul>
</div>
</div>

<div id="outline-container-org1f645b3" class="outline-3">
<h3 id="org1f645b3">构造字面量</h3>
<div class="outline-text-3" id="text-org1f645b3">
<ul class="org-ul">
<li>composite literal</li>
<li>可以指定局部成员，可以乱序，如 <code>&amp;File{fd:fd, name:name}</code></li>
<li>可以完全不写成员值，以初始化空值</li>
<li>可以用于初始化 array, slice, map</li>
<li>数组类初始化，field 名称直接被忽略</li>
</ul>
</div>
</div>


<div id="outline-container-org77d3ac8" class="outline-3">
<h3 id="org77d3ac8">Arrays</h3>
<div class="outline-text-3" id="text-org77d3ac8">
<ul class="org-ul">
<li>与 C 的数组不同，在 Go 中
<ul class="org-ul">
<li>Array are value, 赋值相当于拷贝</li>
<li>将 array 作为函数的参数，会对值进行拷贝</li>
<li>The size of an array is part of its type: <code>[10]int</code></li>
</ul></li>
<li>为了提高效率，函数参数需要以指针传入，避免拷贝</li>
<li>一般用 slice 来替代直接使用 array</li>
</ul>
</div>
</div>


<div id="outline-container-org3a1df1f" class="outline-3">
<h3 id="org3a1df1f">Slices</h3>
<div class="outline-text-3" id="text-org3a1df1f">
<ul class="org-ul">
<li>对 arrays 的封装</li>
<li>更通用，功能更强，接口更方便</li>
<li>大部分应用场景下都应使用 slice 来替代 array</li>
<li>slice 是引用，赋值不会拷贝</li>
<li>slice 隐含有长度（和容量）信息</li>
<li>slice 的长度可以扩展，受底层 array 容量的限制</li>
<li>要改变 slice 长度，只需要对其切片赋值到新的 slice</li>
<li>内置有 append 函数</li>
</ul>
</div>
</div>






<div id="outline-container-orgb4b698d" class="outline-3">
<h3 id="orgb4b698d">Two-dimensional slices</h3>
<div class="outline-text-3" id="text-orgb4b698d">
<ul class="org-ul">
<li>例如 <code>type linesOfText [][]byte</code></li>
<li>slice 是变长的，所以内部（第二维） slice 可以是变长的</li>
<li>二维数组实现有两种方式
<ol class="org-ol">
<li>独立申请第二维 slice，类似 C 中指针数组</li>
<li>对一维数组中切片，适用于固定长度</li>
</ol></li>
</ul>
</div>
</div>



<div id="outline-container-orgbc4f286" class="outline-3">
<h3 id="orgbc4f286">Maps</h3>
<div class="outline-text-3" id="text-orgbc4f286">
<ul class="org-ul">
<li>key 可以是定义了 equality operator 的任意类型</li>
<li>key 可以是 interface 类型的</li>
<li>slice 不可以作为 key</li>
<li>map 是引用类型，会被函数修改</li>
<li>？？copy, deepcopy</li>
<li>类型写作 <code>map[string]int</code> ，表示 string 类的键指向 int 类的值</li>
<li>取不存在的键，返回零值</li>
<li>返回两个值，后一个作为是否存在的标志</li>
<li>delete 删除 map 中的成员，不存在也不会报错</li>
</ul>
</div>
</div>








<div id="outline-container-org0196f55" class="outline-3">
<h3 id="org0196f55">Printing</h3>
<div class="outline-text-3" id="text-org0196f55">
<ul class="org-ul">
<li>常用的函数有 <code>fmt.{Printf,Fprintf,Sprintf}</code></li>
<li>Println 插入空格和换行， Print 插入空格</li>
<li>Fprint 等函数的文件对象需要实现 <code>io.Writer</code> 接口</li>
<li>常用文件如 <code>os.Stdout</code> 或 <code>os.Stderr</code></li>
<li><code>%d</code> 不能像 C 一样带修饰符</li>
<li><code>%v</code> 作 default conversion，可打印复合结构，如 array, slice, struct, map</li>
<li>对于结构体, <code>%v</code> 显示值， <code>%+v</code> 显示键和值， <code>%#v</code> 以 Go 语法来显示键和值</li>
<li><code>%q</code>, 指 quote，用于 <code>string</code> 或 <code>[]byte</code></li>
<li><code>%#q</code> 使用 backquote 来作为引用符</li>
<li><code>%x</code> 可应用于 <code>string</code>, <code>[]byte</code></li>
<li><code>% x</code> 可以在 hex 中插入空格</li>
<li><code>%T</code> 打印变量的类型</li>
<li>通过实现 <code>T.String()</code> 方法来提供默认的格式化方法</li>
<li><code>func Printf( format string, v ...interface{} )(n int, err error)</code></li>
<li>v 是可变长参数列表，使用 <code>v...</code> 来展开（类似于 lisp apply）</li>
</ul>
</div>
</div>











<div id="outline-container-org8dc1310" class="outline-3">
<h3 id="org8dc1310">Append</h3>
<div class="outline-text-3" id="text-org8dc1310">
<ul class="org-ul">
<li>示意如下 <code>func append( slice []T, elements ...T)[]T</code></li>
<li>Go 不能实现对泛型的函数定义，因此 append 以内置函数实现</li>
<li><code>append( x, y... )</code> ，类似于 lisp 中的 <code>(append* a b)</code></li>
</ul>
</div>
</div>

<div id="outline-container-org1fcf610" class="outline-3">
<h3 id="org1fcf610">注意</h3>
<div class="outline-text-3" id="text-org1fcf610">
<ul class="org-ul">
<li>It's perfect OK to return the address of a local variable（涉及内存堆与栈的切换，以及 GC 的优化）</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org1e4779b" class="outline-2">
<h2 id="org1e4779b">初始化</h2>
<div class="outline-text-2" id="text-org1e4779b">
<p>
Go 比 C 或 C++ 更加强大，体现在：
</p>

<ol class="org-ol">
<li>复杂结构的构造</li>
<li>构造顺序问题</li>
</ol>
</div>

<div id="outline-container-org7375699" class="outline-3">
<h3 id="org7375699">Constants</h3>
<div class="outline-text-3" id="text-org7375699">
<ul class="org-ul">
<li>在编译期被创建</li>
<li>只能是 number, rune, string, boolean 类型</li>
<li>必须是 constant expression （编译需要）</li>
<li>使用 <code>iota</code> 生成枚举， iota 是表达式</li>
</ul>
</div>
</div>

<div id="outline-container-org0a24b67" class="outline-3">
<h3 id="org0a24b67">variables</h3>
<div class="outline-text-3" id="text-org0a24b67">
<ul class="org-ul">
<li>与 constant 语法类似</li>
<li>但在 run time 被初始化</li>
</ul>
</div>
</div>

<div id="outline-container-org1401ddf" class="outline-3">
<h3 id="org1401ddf">init function</h3>
<div class="outline-text-3" id="text-org1401ddf">
<ul class="org-ul">
<li>每个源文件可以有自己的 <code>init</code> 函数</li>
<li>在所有变量初始化完成后，包被初始化后才会执行</li>
<li>常用于验证和修改状态</li>
</ul>
</div>
</div>
</div>






<div id="outline-container-org732f770" class="outline-2">
<h2 id="org732f770">Methods</h2>
<div class="outline-text-2" id="text-org732f770">
</div><div id="outline-container-orga913d7a" class="outline-3">
<h3 id="orga913d7a">Pointers vs. Values</h3>
<div class="outline-text-3" id="text-orga913d7a">
<ul class="org-ul">
<li>methods can be defined for any named type ( except a pointer or an interface )</li>
<li>使用指针，方法可以直接修改 caller 本身</li>
<li>value methods can be invoked on pointers and values; but pointers methods can only be invoked on pointers</li>
<li>对于可取地址的值，对其进行方法调用时，编译器用自动进行地址引用。因此 <code>(&amp;b).Write</code> 可以简写为 <code>b.write</code></li>
</ul>
</div>
</div>
</div>



<div id="outline-container-orgb9177ef" class="outline-2">
<h2 id="orgb9177ef">Interfaces and other types</h2>
<div class="outline-text-2" id="text-orgb9177ef">
</div><div id="outline-container-org447858d" class="outline-3">
<h3 id="org447858d">Interfaces</h3>
<div class="outline-text-3" id="text-org447858d">
<ul class="org-ul">
<li>provider a way to specify the behavior of an object: <span class="underline">If something can do this, then it can be used there.</span></li>
<li>只有一到两个方法的 interface 属于常见</li>
<li>一个类型可以实现多个 interface 的方法，但不指定显示的继承实现路径</li>
</ul>
</div>
</div>

<div id="outline-container-org56aafb7" class="outline-3">
<h3 id="org56aafb7">Conversions</h3>
<div class="outline-text-3" id="text-org56aafb7">
<ul class="org-ul">
<li>两个底层构造一致的对象可以相互转换</li>
<li>转换并不是要创建新的对象，而仅是类型（及方法）的转换说明</li>
<li>可以将对象的类型进行转换，以使用不同接口中的方法</li>
</ul>
</div>
</div>

<div id="outline-container-org310d43b" class="outline-3">
<h3 id="org310d43b">Interface conversions and type assertions</h3>
<div class="outline-text-3" id="text-org310d43b">
<ul class="org-ul">
<li>type switch 有个常用的方式，对 interface 取 switch，在每个 case 中转换为相应的类型，进行具体的操作</li>
<li>switch 条件为 <code>value.(type)</code></li>
<li>通过 <code>value.(typeName)</code> 进行类型断言或转换</li>
<li>若无法转换，则会 crash with a run-time error</li>
<li>使用 "val, ok" 来测试是否能够正常转换</li>
</ul>
</div>
</div>

<div id="outline-container-org7628c24" class="outline-3">
<h3 id="org7628c24">Generality</h3>
<div class="outline-text-3" id="text-org7628c24">
<ul class="org-ul">
<li>若无 interface 以外的方法实现，类型便无意义</li>
<li>构造函数可以返回一个 interface 而非具体实现</li>
<li>通过对 interface 提供的接口进行开发，以实现抽象编程</li>
</ul>
</div>
</div>









<div id="outline-container-org82d4bf8" class="outline-3">
<h3 id="org82d4bf8">Interface and methods</h3>
<div class="outline-text-3" id="text-org82d4bf8">
<p>
<span class="underline">Almost anything can have methods attached, almost anythin can santisfy an interface</span>
</p>
</div>
</div>
</div>
<div id="outline-container-org8fe17b0" class="outline-2">
<h2 id="org8fe17b0">The Blank Identifier</h2>
<div class="outline-text-2" id="text-org8fe17b0">
<ul class="org-ul">
<li>can be assigned or declared with any value of any type, with the value discarded harmlessly</li>
<li>用于 multiple assignment</li>
<li>用于 unused imports and variables，引用未使用的包或变量，以避免编译错误</li>
<li>用于 import for side effect，如 <code>import _ "net/http/pprof"</code></li>
<li>用于 interface check，如 <code>var _ json.Marshaler = (*RamMessage)(nil)</code></li>
<li>类型无需指出它具体实现了哪些接口，而去具体实现相应的方法，大部分转换都在编译时进行的</li>
<li>使用 <code>value.(type)</code> 进行 check，会在运行时进行</li>
</ul>
</div>
</div>
<div id="outline-container-orgd07261a" class="outline-2">
<h2 id="orgd07261a">Errors</h2>
<div class="outline-text-2" id="text-orgd07261a">
<ul class="org-ul">
<li>正常情况通过多返回值来描述错误信息</li>
<li>错误类型为 <code>error</code> ，是一个内置的 interface，其中有 <code>Error()</code> 方法</li>
<li>除了简单的报错外，还可以提供一些上下文环境记录</li>
<li>调用者通过 type switch 或 type assertion 来区分 error 的具体类型</li>
</ul>
</div>

<div id="outline-container-orga76dc9b" class="outline-3">
<h3 id="orga76dc9b">Panic</h3>
<div class="outline-text-3" id="text-orga76dc9b">
<ul class="org-ul">
<li>对不可恢复的错误，使用 <code>panic</code> 来创建 runtime error，并停止程序执行</li>
<li>panic 后可以跟任意类型，一般是字符串，会打印其错误信息</li>
<li>多场景都不应使用 panic</li>
</ul>
</div>
</div>

<div id="outline-container-orgf490a1e" class="outline-3">
<h3 id="orgf490a1e">Recover</h3>
<div class="outline-text-3" id="text-orgf490a1e">
<ul class="org-ul">
<li>当 panic 触发后，会立即停止当前函数的执行，展开 goroutine 的栈，执行 defer 注册的函数，栈处理完成后停止程序</li>
<li>panic 流程中途用 recover 来恢复正常执行流程，recover 停下 goroutine 栈的展开</li>
<li>recover 只可写在 deferred 函数的内部</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: 赵文彬</p>
<p class="date">Created: 2017-06-11 Sun 11:52</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
