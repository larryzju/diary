<!DOCTYPE html>
<html>
	<head>
		<title>library.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="error">error</h1>
<h2 id="github.compkgerrors">github.com/pkg/errors</h2>
<p>Add context to the failure path in their code in a way that does not destroy the original value of the error.</p>
<h1 id="iofile">io/file</h1>
<h2 id="ioioutil">io/ioutil</h2>
<ul class="incremental">
<li>list directory</li>
<li></li>
</ul>
<h2 id="os">os</h2>
<ul class="incremental">
<li><code>FileInfo</code> type</li>
<li><code>File</code> type</li>
<li><code>Open</code> func</li>
</ul>
<h2 id="pathfilepath">path/filepath</h2>
<h2 id="io">io</h2>
<h1 id="unittest">unittest</h1>
<h2 id="github.comstretchrtestify">github.com/stretchr/testify</h2>
<p>With 4 subpackage</p>
<ol class="incremental">
<li>assert</li>
<li>require: similar to assert but end test if error</li>
<li>mock</li>
<li>suit: similar to python unittest and provides setup/teardown procedure</li>
</ol>
<h2 id="github.comgolangmock">github.com/golang/mock</h2>
<h3 id="mockgen">mockgen</h3>
<p>mockgen is a binary tool to generate mock object by</p>
<ol class="incremental">
<li>reflect of packages</li>
<li>from source</li>
</ol>
<h3 id="usage">usage</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1"></a>ctrl := gomock.NewController()</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">defer</span> ctrl.Finish()</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>obj := mocks.NewMockedObject(ctrl)</span>
<span id="cb1-5"><a href="#cb1-5"></a>obj.EXPECT().Method(gomock.Eq(arg), gomock.Any()).Do(<span class="kw">func</span>(a <span class="dt">int</span>, b <span class="kw">interface</span>{}) {</span>
<span id="cb1-6"><a href="#cb1-6"></a>}).Return(<span class="ot">nil</span>)</span></code></pre></div>
<h1 id="net">net</h1>
<h2 id="github.comgorillamux">github.com/gorilla/mux</h2>
<p>Like <code>http.ServeMux</code> but add extra dispatch features</p>
<h3 id="richer-matcher-function">Richer matcher function</h3>
<ul class="incremental">
<li>host, method, scheme, header, query value match</li>
<li>custom matcher function</li>
<li>combine multiple matchers in a single route</li>
</ul>
<h3 id="subrouter">subrouter</h3>
<p>Define subrouter and combine other matchers. Mostly used as namespace abstraction.</p>
<h3 id="registered-urls">Registered URLs</h3>
<p>Name the handle function and build the URL (or Host, or Path) by feed it parameters</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1"></a>r := mux.NewRouter()</span>
<span id="cb2-2"><a href="#cb2-2"></a>r.Host(<span class="st">&quot;{subdomain}.example.com&quot;</span>).</span>
<span id="cb2-3"><a href="#cb2-3"></a>  Path(<span class="st">&quot;/articles/{category}/{id:[0-9]+}&quot;</span>).</span>
<span id="cb2-4"><a href="#cb2-4"></a>  Queries(<span class="st">&quot;filter&quot;</span>, <span class="st">&quot;{filter}&quot;</span>).</span>
<span id="cb2-5"><a href="#cb2-5"></a>  HandlerFunc(ArticleHandler).</span>
<span id="cb2-6"><a href="#cb2-6"></a>  Name(<span class="st">&quot;article&quot;</span>)</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">// url.String() will be &quot;http://news.example.com/articles/technology/42?filter=gorilla&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>url, err := r.Get(<span class="st">&quot;article&quot;</span>).URL(<span class="st">&quot;subdomain&quot;</span>, <span class="st">&quot;news&quot;</span>,</span>
<span id="cb2-10"><a href="#cb2-10"></a>                                 <span class="st">&quot;category&quot;</span>, <span class="st">&quot;technology&quot;</span>,</span>
<span id="cb2-11"><a href="#cb2-11"></a>                                 <span class="st">&quot;id&quot;</span>, <span class="st">&quot;42&quot;</span>,</span>
<span id="cb2-12"><a href="#cb2-12"></a>                                 <span class="st">&quot;filter&quot;</span>, <span class="st">&quot;gorilla&quot;</span>)</span></code></pre></div>
<h3 id="walking-routes">Walking Routes</h3>
<p>Loop over all the registered routes. Simliar to <code>filepath.Walk()</code></p>
<h3 id="middleware">Middleware</h3>
<p>Almost like clojure ring middleware (and also python's decorator). Hack the request for each middlewares and pass the new request to the next one.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> MiddlewareFunc <span class="kw">func</span>(http.Handler) http.Handler</span></code></pre></div>
<p>Some common use cases for middleware are</p>
<ul class="incremental">
<li>request logging</li>
<li>header manipulation</li>
<li><code>ResponseWriter</code> hijacking</li>
</ul>
<p>To use the middleware</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1"></a>r := mux.NewRouter()</span>
<span id="cb4-2"><a href="#cb4-2"></a>r.HandleFunc(<span class="st">&quot;/&quot;</span>, handler)</span>
<span id="cb4-3"><a href="#cb4-3"></a>r.Use(loggingMiddleware)</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">func</span> loggingMiddleware(next http.Handler) http.Handler {</span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="kw">return</span> http.HandlerFunc(<span class="kw">func</span>(w http.ResponseWriter, r *http.Request) {</span>
<span id="cb4-7"><a href="#cb4-7"></a>        <span class="co">// Do stuff here</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>        log.Println(r.RequestURI)</span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="co">// Call the next handler, which can be another middleware in the chain, or the final handler.</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>        next.ServeHTTP(w, r)</span>
<span id="cb4-11"><a href="#cb4-11"></a>    })</span>
<span id="cb4-12"><a href="#cb4-12"></a>}</span></code></pre></div>

			</div>
		</section>
	</body>
</html>
