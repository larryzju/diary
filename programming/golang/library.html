<!DOCTYPE html>
<html>
	<head>
		<title>library.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="error">error</h1>
<h2 id="github.compkgerrors">github.com/pkg/errors</h2>
<p>Add context to the failure path in their code in a way that does not destroy the original value of the error.</p>
<h1 id="iofile">io/file</h1>
<h2 id="ioioutil">io/ioutil</h2>
<ul class="incremental">
<li>list directory</li>
<li></li>
</ul>
<h2 id="os">os</h2>
<ul class="incremental">
<li><code>FileInfo</code> type</li>
<li><code>File</code> type</li>
<li><code>Open</code> func</li>
</ul>
<h2 id="pathfilepath">path/filepath</h2>
<h2 id="io">io</h2>
<h1 id="unittest">unittest</h1>
<h2 id="github.comstretchrtestify">github.com/stretchr/testify</h2>
<p>With 4 subpackage</p>
<ol class="incremental">
<li>assert</li>
<li>require: similar to assert but end test if error</li>
<li>mock</li>
<li>suit: similar to python unittest and provides setup/teardown procedure</li>
</ol>
<h2 id="github.comgolangmock">github.com/golang/mock</h2>
<h3 id="mockgen">mockgen</h3>
<p>mockgen is a binary tool to generate mock object by</p>
<ol class="incremental">
<li>reflect of packages</li>
<li>from source</li>
</ol>
<h3 id="usage">usage</h3>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ctrl := gomock.NewController()
<span class="kw">defer</span> ctrl.Finish()

obj := mocks.NewMockedObject(ctrl)
obj.EXPECT().Method(gomock.Eq(arg), gomock.Any()).Do(<span class="kw">func</span>(a <span class="dt">int</span>, b <span class="kw">interface</span>{}) {
}).Return(<span class="ot">nil</span>)</code></pre></div>
<h1 id="net">net</h1>
<h2 id="github.comgorillamux">github.com/gorilla/mux</h2>
<p>Like <code>http.ServeMux</code> but add extra dispatch features</p>
<h3 id="richer-matcher-function">Richer matcher function</h3>
<ul class="incremental">
<li>host, method, scheme, header, query value match</li>
<li>custom matcher function</li>
<li>combine multiple matchers in a single route</li>
</ul>
<h3 id="subrouter">subrouter</h3>
<p>Define subrouter and combine other matchers. Mostly used as namespace abstraction.</p>
<h3 id="registered-urls">Registered URLs</h3>
<p>Name the handle function and build the URL (or Host, or Path) by feed it parameters</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">r := mux.NewRouter()
r.Host(<span class="st">&quot;{subdomain}.example.com&quot;</span>).
  Path(<span class="st">&quot;/articles/{category}/{id:[0-9]+}&quot;</span>).
  Queries(<span class="st">&quot;filter&quot;</span>, <span class="st">&quot;{filter}&quot;</span>).
  HandlerFunc(ArticleHandler).
  Name(<span class="st">&quot;article&quot;</span>)

<span class="co">// url.String() will be &quot;http://news.example.com/articles/technology/42?filter=gorilla&quot;</span>
url, err := r.Get(<span class="st">&quot;article&quot;</span>).URL(<span class="st">&quot;subdomain&quot;</span>, <span class="st">&quot;news&quot;</span>,
                                 <span class="st">&quot;category&quot;</span>, <span class="st">&quot;technology&quot;</span>,
                                 <span class="st">&quot;id&quot;</span>, <span class="st">&quot;42&quot;</span>,
                                 <span class="st">&quot;filter&quot;</span>, <span class="st">&quot;gorilla&quot;</span>)</code></pre></div>
<h3 id="walking-routes">Walking Routes</h3>
<p>Loop over all the registered routes. Simliar to <code>filepath.Walk()</code></p>
<h3 id="middleware">Middleware</h3>
<p>Almost like clojure ring middleware (and also python's decorator). Hack the request for each middlewares and pass the new request to the next one.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> MiddlewareFunc <span class="kw">func</span>(http.Handler) http.Handler</code></pre></div>
<p>Some common use cases for middleware are</p>
<ul class="incremental">
<li>request logging</li>
<li>header manipulation</li>
<li><code>ResponseWriter</code> hijacking</li>
</ul>
<p>To use the middleware</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">r := mux.NewRouter()
r.HandleFunc(<span class="st">&quot;/&quot;</span>, handler)
r.Use(loggingMiddleware)

<span class="kw">func</span> loggingMiddleware(next http.Handler) http.Handler {
    <span class="kw">return</span> http.HandlerFunc(<span class="kw">func</span>(w http.ResponseWriter, r *http.Request) {
        <span class="co">// Do stuff here</span>
        log.Println(r.RequestURI)
        <span class="co">// Call the next handler, which can be another middleware in the chain, or the final handler.</span>
        next.ServeHTTP(w, r)
    })
}</code></pre></div>

			</div>
		</section>
	</body>
</html>
