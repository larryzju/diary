<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2017-06-10 Sat 23:36 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>learning go 笔记</title>
<meta name="generator" content="Org mode">
<meta name="author" content="赵文彬">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/diary/style/style.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">learning go 笔记</h1>
</header>
<div id="outline-container-org8ca2b9f" class="outline-2">
<h2 id="org8ca2b9f">Introduction</h2>
<div class="outline-text-2" id="text-org8ca2b9f">
</div><div id="outline-container-org48f925c" class="outline-3">
<h3 id="org48f925c">语言的特性</h3>
<div class="outline-text-3" id="text-org48f925c">
<ul class="org-ul">
<li>Clean and Simple</li>
<li>Concurrent ( goroutine 轻量级线程 )</li>
<li>Channels</li>
<li>Fast 编译和运行</li>
<li>Safe 显示要求和严格的规则，内存回收</li>
<li>gofmt</li>
<li>Postfix types</li>
<li>UTF8 (python3 级)</li>
<li>Open Source</li>
<li>Fun</li>
</ul>
</div>
</div>

<div id="outline-container-orgcea1f16" class="outline-3">
<h3 id="orgcea1f16">查看帮助</h3>
<div class="outline-text-3" id="text-orgcea1f16">
<dl class="org-dl">
<dt><code>godoc builtin</code></dt><dd>类似于 <code>java.lang.System</code></dd>
<dt><code>godoc hash</code></dt><dd>查看包的手册</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org080fd2f" class="outline-2">
<h2 id="org080fd2f">基础</h2>
<div class="outline-text-2" id="text-org080fd2f">
</div><div id="outline-container-orgffc00be" class="outline-3">
<h3 id="orgffc00be"><span class="todo TODO">TODO</span> hello world</h3>
<div class="outline-text-3" id="text-orgffc00be">
<div class="org-src-container">
<pre class="src src-go">package main

import "fmt"

func main() {
    fmt.Printf( "Hello World." )
}
</pre>
</div>

<ul class="org-ul">
<li>可执行程序包名必须是 <code>main</code></li>
<li>可执行程序的入口是 <code>main.main()</code></li>
<li>main 的参数由 sys 传入?（类似 python）</li>
</ul>
</div>
</div>


<div id="outline-container-orgabf7187" class="outline-3">
<h3 id="orgabf7187">编译执行</h3>
<div class="outline-text-3" id="text-orgabf7187">
<div class="org-src-container">
<pre class="src src-shell">go build helloworld.go
</pre>
</div>

<ul class="org-ul">
<li>文件名可以与包名不一致</li>
<li>生成结果与文件名一致</li>
<li>可以直接使用 <code>go run helloworld.go</code> 来运行</li>
</ul>
</div>
</div>




<div id="outline-container-org4f08b61" class="outline-3">
<h3 id="org4f08b61">基础类型和变量</h3>
<div class="outline-text-3" id="text-org4f08b61">
</div><div id="outline-container-org4387231" class="outline-4">
<h4 id="org4387231">类型后缀形式</h4>
<div class="outline-text-4" id="text-org4387231">
<div class="org-src-container">
<pre class="src src-go">var a int
</pre>
</div>

<p>
类型有默认的空值
</p>
</div>
</div>

<div id="outline-container-org8cce32d" class="outline-4">
<h4 id="org8cce32d">声明与初始化可以写在一起</h4>
<div class="outline-text-4" id="text-org8cce32d">
<p>
如 <code>var a = 15; a := 15</code> 等价于 <code>a = 15</code>
</p>

<p>
<code>:=</code> 是赋值语句，只能用在函数内部
</p>
</div>
</div>

<div id="outline-container-orga84143c" class="outline-4">
<h4 id="orga84143c">多个变量申明</h4>
<div class="outline-text-4" id="text-orga84143c">
<p>
多变量申明可以放于一起，类似的还有 <code>const</code> 和 =import=，如
</p>

<div class="org-src-container">
<pre class="src src-go">var (
  x int
  b bool
)
</pre>
</div>

<p>
相同类型的变量可以一起申明或赋值
</p>

<pre class="example">
var x, y int 
a, b := 20, 16
</pre>
</div>
</div>

<div id="outline-container-org77adc74" class="outline-4">
<h4 id="org77adc74">特殊变量 <code>`_`</code></h4>
<div class="outline-text-4" id="text-org77adc74">
<p>
类似于 lua，表示丢弃这一变量
</p>

<p>
go 中检查比较严格，发现未使用的变量会报错，使用 <code>_</code> 来显示的解决错误
</p>
</div>
</div>

<div id="outline-container-orgcc56953" class="outline-4">
<h4 id="orgcc56953">Boolean</h4>
<div class="outline-text-4" id="text-orgcc56953">
<ul class="org-ul">
<li>关键字是 <code>bool</code></li>
<li>两个字面值是 <code>true</code> 和 <code>false</code></li>
</ul>
</div>
</div>

<div id="outline-container-org4f0e68a" class="outline-4">
<h4 id="org4f0e68a">Numerical</h4>
<div class="outline-text-4" id="text-org4f0e68a">
<dl class="org-dl">
<dt><code>int</code></dt><dd>宽度视平台而定</dd>
<dt><code>uint</code></dt><dd>同上</dd>
<dt><code>[u]int{8,16,32,64}</code></dt><dd>指定具体宽度</dd>
<dt><code>byte</code></dt><dd>对应 <code>uint8</code></dd>
<dt><code>float{32,64}</code></dt><dd>浮点数（无 double）</dd>
</dl>
</div>

<ul class="org-ul"><li><a id="org72ae440"></a><span class="todo TODO">TODO</span> 类型转换<br><div class="outline-text-5" id="text-org72ae440">
<p>
不同类型之前直接不可赋值或计算 
</p>
</div></li></ul>
</div>

<div id="outline-container-org071bf7e" class="outline-4">
<h4 id="org071bf7e">Constants</h4>
<div class="outline-text-4" id="text-org071bf7e">
<p>
在编译时生成，只能是数字、字符串或布尔值。
</p>
</div>

<ul class="org-ul"><li><a id="org91407f5"></a><span class="todo TODO">TODO</span> 枚举<br><div class="outline-text-5" id="text-org91407f5">
<p>
使用 <code>iota</code> 来生成枚举（ iota 指极少量）
</p>

<p>
为什么这里的 iota 可以省略？
</p>

<div class="org-src-container">
<pre class="src src-go">const (
  a = iota
  b
)
</pre>
</div>
</div></li></ul>
</div>







<div id="outline-container-org85325cc" class="outline-4">
<h4 id="org85325cc"><span class="todo TODO">TODO</span> Strings</h4>
<div class="outline-text-4" id="text-org85325cc">
<ul class="org-ul">
<li>以双引号表示</li>
<li>？单引号表示字符？</li>
<li>字符串不可修改（immutable）</li>
</ul>
</div>
</div>


<div id="outline-container-org6947c2b" class="outline-4">
<h4 id="org6947c2b"><span class="todo TODO">TODO</span> Runes</h4>
<div class="outline-text-4" id="text-org6947c2b">
<p>
是 <code>int32</code> 的别名，保存 utf8 编码，方便对宽字符集作操作
</p>

<p>
可以修改？
</p>
</div>
</div>


<div id="outline-container-org91cc83b" class="outline-4">
<h4 id="org91cc83b"><span class="todo TODO">TODO</span> Complex Numbers</h4>
<div class="outline-text-4" id="text-org91cc83b">
<p>
原生支持复数，有两个类型
</p>

<ol class="org-ol">
<li><code>complex128</code></li>
<li><code>complex64</code></li>
</ol>

<p>
有没有字面表示方法？
</p>
</div>
</div>


<div id="outline-container-org75db5b8" class="outline-4">
<h4 id="org75db5b8"><span class="todo TODO">TODO</span> Error</h4>
<div class="outline-text-4" id="text-org75db5b8">
<ul class="org-ul">
<li>默认值是 <code>nil</code></li>
</ul>
</div>
</div>
</div>







<div id="outline-container-org543d4a0" class="outline-3">
<h3 id="org543d4a0">操作符和基本函数</h3>
<div class="outline-text-3" id="text-org543d4a0">
<p>
go 不支持运算符重载！
</p>
</div>
</div>



<div id="outline-container-orgf36c5cf" class="outline-3">
<h3 id="orgf36c5cf">控制结构</h3>
<div class="outline-text-3" id="text-orgf36c5cf">
</div><div id="outline-container-org2132de4" class="outline-4">
<h4 id="org2132de4">if-else</h4>
<div class="outline-text-4" id="text-org2132de4">
<ul class="org-ul">
<li>if 可以像 for 有初始步骤</li>
<li>条件不加括号</li>
<li>body 必须使用大括号</li>
</ul>
</div>
</div>

<div id="outline-container-orgaa71111" class="outline-4">
<h4 id="orgaa71111">goto</h4>
<div class="outline-text-4" id="text-orgaa71111">
<ul class="org-ul">
<li>和 C 一样，跳转到 label 处</li>
<li>label 大小写无要求</li>
</ul>
</div>
</div>

<div id="outline-container-org9117da3" class="outline-4">
<h4 id="org9117da3">for</h4>
<div class="outline-text-4" id="text-org9117da3">
<ul class="org-ul">
<li>基本形式与 C 的一致</li>
<li>可以省略初始和变化而部分，退化成 <code>while(condition)</code></li>
<li>可以全部省略三个参数，退化成 <code>while()</code></li>
<li>for 中初始的变量只能在 for 中使用</li>
</ul>
</div>
</div>

<div id="outline-container-org7aaa31c" class="outline-4">
<h4 id="org7aaa31c">break and continue</h4>
<div class="outline-text-4" id="text-org7aaa31c">
<ul class="org-ul">
<li>基本用法和 C 的致</li>
<li>另外可以指定退出的 label，跳出多层循环</li>
</ul>
</div>
</div>

<div id="outline-container-org5234758" class="outline-4">
<h4 id="org5234758">range</h4>
<div class="outline-text-4" id="text-org5234758">
<ul class="org-ul">
<li>关键字 <code>range</code> 用于迭代序列 (loop over)</li>
<li>对于 slice 或 array，返回 <code>index: int</code> 和 <code>value: string</code></li>
<li>字符串是对每个 UTF8 字符进行迭代，postition 为字节数</li>
</ul>
</div>
</div>

<div id="outline-container-org050b8f1" class="outline-4">
<h4 id="org050b8f1"><span class="todo TODO">TODO</span> switch</h4>
<div class="outline-text-4" id="text-org050b8f1">
<div class="org-src-container">
<pre class="src src-go">switch{
  case '0' &lt;= c &amp;&amp; c &lt;= '9':
    return c - '0'
  case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
    return c - 'a' + 10
  case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
    return c - 'A' + 10
}

switch i {
  case 0, 1:
    f()
  case 2: fallthrough
  case 3: 
    h()
  default:
    g()
</pre>
</div>

<ul class="org-ul">
<li>匹配的可以不止是整数（与C相比）</li>
<li>不加条件的 switch 相当于 <code>switch true</code> ， 可以用于生成条件分支</li>
<li>不用加 break，若要生成多条件匹配，用关键字 <code>fallthrough</code></li>
<li>默认分支用 <code>default</code> 标识</li>
<li>case 后可以跟多个条件</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org4869bbf" class="outline-2">
<h2 id="org4869bbf">内建函数</h2>
<div class="outline-text-2" id="text-org4869bbf">
</div><div id="outline-container-orgeb017c7" class="outline-3">
<h3 id="orgeb017c7">基础</h3>
<div class="outline-text-3" id="text-orgeb017c7">
<p>
<b>使用 <code>godoc builtin</code> 来查看内建函数手册</b>
</p>

<dl class="org-dl">
<dt>close</dt><dd>close a channel</dd>
<dt>delete</dt><dd>delete entries in maps</dd>
<dt>len/cap</dt><dd>长度，容量</dd>
<dt>new</dt><dd>allocating memory for user defined data types.</dd>
<dt>make</dt><dd>allocating memory for builtin types (maps,slices,channels)</dd>
<dt>copy/append</dt><dd>copy or concatenating slices</dd>
<dt>panic,recover</dt><dd>used for an exception mechanism</dd>
<dt>complex,real,img</dt><dd>deal with complex numbers</dd>
</dl>
</div>
</div>

<div id="outline-container-org7b27e1d" class="outline-3">
<h3 id="org7b27e1d">Arrays</h3>
<div class="outline-text-3" id="text-org7b27e1d">
</div><div id="outline-container-org2d3e327" class="outline-4">
<h4 id="org2d3e327">示例</h4>
<div class="outline-text-4" id="text-org2d3e327">
<div class="org-src-container">
<pre class="src src-go">var arr [10]int
a := [3]int{1,2,3}
b := [...]int{1,2,3,4} // composite literal
</pre>
</div>
</div>
</div>

<div id="outline-container-org055efd8" class="outline-4">
<h4 id="org055efd8">特性</h4>
<div class="outline-text-4" id="text-org055efd8">
<ul class="org-ul">
<li>有固定长度</li>
<li>函数参数时传递拷贝，而非指针</li>
</ul>
</div>
</div>
</div>








<div id="outline-container-org291106a" class="outline-3">
<h3 id="org291106a">Slices</h3>
<div class="outline-text-3" id="text-org291106a">
<ul class="org-ul">
<li>类似于数组，但可以动态扩展（通过 <b>append</b> 和 <b>copy</b> ）方法</li>
<li>底层也是 array</li>
<li>是到 array 的指针（类似于 C++ 中的引用类型）</li>
<li>引用类型通过 <b>make</b> 生成</li>
</ul>
</div>

<div id="outline-container-org68ea17d" class="outline-4">
<h4 id="org68ea17d">示例</h4>
<div class="outline-text-4" id="text-org68ea17d">
<div class="org-src-container">
<pre class="src src-go">c  := [...]int{1,2,3,4,5}
sa := make([]int, 10)
sb := c[:3]
sc := c[0:3:4] // 同时设定 cap
</pre>
</div>
</div>
</div>


<div id="outline-container-org6f49358" class="outline-4">
<h4 id="org6f49358">append</h4>
<div class="outline-text-4" id="text-org6f49358">
<ul class="org-ul">
<li>append 会生成新的底层数组</li>
<li>后面跟数组元素类型时，添加元素: <code>append(s,1,2,3)</code></li>
<li>后面跟数组类型时，添加数组（注意 <b>`&#x2026;`</b> ） <code>append(s,s2...)</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-go">s1 := []int{1,2,3}
s2 := []int{5,6,7}
fmt.Println( append(s1,s2...) )
</pre>
</div>
</div>
</div>


<div id="outline-container-org037ff2e" class="outline-4">
<h4 id="org037ff2e">copy</h4>
<div class="outline-text-4" id="text-org037ff2e">
<ul class="org-ul">
<li>copy 返回实际拷贝长度（类似 memcpy）</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org5b53952" class="outline-3">
<h3 id="org5b53952"><span class="todo TODO">TODO</span> Array VS Slices</h3>
<div class="outline-text-3" id="text-org5b53952">
</div><div id="outline-container-org01e7a75" class="outline-4">
<h4 id="org01e7a75">初始化方式</h4>
<div class="outline-text-4" id="text-org01e7a75">
<p>
Array 初始化时需要指定长度: `[3]int{1,2,3}` 或 `[&#x2026;]int{1,2,3}` ；
而 Slices 不需要指定: `[]int{1,2,3}`
</p>
</div>
</div>

<div id="outline-container-org2852bba" class="outline-4">
<h4 id="org2852bba"><span class="todo TODO">TODO</span> 如何确定 array 或 slices</h4>
</div>
</div>

<div id="outline-container-orgb03b90a" class="outline-3">
<h3 id="orgb03b90a">Maps</h3>
<div class="outline-text-3" id="text-orgb03b90a">
</div><div id="outline-container-orgb065d88" class="outline-4">
<h4 id="orgb065d88">类比</h4>
<div class="outline-text-4" id="text-orgb065d88">
<ul class="org-ul">
<li>Perl 中的 hash</li>
<li>python 中的 dictionary</li>
<li>C++ 中的maps</li>
</ul>
</div>
</div>

<div id="outline-container-orgc09d586" class="outline-4">
<h4 id="orgc09d586">语法</h4>
<div class="outline-text-4" id="text-orgc09d586">
<div class="org-src-container">
<pre class="src src-go">monthdays := map[string]int{
  "Jan": 31, "Feb": 28, "Mar": 31,
  "Apr": 30, "May": 31, "Jun": 30,
  "Jul": 31, "Aug": 31, "Sep": 30,
  "Oct": 31, "Nov": 30, "Dec": 31,
}
</pre>
</div>

<ul class="org-ul">
<li>通用的语法是: <code>map[&lt;from type&gt;]&lt;to type&gt;</code></li>
<li>注意， <b>结尾的逗号是必须的</b></li>
<li>使用 <code>make[string]int</code> 来生成一个 map</li>
<li>map 是一个引用类型</li>
<li>与数组一样，通过方括号进行访问</li>
<li>通过 <b>range</b> 来迭代</li>
<li>通过 <code>value, present := monthdays["Jan"]</code> 来测试是否存在</li>
<li>通过 <code>delete( monthdays, "Mar" )</code> 来删除键值</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orga9326d4" class="outline-2">
<h2 id="orga9326d4">函数</h2>
<div class="outline-text-2" id="text-orga9326d4">
</div><div id="outline-container-orge8c4a26" class="outline-3">
<h3 id="orge8c4a26"><span class="todo TODO">TODO</span> receiver</h3>
</div>
<div id="outline-container-org33f90a1" class="outline-3">
<h3 id="org33f90a1">定义函数</h3>
<div class="outline-text-3" id="text-org33f90a1">
<div class="org-src-container">
<pre class="src src-go">type mytype int
func ( p mytype ) funcname ( q int ) ( r, s int ) { return 0, 0 }
</pre>
</div>
</div>

<div id="outline-container-org85a4dbb" class="outline-4">
<h4 id="org85a4dbb"><span class="todo TODO">TODO</span> 说明</h4>
<div class="outline-text-4" id="text-org85a4dbb">
<ul class="org-ul">
<li>optionally bind to a specific type called receiver ( method )</li>
<li>parameters are passed pass-by-value</li>
<li>functions in Go can have multiple return values</li>
<li>named result parameters, return 后不加参数时被返回</li>
<li>函数可以以任意顺序声明（与 C 需要声明不同）</li>
<li>不允许函数嵌套定义！！但可以使用匿名函数</li>
<li>可以递归。尾递归？？</li>
</ul>
</div>
</div>
</div>



<div id="outline-container-org4f530b0" class="outline-3">
<h3 id="org4f530b0">作用域</h3>
<div class="outline-text-3" id="text-org4f530b0">
<ul class="org-ul">
<li>注意赋值 <code>=</code> 与定义 <code>:=</code> 的区别</li>
<li>函数的局部变量不会绑定到要调用的函数环境中</li>
</ul>
</div>
</div>

<div id="outline-container-orga8f0d28" class="outline-3">
<h3 id="orga8f0d28">高阶函数</h3>
<div class="outline-text-3" id="text-orga8f0d28">
<div class="org-src-container">
<pre class="src src-go">var xs = map[int]func() int{
  1: func() int {return 10},
  2: func() int {return 20},
  3: func() int {return 30},
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org039bf38" class="outline-3">
<h3 id="org039bf38">defer</h3>
<div class="outline-text-3" id="text-org039bf38">
<ul class="org-ul">
<li>不是 lazy eval，而类似于 atexit。在函数退出时被回调</li>
<li>可以多次注册，以 LIFO （栈）形式被回调</li>
<li>defer 还可以用于装饰返回结果（如 JSON 序列化）</li>
</ul>
</div>
</div>

<div id="outline-container-orgb813642" class="outline-3">
<h3 id="orgb813642">变长参数列表</h3>
<div class="outline-text-3" id="text-orgb813642">
<p>
类似于 scala，示例如下：
</p>

<div class="org-src-container">
<pre class="src src-go">func myfunc2( args ...string ) {
	for _, v := range args {
		fmt.Println( v )
	}
}

func myfunc( args ...string ) {
	myfunc2( args[3:]... )
}
</pre>
</div>
</div>

<div id="outline-container-orgd499b82" class="outline-4">
<h4 id="orgd499b82"><span class="todo TODO">TODO</span> interface</h4>
<div class="outline-text-4" id="text-orgd499b82">
<p>
If you don't specify the type of the varadic argument
it defaults to the empty interface <code>interface{}</code>
</p>
</div>
</div>
</div>

<div id="outline-container-org4c18b7e" class="outline-3">
<h3 id="org4c18b7e">Panic and recovering</h3>
<div class="outline-text-3" id="text-org4c18b7e">
</div><div id="outline-container-orgac34504" class="outline-4">
<h4 id="orgac34504"><span class="todo TODO">TODO</span> Exception vs Panic-Recovering</h4>
<div class="outline-text-4" id="text-orgac34504">
<p>
GO 不提供异常捕获机制
</p>
</div>

<ul class="org-ul"><li><a id="org1fd82ef"></a><span class="todo TODO">TODO</span> 原因<br></li>

<li><a id="org3cfcc5c"></a><span class="todo TODO">TODO</span> 区别<br></li>

<li><a id="orgd850b8b"></a><span class="todo TODO">TODO</span> 细节<br><ul class="org-ul"><li><a id="org86250df"></a>Panic<br><div class="outline-text-6" id="text-org86250df">
<ul class="org-ul">
<li>函数调用 <code>panic</code> 时，函数的 defer 被回调，然后返回到被调用处</li>
<li>对外层函数，触发 panic 的函数，此时相当于一个 panic</li>
<li>沿着栈回溯向下</li>
</ul>
</div></li>

<li><a id="org73056e9"></a>Recover<br><div class="outline-text-6" id="text-org73056e9">
<ul class="org-ul">
<li>正常执行中，返回 nil，无其它作用</li>
<li>用于恢复被 panic 打断的执行</li>
</ul>
</div></li></ul></li></ul>
</div>
</div>
</div>



<div id="outline-container-org92b60b7" class="outline-2">
<h2 id="org92b60b7">Packages</h2>
<div class="outline-text-2" id="text-org92b60b7">
</div><div id="outline-container-orgd06e21a" class="outline-3">
<h3 id="orgd06e21a">定义</h3>
<div class="outline-text-3" id="text-orgd06e21a">
<p>
A package is a collection of functions and data.
</p>
</div>
</div>

<div id="outline-container-orga2cfc88" class="outline-3">
<h3 id="orga2cfc88">说明</h3>
<div class="outline-text-3" id="text-orga2cfc88">
<ul class="org-ul">
<li>文件名与包名无关</li>
<li>包名通常用小写命名</li>
<li>多个文件可以取相同的包名</li>
<li>包里的以大写开头的函数对外可见（exported）</li>
<li>导入名与代码路径一致</li>
<li>包名是路径的最后一级</li>
<li><code>import bar "bytes"</code> 重命名包</li>
</ul>
</div>
</div>

<div id="outline-container-orgd4d125a" class="outline-3">
<h3 id="orgd4d125a"><span class="todo TODO">TODO</span> 多文件包融合问题</h3>
</div>

<div id="outline-container-org4197d0e" class="outline-3">
<h3 id="org4197d0e"><span class="todo TODO">TODO</span> Document</h3>
<div class="outline-text-3" id="text-org4197d0e">
<ul class="org-ul">
<li>在 <code>package</code> 关键字节可以加入块级注释，作为代码的文档</li>
<li>用 <code>go doc</code> 来查看</li>
<li>多文件的包应该只写一次（重复写会怎样？）</li>
<li>习惯上建立一个 <code>doc.go</code> 来写文档</li>
<li>函数注释同理</li>
</ul>
</div>
</div>


<div id="outline-container-orge560ed1" class="outline-3">
<h3 id="orge560ed1"><span class="todo TODO">TODO</span> Testing packages</h3>
<div class="outline-text-3" id="text-orge560ed1">
<ul class="org-ul">
<li>使用 <code>testing</code> 包提供的功能</li>
<li>调用 <code>go test</code> 测试</li>
<li>test 文件以 <code>*_test.go</code> 为后缀</li>
<li>test 函数原型是 <code>Test: func TestXxx( t *testing.T )</code></li>
<li>使用 <code>go doc testing</code> 或 <code>go help testfun</code> 来查看帮助</li>
</ul>
</div>

<div id="outline-container-org95d6527" class="outline-4">
<h4 id="org95d6527">常用函数</h4>
<div class="outline-text-4" id="text-org95d6527">
<dl class="org-dl">
<dt><code>func (t *T) Fail()</code></dt><dd>failed but continues execution</dd>
<dt><code>func (t *T) FailNow()</code></dt><dd>fail and stop execution</dd>
<dt><code>func (t *T) Log( args ...interface{} )</code></dt><dd>error log</dd>
<dt><code>func (t *T) Fatal(args ...interface{} )</code></dt><dd>Log + FailNow</dd>
</dl>
</div>
</div>
</div>








<div id="outline-container-org0edc84c" class="outline-3">
<h3 id="org0edc84c">常用 Packages</h3>
<div class="outline-text-3" id="text-org0edc84c">
</div><div id="outline-container-orge2d16f2" class="outline-4">
<h4 id="orge2d16f2">列表</h4>
<div class="outline-text-4" id="text-orge2d16f2">
<dl class="org-dl">
<dt>fmt</dt><dd>注意比 C 多出的 <code>%v</code>, <code>%#v</code>, <code>%T</code></dd>
<dt>io</dt><dd>I/O primitives</dd>
<dt>bufio</dt><dd>buffered I/O</dd>
<dt>sort</dt><dd>sorting</dd>
<dt>strconv</dt><dd>string &lt;-&gt; basic data type</dd>
<dt>os</dt><dd>platform-independent interface</dd>
<dt>sync</dt><dd>synchronization primitives such as mutual exclusion locks</dd>
<dt>flag</dt><dd>argparses or getopt</dd>
<dt>encoding/json</dt><dd>RFC4627</dd>
<dt>html/template</dt><dd>generate HTML</dd>
<dt>net/http</dt><dd>HTTP server/client</dd>
<dt>unsafe</dt><dd>??</dd>
<dt>reflect</dt><dd>run-time reflection</dd>
<dt>os/exec</dt><dd>os.system in python</dd>
</dl>
</div>
</div>

<div id="outline-container-org8e38379" class="outline-4">
<h4 id="org8e38379">其它</h4>
<div class="outline-text-4" id="text-org8e38379">
<ul class="org-ul">
<li>在 <code>$GOROOT/src/pkg</code> 目录下查看</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-org59e6a12" class="outline-2">
<h2 id="org59e6a12">Beyond the basics</h2>
<div class="outline-text-2" id="text-org59e6a12">
</div><div id="outline-container-org074838d" class="outline-3">
<h3 id="org074838d">Pointer</h3>
<div class="outline-text-3" id="text-org074838d">
</div><div id="outline-container-orgf4e8935" class="outline-4">
<h4 id="orgf4e8935">概念</h4>
<div class="outline-text-4" id="text-orgf4e8935">
<ul class="org-ul">
<li>Go has pointers.</li>
<li>There is however no pointer arithmetic</li>
<li>Go pointers act more like references than pointers in C</li>
</ul>
</div>
</div>

<div id="outline-container-org5110d4c" class="outline-4">
<h4 id="org5110d4c">语法</h4>
<div class="outline-text-4" id="text-org5110d4c">
<ul class="org-ul">
<li>在类型前前缀 '*'</li>
<li>默认指向 <code>nil</code></li>
<li>使用 '&amp;' 来取地址，并给指针赋值</li>
<li>使用 '*' 来反引用（取指向数据）</li>
</ul>
</div>
</div>

<div id="outline-container-org4fd13af" class="outline-4">
<h4 id="org4fd13af">例子</h4>
<div class="outline-text-4" id="text-org4fd13af">
<div class="org-src-container">
<pre class="src src-go">var p *int
fmt.Printf( "%v %T\n", p, p )

var i int
p = &amp;i
fmt.Printf( "%v %v %T\n", p, *p, p )
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org8fc8830" class="outline-3">
<h3 id="org8fc8830">Allocation</h3>
<div class="outline-text-3" id="text-org8fc8830">
</div><div id="outline-container-org6a6b8ab" class="outline-4">
<h4 id="org6a6b8ab">概念</h4>
<div class="outline-text-4" id="text-org6a6b8ab">
<ul class="org-ul">
<li>go 有自动内存管理，无须手动释放</li>
<li>申请有两个原语: <code>new</code> 和 <code>make</code></li>
<li><b>new</b> alloctes; <b>make</b> initializes</li>
</ul>
</div>
</div>


<div id="outline-container-orgcacb774" class="outline-4">
<h4 id="orgcacb774">new</h4>
<div class="outline-text-4" id="text-orgcacb774">
<p>
<code>new(T)</code> 为类型 T 申请一个空的空间，返回地址( *T )
</p>
</div>
</div>


<div id="outline-container-orgc00c542" class="outline-4">
<h4 id="orgc00c542">make</h4>
<div class="outline-text-4" id="text-orgc00c542">
<ul class="org-ul">
<li><code>make(T, args)</code> 用于创建 slices, map, 或 channels</li>
<li>返回是 T 本身，而非地址</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcb94dcc" class="outline-3">
<h3 id="orgcb94dcc">Composite literals</h3>
<div class="outline-text-3" id="text-orgcb94dcc">
<p>
Composite literal is an expression that creates a new instance each time it is evaluated.
</p>
</div>

<div id="outline-container-orgc75ec73" class="outline-4">
<h4 id="orgc75ec73"><span class="todo TODO">TODO</span> 例子</h4>
<div class="outline-text-4" id="text-orgc75ec73">
<div class="org-src-container">
<pre class="src src-go">func NewFile( fd int, name string )*File {
  if fd &lt; 0 {
    return nil
  }

  f := File{fd, name, nil, 0}
  return &amp;f
}
</pre>
</div>

<p>
注意返回一个局部变量 f 在 golang 中是允许的，go 会自动提升变量存活时长
</p>
</div>
</div>


<div id="outline-container-org07db704" class="outline-4">
<h4 id="org07db704">说明</h4>
<div class="outline-text-4" id="text-org07db704">
<ul class="org-ul">
<li>laid out in order and must all be present： <code>File{fd,name,nil,0}</code></li>
<li>也可以加 label，乱序和选填： <code>File{fd:fd, name;name]</code></li>
<li>甚至可以不填: <code>File{}</code></li>
<li>返回是一个实例, 可以解引用： <code>&amp;File{}</code></li>
<li>字符串数组，忽略 field: <code>[...]string{Enone: "no error", Einval: "invalid argument"}</code></li>
</ul>
</div>
</div>
</div>
</div>





<div id="outline-container-org21cecb8" class="outline-2">
<h2 id="org21cecb8">自定义类型</h2>
<div class="outline-text-2" id="text-org21cecb8">
</div><div id="outline-container-org10f8034" class="outline-3">
<h3 id="org10f8034">基本语法</h3>
<div class="outline-text-3" id="text-org10f8034">
<ul class="org-ul">
<li>基本语法是 <code>type foo int</code> ，创建一个类型 foo，定义是 int</li>
<li>与 C 中的 typedef 相似，顺序相反</li>
</ul>
</div>
</div>

<div id="outline-container-orge24dea7" class="outline-3">
<h3 id="orge24dea7">例子</h3>
<div class="outline-text-3" id="text-orge24dea7">
<div class="org-src-container">
<pre class="src src-go">type Point struct{
	x float64
	y float64
}

func main() {
	p := &amp;Point{x:10}
	fmt.Printf( "%v %v %T\n", p, *p, p )
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5863624" class="outline-3">
<h3 id="org5863624">struct</h3>
<div class="outline-text-3" id="text-org5863624">
<ul class="org-ul">
<li>struct 可以没有 field</li>
<li>可以有多个 field</li>
<li>可以只有类型，称为 anonymous field</li>
<li>field 以大写开关的表示全局可见，否则只能在本包内使用</li>
</ul>
</div>
</div>
</div>






<div id="outline-container-org0ac9ec6" class="outline-2">
<h2 id="org0ac9ec6">Methods</h2>
<div class="outline-text-2" id="text-org0ac9ec6">
</div><div id="outline-container-orgc544e57" class="outline-3">
<h3 id="orgc544e57">基础</h3>
<div class="outline-text-3" id="text-orgc544e57">
<ul class="org-ul">
<li>目标是为类型提供方法调用</li>
<li>但不是以 Java/C++/Python OOP 形式</li>
<li>更像是 lisp/scheme 中的 GOOP 形式，或 Clojure 中的 Protocol</li>
<li>要满足 interface，必须要使用 method</li>
<li>其它情况 method 和 function 都可使用</li>
<li>对于指针的方法，可以用 <code>x.m()</code> 来简写 <code>(&amp;x).m</code></li>
</ul>
</div>
</div>

<div id="outline-container-org220cdbe" class="outline-3">
<h3 id="org220cdbe"><span class="todo TODO">TODO</span> 继承关系</h3>
</div>
</div>



<div id="outline-container-org2412c37" class="outline-2">
<h2 id="org2412c37">类型转换</h2>
<div class="outline-text-2" id="text-org2412c37">
<ul class="org-ul">
<li>通过操作符(operator)来转换（与函数形式一样，本质上有所不同）</li>
<li>字符串可以转换为 <code>byte[]</code> 或 <code>rune[]</code> ，反之亦然</li>
<li>自定义类型与其别名之间可以相互转换</li>
</ul>
</div>
</div>

<div id="outline-container-org429073f" class="outline-2">
<h2 id="org429073f">Interface</h2>
<div class="outline-text-2" id="text-org429073f">
</div><div id="outline-container-org88bfd05" class="outline-3">
<h3 id="org88bfd05">意义</h3>
<div class="outline-text-3" id="text-org88bfd05">
<ul class="org-ul">
<li>用于函数定义与类型绑定 GOOPS</li>
<li>定义一个 interface 类型，表示方法的集合: 鸭子类型</li>
<li>Go 可以使用 interface 类型作为参数类型，称为 interface value</li>
</ul>
</div>
</div>

<div id="outline-container-org0f3cbf3" class="outline-3">
<h3 id="org0f3cbf3">示例</h3>
<div class="outline-text-3" id="text-org0f3cbf3">
<div class="org-src-container">
<pre class="src src-go">type I interface {
  Get() int
  Put(int)
}

func f( p I ) {
  fmt.Println( p.Get() )
  p.Put(1)
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3323aa0" class="outline-3">
<h3 id="org3323aa0">拆分多态</h3>
<div class="outline-text-3" id="text-org3323aa0">
<div class="org-src-container">
<pre class="src src-go">func f(p I) {
  switch t := p.(type) {
    case *S:
    case *R:
    default:
}
</pre>
</div>

<p>
其中 <code>(.type)</code> 语法只在 switch 中有效，也可以写成
</p>

<div class="org-src-container">
<pre class="src src-go">if t, ok := something.(I); ok {
   // 检查 something 是否实现了接口 I
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdfea571" class="outline-3">
<h3 id="orgdfea571">Empty Interface</h3>
<div class="outline-text-3" id="text-orgdfea571">
<ul class="org-ul">
<li>每个类型都默认实现了 <code>interface{}</code></li>
<li>用于创建通用函数</li>
<li>通用函数，动态的获取其中的函数</li>
</ul>
</div>

<div id="outline-container-org5a16082" class="outline-4">
<h4 id="org5a16082">示例</h4>
<div class="outline-text-4" id="text-org5a16082">
<div class="org-src-container">
<pre class="src src-go">func g( something interface{} ) int {
    return something.(I).Get()
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb9a6ce8" class="outline-3">
<h3 id="orgb9a6ce8">Methods</h3>
<div class="outline-text-3" id="text-orgb9a6ce8">
<ul class="org-ul">
<li>Methods are functions that have a receiver</li>
<li>可以对任何类型定义方法，包括内置类型（除了 int 之外）</li>
</ul>
</div>
</div>

<div id="outline-container-orgc4f981b" class="outline-3">
<h3 id="orgc4f981b"><span class="todo TODO">TODO</span> Methods on interface faces</h3>
<div class="outline-text-3" id="text-orgc4f981b">
<ul class="org-ul">
<li>An interface defines a set of methods : 定义</li>
<li>A method contains the actual code ： 实现</li>
<li>receiver can not be an interface type?</li>
</ul>
</div>

<div id="outline-container-org6cafbba" class="outline-4">
<h4 id="org6cafbba">receiver type</h4>
<div class="outline-text-4" id="text-org6cafbba">
<ul class="org-ul">
<li>有两种形式 <code>T</code> 或者 <code>*T</code></li>
<li>T is called the base type</li>
<li>T must not be a pointer or interface type</li>
<li>T must be declared in the same package as the method</li>
<li>不应该对 interface value 作指针</li>
</ul>
</div>
</div>

<div id="outline-container-org90b8a54" class="outline-4">
<h4 id="org90b8a54">Interface names</h4>
<div class="outline-text-4" id="text-org90b8a54">
<ul class="org-ul">
<li>如果只有一个方法，以 <code>-er</code> 为后缀，如 Reader, Writer, Formatter</li>
<li>方法名避免与标准函数重名</li>
</ul>
</div>
</div>
</div>







<div id="outline-container-orgf5cc39c" class="outline-3">
<h3 id="orgf5cc39c"><span class="todo TODO">TODO</span> tag</h3>
</div>
<div id="outline-container-org23f9cb8" class="outline-3">
<h3 id="org23f9cb8">Introspection and reflection</h3>
<div class="outline-text-3" id="text-org23f9cb8">
</div><div id="outline-container-org87d9f1d" class="outline-4">
<h4 id="org87d9f1d">示例</h4>
<div class="outline-text-4" id="text-org87d9f1d">
<div class="org-src-container">
<pre class="src src-go">type Person struct {
    name string "namestr"
    age int
}


func ShowTag( i interface[] ) {
    switch t:= reflect.TypeOf(i); t.Kind() {
    case reflect.Ptr:
	tag := t.Elem().Field(0).Tag
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org9cdc669" class="outline-4">
<h4 id="org9cdc669"><span class="todo TODO">TODO</span> 说明</h4>
<div class="outline-text-4" id="text-org9cdc669">
<ul class="org-ul">
<li>要通过内存中的变量，得到关于结构体等定义信息</li>
<li>用于区分 type 和 value</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org8c532ff" class="outline-2">
<h2 id="org8c532ff">Concurrency</h2>
<div class="outline-text-2" id="text-org8c532ff">
</div><div id="outline-container-org537ee9e" class="outline-3">
<h3 id="org537ee9e">概述</h3>
<div class="outline-text-3" id="text-org537ee9e">
<ul class="org-ul">
<li>Parallelism is about performance.</li>
<li>Concurrency is about program design</li>
<li>核心是 channel 和 goroutine</li>
</ul>
</div>
</div>

<div id="outline-container-orgf7559ad" class="outline-3">
<h3 id="orgf7559ad">goroutine</h3>
<div class="outline-text-3" id="text-orgf7559ad">
<blockquote>
<p>
It is a function executing in parallel with other goroutines in the same address sapce. 
It is lightweight, cosing little more than the allocation of stack space.
And the stacks start small, so they are cheap, and grow by 
allocating( and freeing) heap storage as required.
</p>
</blockquote>
</div>

<div id="outline-container-orgff97c54" class="outline-4">
<h4 id="orgff97c54">说明</h4>
<div class="outline-text-4" id="text-orgff97c54">
<ul class="org-ul">
<li>普通函数，以关键字 <code>go</code> 开头</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcc1e994" class="outline-3">
<h3 id="orgcc1e994">channel</h3>
<div class="outline-text-3" id="text-orgcc1e994">
</div><div id="outline-container-orge0e8c57" class="outline-4">
<h4 id="orge0e8c57">说明</h4>
<div class="outline-text-4" id="text-orge0e8c57">
<ul class="org-ul">
<li>类似于双向的 pipe</li>
<li>只能以 channel 定义的数据类型进行交流</li>
<li>通过 <code>make(chan int)</code> 来生成</li>
<li>可以交换 interface, <code>make(chan interface{})</code> !!!</li>
<li>通过 <code>&lt;-</code> 来发送信息和接收</li>
<li>使用函数 <code>select</code> 来监听接收信息</li>
</ul>
</div>
</div>

<div id="outline-container-org678cc87" class="outline-4">
<h4 id="org678cc87">示例</h4>
<div class="outline-text-4" id="text-org678cc87">
<div class="org-src-container">
<pre class="src src-go">func ready( w string, sec int ) {
    time.Sleep( time.Duration(sec) * time.Second )
    fmt.Println( w, "is ready" )
    c &lt;- w
}

func main() {
    c = make(chan string)
    go ready( "2sec", 2 )
    go ready( "1sec", 1 )
    fmt.Println( "I'm waiting" )
    fmt.Println( &lt;-c )
    fmt.Println( &lt;-c )
    fmt.Println( "over" )
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6b45b41" class="outline-4">
<h4 id="org6b45b41">缓存</h4>
<div class="outline-text-4" id="text-org6b45b41">
<ul class="org-ul">
<li><code>make(chan bool)</code> 创建的是 unbuffered channel for bools</li>
<li>unbuffered channel 用于同步多个 goroutine</li>
<li><code>make(chan bool, 4)</code> 创建带缓存的 channel</li>
</ul>
</div>
</div>

<div id="outline-container-org0b5e7ec" class="outline-4">
<h4 id="org0b5e7ec">关闭</h4>
<div class="outline-text-4" id="text-org0b5e7ec">
<ul class="org-ul">
<li>channel 会被单向关闭</li>
<li>可以以 <code>x, ok = &lt;-ch</code> 来检查是否关闭（ok 为 false 表示关闭）</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgaf5e884" class="outline-3">
<h3 id="orgaf5e884">parallel</h3>
<div class="outline-text-3" id="text-orgaf5e884">
<ul class="org-ul">
<li>goroutine concurrently，而非并行</li>
<li>使用 <code>runtime.GOMAXPROCS(n)</code> 来设置最大并行度</li>
<li>也可以设置 <code>GOMAXPROCS</code> 环境变量</li>
<li>默认并行度是 CPU 的核数</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org7420c0b" class="outline-2">
<h2 id="org7420c0b">Communication</h2>
<div class="outline-text-2" id="text-org7420c0b">
</div><div id="outline-container-orgf58d435" class="outline-3">
<h3 id="orgf58d435">清单</h3>
<div class="outline-text-3" id="text-orgf58d435">
<ul class="org-ul">
<li>与外界交互，如 file, directories, networking, system(shell)</li>
<li>I/O 接口 <code>io.Reader</code> 和 <code>io.Writer</code></li>
<li><code>os.Open</code>, <code>os.Close</code>, <code>os.Stdout</code>, <code>os.Stat</code>, <code>os.Mkdir</code></li>
<li><code>File.Read</code>, <code>File.Write</code></li>
<li>bufio( Buffered I/O ), 如 NewReader, NewWriter, Read, Write, Flush, ReadString, ReadLine</li>
<li>日志 <code>log</code>, 如 Fatalf</li>
</ul>
</div>
</div>

<div id="outline-container-orged3ca10" class="outline-3">
<h3 id="orged3ca10">命令行参数</h3>
<div class="outline-text-3" id="text-orged3ca10">
<ul class="org-ul">
<li>os.Args （类似于 sys.args in python）</li>
<li>flag 包来解析参数 （类似于 argparsers, optparser in python， getopt）</li>
<li><code>flag.{Bool,String}</code> , <code>flag.Usage</code>, <code>flag.Parse</code>, <code>flag.PrintDefaults</code></li>
</ul>
</div>

<div id="outline-container-org7a07479" class="outline-4">
<h4 id="org7a07479"><span class="todo TODO">TODO</span> 效率？？</h4>
</div>
</div>

<div id="outline-container-org2b7f89f" class="outline-3">
<h3 id="org2b7f89f">系统命令</h3>
<div class="outline-text-3" id="text-org2b7f89f">
<ul class="org-ul">
<li><code>os/exec</code> 提供了调用外部命令的函数</li>
<li><code>exec.Command</code></li>
<li><code>cmd.Run</code>, <code>cmd.Output</code></li>
</ul>
</div>
</div>

<div id="outline-container-org8a1d611" class="outline-3">
<h3 id="org8a1d611">Networking</h3>
<div class="outline-text-3" id="text-org8a1d611">
</div><div id="outline-container-org7662c08" class="outline-4">
<h4 id="org7662c08">低级接口</h4>
<div class="outline-text-4" id="text-org7662c08">
<ul class="org-ul">
<li>在包 <code>net</code> 中定义</li>
<li><code>net.DIal</code> 返回一个 <code>Conn</code> 接口类型，可以用来收发信息</li>
<li><code>Conn</code> 实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 类型</li>
</ul>
</div>
</div>

<div id="outline-container-org771a3d4" class="outline-4">
<h4 id="org771a3d4">http 接口</h4>
<div class="outline-text-4" id="text-org771a3d4">
<ul class="org-ul">
<li><code>http</code> 包， Get 方法，对返回结果的 Body 进行操作</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org26e6cc8" class="outline-2">
<h2 id="org26e6cc8">杂项</h2>
<div class="outline-text-2" id="text-org26e6cc8">
</div><div id="outline-container-orgc687a31" class="outline-3">
<h3 id="orgc687a31"><span class="todo TODO">TODO</span> iota</h3>
<div class="outline-text-3" id="text-orgc687a31">
<div class="org-src-container">
<pre class="src src-go">const (
   _ = 1000 * iota
   ADD
   SUB
   MUL
   DIV
   MAXPOS = 11
)
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: 赵文彬</p>
<p class="date">Created: 2017-06-10 Sat 23:36</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
