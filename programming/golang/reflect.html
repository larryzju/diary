<!DOCTYPE html>
<html>
	<head>
		<title>reflect.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="laws-of-reflection">laws of reflection</h1>
<p>Note of <a href="https://blog.golang.org/laws-of-reflection">laws of reflection</a></p>
<h2 id="introduction">Introduction</h2>
<p>Program can examine its own structure with <code>reflect</code> through <strong>types</strong>. (Metaprogramming)</p>
<h2 id="type-interfaces">Type &amp; Interfaces</h2>
<p>Go is static type language.</p>
<p><code>type MyInt int</code> define new type &quot;MyInt&quot; which is different from int even they have the same underlying type.</p>
<p><strong>interface</strong> type is a special type, which can hold concrete value that satisfied the interface's method prototypes.</p>
<p><code>interface{}</code> can store any type of value. But it's still static type language.</p>
<h2 id="the-representation-of-an-interface">The representation of an interface</h2>
<p>Interface keeps tuple informations: <code>(value, concrete type)</code></p>
<p>With interface variable, we can only call the methods in interface prototype. Such as <code>r.read()</code>.</p>
<p>The concrete value can define much more methods, we need to declare (convert) it to another interface to use these methods normally use <strong>type assertion syntax</strong></p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">w = r.(io.Writer)</code></pre></div>
<p>Empty interface can be assigned any type of value without type asserting.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">var</span> empty <span class="kw">interface</span>{}
empty = w</code></pre></div>
<h2 id="law1.-reflection-goes-from-interface-value-to-reflection-object">Law1. Reflection goes from interface value to reflection object</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> (
        <span class="st">&quot;fmt&quot;</span>
        <span class="st">&quot;reflect&quot;</span>
)

<span class="kw">func</span> main() {
        <span class="kw">var</span> x <span class="dt">float64</span> = <span class="dv">3</span><span class="fl">.6</span>
        fmt.Println(<span class="st">&quot;type:&quot;</span>, reflect.TypeOf(x))
        fmt.Println(<span class="st">&quot;value:&quot;</span>, reflect.ValueOf(x).String())


        v := reflect.ValueOf(x)
        fmt.Println(<span class="st">&quot;type:&quot;</span>, v.Type())
        fmt.Println(<span class="st">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)
        fmt.Println(<span class="st">&quot;value:&quot;</span>, v.Float())
}</code></pre></div>
<ul class="incremental">
<li><p>Use <code>reflect.TypeOf</code> gets value's type. The <code>x</code> is convert to empty interface first and <code>reflect.TypeOf</code> unpacks that empty interface to recover the type information.</p></li>
<li><p>Use <code>reflect.ValueOf</code> gets interface's value</p></li>
<li><code>Value</code> has lots of methods to let use examine and manipulate them
<ul class="incremental">
<li><code>Type</code></li>
<li><code>Kind</code> describes the underlying type, not the static type</li>
<li><code>Int</code>, <code>Float</code> to grab values</li>
</ul></li>
</ul>
<h2 id="law2.-reflection-goes-from-reflection-object-to-interface-value">Law2. Reflection goes from reflection object to interface value</h2>
<p>Repack <code>(value, concrete type)</code> to <code>interface</code> which can be seen as a inverse of the `ValueOf` function.</p>
<p>The result is always of static type <code>interface{}</code></p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> (
        <span class="st">&quot;fmt&quot;</span>
        <span class="st">&quot;reflect&quot;</span>
)

<span class="kw">func</span> main() {
        <span class="kw">var</span> x <span class="dt">int32</span>
        x = <span class="dv">10240</span>

        v := reflect.ValueOf(x)
        fmt.Printf(<span class="st">&quot;%.2e&quot;</span>, <span class="dt">float64</span>(v.Interface().(<span class="dt">int32</span>)))
}</code></pre></div>
<h2 id="law3.-to-modifiy-a-reflection-object-the-value-must-be-settable">Law3. To modifiy a reflection object, the value must be settable</h2>
<p>Before set the value with reflect, call <code>CanSet</code> on the <code>Value</code></p>
<p>We can modify the reflect value only if its not the copy for the raw value. (Similar to pass parameters to function by value or by reference).</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> (
        <span class="st">&quot;fmt&quot;</span>
        <span class="st">&quot;reflect&quot;</span>
)

<span class="kw">func</span> main() {
        <span class="kw">var</span> x <span class="dt">int32</span> = <span class="dv">1024</span>
        v := reflect.ValueOf(&amp;x)
        fmt.Println(v.CanSet())
        t := v.Elem()
        fmt.Println(t.CanSet())
        t.SetInt(<span class="dv">2048</span>)
        fmt.Println(t)
        fmt.Println(x)
}</code></pre></div>
<h2 id="struct">Struct</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> (
        <span class="st">&quot;fmt&quot;</span>
        <span class="st">&quot;reflect&quot;</span>
)

<span class="kw">type</span> T <span class="kw">struct</span> {
        Foo <span class="dt">string</span>
        bar <span class="dt">string</span>
}

<span class="kw">func</span> main() {
        t := T{<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>}
        s := reflect.ValueOf(&amp;t).Elem()
        s.Field(<span class="dv">0</span>).SetString(<span class="st">&quot;Aloha&quot;</span>)
        <span class="co">// can not set unexport field</span>
        <span class="co">// s.Field(1).SetString(&quot;世界&quot;)</span>
        fmt.Println(t)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="co">// iterator all fields in struct</span>
typeOfT := s.Type()
<span class="kw">for</span> i := <span class="dv">0</span>; i &lt; s.NumField(); i++ {
        f := s.Field(i)
        fmt.Printf(<span class="st">&quot;%d: %s %s = %v</span><span class="ch">\n</span><span class="st">&quot;</span>, i,
                typeOfT.Field(i).Name, f.Type(), f.Interface())
}</code></pre></div>

			</div>
		</section>
	</body>
</html>
