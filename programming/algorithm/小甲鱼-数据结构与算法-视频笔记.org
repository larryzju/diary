#+TITLE: 小甲鱼-数据结构与算法-视频教程笔记
#+AUTHOR: Zhao WenBin

* Roadmap

- [0/1] 绪论
- [0/1] 谈谈算法
- [0/3] 时间和空间复杂度
- [8/17] 线性表
- [0/7] 栈与队列
- [0/70] 其它

* 线性表

线性表是一个有限的有序数列，每一个元素都有唯一有前驱和唯一的后继（除开头和结尾）

元素具有相同的数据类型。

** 抽象数据类型 ADT

相当于 class，指数学模型及定义在其上的一系列方法。抽象相对于具体，只指定其接口，而没有实现。

通过 ADT 提供的基本方法可以组合出更加复杂的操作

*** 为什么有类型

1. 适应不同的应用场景
2. 节省空间（有限精度，如 =int= 和 =long= ）

*** 类型分类

1. 原子类型
2. 组合类型

** 常用操作

- init
- clean
- isEmpty
- get(i)
- locate(v)
- insert(v)
- delete(v)
- length

** 例子

- =union(L1,L2)=

** 实现方式

有两种存储结构来实现线性表
1. 顺序表，使用连贯的内存地址来存放数据，需要记录数据的长度和空间的容量
2. 链式表，不需要连续地址存放数据，用一个指针域指向下一个后继元素

*** TODO 顺序表

实现参见代码 [?]()

优点:
1. 空间紧凑（因为隐式地使用了地址作为下标）
2. 快速存取

缺点：
1. 容量固定，扩容可能造成“碎片”化
2. 插入、删除开销大

*** 链式表

包括两个基本域：数据域和指针域

习惯上留置一个头结点作为列表开头，可以在其数据域中存储列表的长度，这样有助于统一列表的访问接口。通过头结点可以访问整个链表，尾指针指向空（null）

单链表的建立方式
1. 头插法，新建节点指向头节点，将链表指向新建节点，生成链表元素顺序与插入顺序相反
2. 尾插法，维护一个临时的指向链表最后一个元素的 node，每次向 node.next 加入新元素，并将 node 后移

对单链表循环删除整表操作时，用一个临时变量来删除

#+BEGIN_SRC go
for p != nil {
    q := p.next
    free(p) // go 不需要显式的释放空间， p.next = nil
    p = q
}
#+END_SRC

单链实现代码如下所示（go 语言）

#+INCLUDE: "/Users/larry/go/src/github.com/larryzju/fishc-go/linkedlist.go" src go

*** 单链表与顺序存储比较

| 比较项   | 单链表 | 顺序表 |
|----------+--------+--------|
| 查找     | O(n)   | O(1)   |
| 插入     | O(1)   | O(n)   |
| 空间性能 |        | 预分配空间，造成空间浪费或溢出 |

- 频繁查找，考虑用顺序存储
- 频繁修改，考虑用链表存储
- 元素个数不确定，或变化大，考虑用链表存储
*** 静态链表

C 语言的指针提供了极大的灵活性（面向对象使用对象引用机制间接的实现了指针的某些功能），是实现链表的语言基础。

在早期（如 basic, fortran）中，以数组代替指针来描述单链表。这种方式称为游标实现法

- 每个元素由游标和数据组成
- 整体上 N 个元素构成，
- 第 N-1 个元素的游标指向第一个元素
- 第 0 个元素的游标指向最后一个元素
- 第一个和最后一个元素 data 不存放数据
- 其它元素的游标指向下一个元素的下标

代码实现如下所示
#+INCLUDES: "/Users/larry/go/src/github.com/larryzju/fishc-go/staticlist.go" src go



