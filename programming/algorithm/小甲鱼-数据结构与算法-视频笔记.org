#+TITLE: 小甲鱼-数据结构与算法-视频教程笔记
#+AUTHOR: Zhao WenBin

* Roadmap

- [1/1] 绪论
- [1/1] 谈谈算法
- [0/3] 时间和空间复杂度
- [11/17] 线性表
- [0/8] 栈与队列
- [0/4] 递归与分治思想
- [0/5] 字符串
- [0/3] 树
- [0/10+] 图


* 绪论

** 为什么数据结构与算法课程不好学？

1. 拼脑力
2. 教授方式枯燥（老师因为重复讲解而缺少吸引力）

** 什么是数据结构

- 研究非数值计算和程序设计问题的操作对象及它们之间的关系和操作
- 程序等于数据结构 + 算法

*** 逻辑结构和物理结构

- 逻辑结构：指对象间的相互关系
- 物理结构：指数据的逻辑结构在计算机中的存储形式

*** 四大逻辑结构

1. 集合结构
2. 线性结构（一对一）
3. 树形结构（一对多）
4. 图形结构（多对多）

*** 物理存储结构

- 与存储器有关，如内存、硬盘
- 按访问方式分为两种
  1. 顺序存储结构（地址连续）
  2. 链式存储结构（相对前缀和后继）

* 谈谈算法

数据结构与算法有密切的关系

** 什么是算法

** 算法的特性

- 输入
- 输出
- 有穷性
- 确定性
- 可行性

** 算法的设计要求

- 正确性（没有语法错误，对合法输入，对非法输入，对于边界条件输入）
- 可读性
- 健壮性
- 时间效率高和存储量低

* [0/3] 时间和空间复杂度
* [11/17] 线性表

线性表是一个有限的有序数列，每一个元素都有唯一有前驱和唯一的后继（除开头和结尾）

元素具有相同的数据类型。

** 抽象数据类型 ADT

相当于 class，指数学模型及定义在其上的一系列方法。抽象相对于具体，只指定其接口，而没有实现。

通过 ADT 提供的基本方法可以组合出更加复杂的操作

*** 为什么有类型

1. 适应不同的应用场景
2. 节省空间（有限精度，如 =int= 和 =long= ）

*** 类型分类

1. 原子类型
2. 组合类型

** 常用操作

- init
- clean
- isEmpty
- get(i)
- locate(v)
- insert(v)
- delete(v)
- length

** 例子

- =union(L1,L2)=

** 实现方式

有两种存储结构来实现线性表
1. 顺序表，使用连贯的内存地址来存放数据，需要记录数据的长度和空间的容量
2. 链式表，不需要连续地址存放数据，用一个指针域指向下一个后继元素

*** TODO 顺序表

实现参见代码 [?]()

优点:
1. 空间紧凑（因为隐式地使用了地址作为下标）
2. 快速存取

缺点：
1. 容量固定，扩容可能造成“碎片”化
2. 插入、删除开销大

*** 链式表

包括两个基本域：数据域和指针域

习惯上留置一个头结点作为列表开头，可以在其数据域中存储列表的长度，这样有助于统一列表的访问接口。通过头结点可以访问整个链表，尾指针指向空（null）

单链表的建立方式
1. 头插法，新建节点指向头节点，将链表指向新建节点，生成链表元素顺序与插入顺序相反
2. 尾插法，维护一个临时的指向链表最后一个元素的 node，每次向 node.next 加入新元素，并将 node 后移

对单链表循环删除整表操作时，用一个临时变量来删除

#+BEGIN_SRC go
for p != nil {
    q := p.next
    free(p) // go 不需要显式的释放空间， p.next = nil
    p = q
}
#+END_SRC

单链实现代码如下所示（go 语言）

#+INCLUDE: "/Users/larry/go/src/github.com/larryzju/fishc-go/linkedlist.go" src go

*** 单链表与顺序存储比较

| 比较项   | 单链表 | 顺序表 |
|----------+--------+--------|
| 查找     | O(n)   | O(1)   |
| 插入     | O(1)   | O(n)   |
| 空间性能 |        | 预分配空间，造成空间浪费或溢出 |

- 频繁查找，考虑用顺序存储
- 频繁修改，考虑用链表存储
- 元素个数不确定，或变化大，考虑用链表存储

** 静态链表

C 语言的指针提供了极大的灵活性（面向对象使用对象引用机制间接的实现了指针的某些功能），指针是实现链表的语言基础。

在早期（如 basic, fortran）语言中，以数组下标代替指针来描述单链表。这种方式称为游标实现法，有以下特征
- 每个元素由游标和数据组成
- 整体上 N 个元素构成，
- 第 N-1 个元素的游标指向第一个元素
- 第 0 个元素的游标指向最后一个元素
- 第一个和最后一个元素 data 不存放数据
- 其它元素的游标指向下一个元素的下标

代码实现如下所示

#+INCLUDE: "/Users/larry/go/src/github.com/larryzju/fishc-go/staticlist.go" src go

需要维护两个链表：
1. 实际链表
2. 备用链表

列表的操作：
- 进行插入时，从备用链表中取出一个可用空间，插入到实际链表中
- 进行删除时，删除元素放回到备用链表中

静态链表的优缺点
- 优点
  + 插入和删除，只需要修改游标，不需要移动元素
- 缺点
  + 没有解决连续存储分配带来的表长确定的问题
  + 失去了顺序存储结构随机存取的优势

** 循环链表

- 链表的尾部指向表头
- 因为单链表必须从头出发，否则无法访问到全部结点
- 与单链表的区别在于如何判断链表为空
- 空表 ~head->next = head~

*** 示例代码

初始化
插入（位置，值）
删除位置（2）
查找元素的位置
查看列表
退出



** 例题

- 快速找到求知长度单链表的中间节点：快慢指针方法
* [0/8] 栈与队列
* [0/4] 递归与分治思想
* [0/5] 字符串
* [0/3] 树
* 图

** 概念

*** 基本概念

图（Graph）由有穷非空的点（Vertex）和边（Edge）构成。

与线性表和树相比：
- 线性表表示链式关系，一对一
- 树表示层次关系，一对多
- 图表示网关系，多对多
- 图的顶点集合不能为空，而线性表和树可以为空

*** 边

按是否有方向，分为有向边和无向边
- =(Vi,Vj)= 无向边
- =<Vi,Vj>= 有向边
- 有向边也称为弧（Arc），起点称为弧头，终点称为弧尾

*** 图的表示

用点和边来表示图，如
#+BEGIN_VERSE
G1 = {V1, E1}
E1 = {(A,B), (B,C), (C,D), (A,C)
V1 = {A,B,C,D}
#+END_VERSE

同理，可以表示有向图

*** 图的分类

- 简单图，不含重复的边，且没有指向点本身的边
- 无向完全图，点两两之间相连，共有 n(n-1)/2 条边
- 有向完全图，共有 n(n-1) 条边
- 稀疏图和稠密图，约定边（弧）小于 $n\log(n)$ 为稀疏图

*** 网（Network）

- 边（弧）上附有关联数值，该数值称为权。常用于表示距离或价值
- 带权的图称为网（Network）

*** 子图

G2 为 G1 的子图，当 V2 包含于 V1, 且 E2 包含于 E1



