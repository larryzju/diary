<!DOCTYPE html>
<html>
	<head>
		<title>README.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="set">Set</h1>
<p>本质上 Set 与 Dict 是一回事，可以把 Dict 看成是 <code>Set&lt;Pair&lt;key,value&gt;&gt;</code> 特殊类型。Set 只用到元素中的 Key 属性，元素可以包括有其它信息。</p>
<p>除了常见的插入、删除、查找外，还需要支持：最大、最小、前序、后序查找。如下所示</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">package</span> set</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">type</span> Key <span class="dt">int64</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">type</span> Element <span class="kw">interface</span> {</span>
<span id="cb1-6"><a href="#cb1-6"></a>	Key() Key</span>
<span id="cb1-7"><a href="#cb1-7"></a>}</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">type</span> Set <span class="kw">interface</span> {</span>
<span id="cb1-10"><a href="#cb1-10"></a>	Search(k Key) Element</span>
<span id="cb1-11"><a href="#cb1-11"></a>	Insert(x Element)</span>
<span id="cb1-12"><a href="#cb1-12"></a>	Delete(x Element) <span class="dt">bool</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>	Minimum() Element</span>
<span id="cb1-14"><a href="#cb1-14"></a>	Maximum() Element</span>
<span id="cb1-15"><a href="#cb1-15"></a>	Successor(x Element) Element</span>
<span id="cb1-16"><a href="#cb1-16"></a>	Predecessor(x Element) Element</span>
<span id="cb1-17"><a href="#cb1-17"></a>}</span></code></pre></div>
<h2 id="elementary-data-structure">Elementary Data Structure</h2>
<h3 id="stack">Stack</h3>
<p>Stack 与 Queue 两者的区别在于元素的取出顺序：</p>
<ul class="incremental">
<li>stack 为 LIFO</li>
<li>queue 为 FIFO</li>
</ul>
<p>Stack 的基本操作为 Push 和 Pop，如下所示</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">package</span> stack</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">import</span> (</span>
<span id="cb2-4"><a href="#cb2-4"></a>	<span class="st">&quot;errors&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>)</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">var</span> (</span>
<span id="cb2-8"><a href="#cb2-8"></a>	UnderflowError = errors.New(<span class="st">&quot;underflow&quot;</span>)</span>
<span id="cb2-9"><a href="#cb2-9"></a>	OverflowError  = errors.New(<span class="st">&quot;overflow&quot;</span>)</span>
<span id="cb2-10"><a href="#cb2-10"></a>)</span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">type</span> Element <span class="kw">interface</span> {</span>
<span id="cb2-13"><a href="#cb2-13"></a>}</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="kw">type</span> Stack <span class="kw">interface</span> {</span>
<span id="cb2-16"><a href="#cb2-16"></a>	Push(e Element) <span class="dt">error</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>	Pop() (Element, <span class="dt">error</span>)</span>
<span id="cb2-18"><a href="#cb2-18"></a>	Empty() <span class="dt">bool</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>}</span></code></pre></div>
<ol class="incremental">
<li><p>数组实现</p>
<p>可以用数组来实现</p>
<ul class="incremental">
<li>维护一个指针 top，指向栈顶</li>
<li>top 为 0 时，表示 Stack 为空</li>
<li>对空栈调用 Pop 时，产生 underflow 错误</li>
<li>对满栈调用 Push 时，产生 overflow 错误</li>
</ul>
<p>Go 语言中，Slice 相当于一个可以动态扩容的 Array。为了与书上统一，我们使用固定长度的 Slice 来实现 Stack</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">package</span> stack</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">type</span> ArrayStack <span class="kw">struct</span> {</span>
<span id="cb3-4"><a href="#cb3-4"></a>	array []Element</span>
<span id="cb3-5"><a href="#cb3-5"></a>	top   <span class="dt">int</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>	<span class="bu">cap</span>   <span class="dt">int</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>}</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">func</span> NewArrayStack(<span class="bu">cap</span> <span class="dt">int</span>) *ArrayStack {</span>
<span id="cb3-10"><a href="#cb3-10"></a>	<span class="kw">return</span> &amp;ArrayStack{</span>
<span id="cb3-11"><a href="#cb3-11"></a>		<span class="bu">make</span>([]Element, <span class="bu">cap</span>),</span>
<span id="cb3-12"><a href="#cb3-12"></a>		<span class="dv">0</span>,</span>
<span id="cb3-13"><a href="#cb3-13"></a>		<span class="bu">cap</span>,</span>
<span id="cb3-14"><a href="#cb3-14"></a>	}</span>
<span id="cb3-15"><a href="#cb3-15"></a>}</span>
<span id="cb3-16"><a href="#cb3-16"></a></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="kw">func</span> (s *ArrayStack) Push(e Element) <span class="dt">error</span> {</span>
<span id="cb3-18"><a href="#cb3-18"></a>	<span class="kw">if</span> s.top &gt;= s.<span class="bu">cap</span> {</span>
<span id="cb3-19"><a href="#cb3-19"></a>		<span class="kw">return</span> OverflowError</span>
<span id="cb3-20"><a href="#cb3-20"></a>	}</span>
<span id="cb3-21"><a href="#cb3-21"></a>	s.array[s.top] = e</span>
<span id="cb3-22"><a href="#cb3-22"></a>	s.top += <span class="dv">1</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>	<span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>}</span>
<span id="cb3-25"><a href="#cb3-25"></a></span>
<span id="cb3-26"><a href="#cb3-26"></a><span class="kw">func</span> (s *ArrayStack) Pop() (Element, <span class="dt">error</span>) {</span>
<span id="cb3-27"><a href="#cb3-27"></a>	<span class="kw">if</span> s.top == <span class="dv">0</span> {</span>
<span id="cb3-28"><a href="#cb3-28"></a>		<span class="kw">return</span> <span class="ot">nil</span>, UnderflowError</span>
<span id="cb3-29"><a href="#cb3-29"></a>	}</span>
<span id="cb3-30"><a href="#cb3-30"></a></span>
<span id="cb3-31"><a href="#cb3-31"></a>	ele := s.array[s.top<span class="dv">-1</span>]</span>
<span id="cb3-32"><a href="#cb3-32"></a>	s.top -= <span class="dv">1</span></span>
<span id="cb3-33"><a href="#cb3-33"></a>	<span class="kw">return</span> ele, <span class="ot">nil</span></span>
<span id="cb3-34"><a href="#cb3-34"></a>}</span>
<span id="cb3-35"><a href="#cb3-35"></a></span>
<span id="cb3-36"><a href="#cb3-36"></a><span class="kw">func</span> (s *ArrayStack) Empty() <span class="dt">bool</span> {</span>
<span id="cb3-37"><a href="#cb3-37"></a>	<span class="kw">return</span> s.top == <span class="dv">0</span></span>
<span id="cb3-38"><a href="#cb3-38"></a>}</span></code></pre></div></li>
<li><p><span class="todo TODO">TODO</span> 双栈</p>
<p>Exercises 10.1-2. 通过一个数组 <code>A[1..n]</code> 来表示两个栈，只有当两者都满后才无法继续压栈</p>
<p>待实现</p></li>
<li><p><span class="todo TODO">TODO</span> 双队列实现</p>
<p>待实现</p></li>
</ol>
<h3 id="queue">Queue</h3>
<p>Quene 的两个基本操作为 Enqueue 和 Dequque。维护了 <strong>head</strong> 和 <strong>tail</strong> 两个索引，分别指向第一个元素，下一个可以插入的位置。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">package</span> queue</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">import</span> (</span>
<span id="cb4-4"><a href="#cb4-4"></a>	<span class="st">&quot;errors&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>)</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="kw">var</span> (</span>
<span id="cb4-8"><a href="#cb4-8"></a>	OverflowError  = errors.New(<span class="st">&quot;overflow&quot;</span>)</span>
<span id="cb4-9"><a href="#cb4-9"></a>	UnderflowError = errors.New(<span class="st">&quot;underflow&quot;</span>)</span>
<span id="cb4-10"><a href="#cb4-10"></a>)</span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="kw">type</span> Element <span class="kw">interface</span> {</span>
<span id="cb4-13"><a href="#cb4-13"></a>}</span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="kw">type</span> Queue <span class="kw">interface</span> {</span>
<span id="cb4-16"><a href="#cb4-16"></a>	Enqueue(e Element) <span class="dt">error</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>	Dequeue() (e Element, err <span class="dt">error</span>)</span>
<span id="cb4-18"><a href="#cb4-18"></a>}</span></code></pre></div>
<p>对于底层长度为 N 的数组，最多可以保存 N-1 个元素（否则 tail 与 head 重合时无法判断是空还是满）</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">package</span> queue</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">type</span> ArrayQueue <span class="kw">struct</span> {</span>
<span id="cb5-4"><a href="#cb5-4"></a>	array []Element</span>
<span id="cb5-5"><a href="#cb5-5"></a>	head  <span class="dt">int</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>	tail  <span class="dt">int</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>}</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">func</span> NewArrayQueue(<span class="bu">cap</span> <span class="dt">int</span>) *ArrayQueue {</span>
<span id="cb5-10"><a href="#cb5-10"></a>	<span class="kw">return</span> &amp;ArrayQueue{</span>
<span id="cb5-11"><a href="#cb5-11"></a>		<span class="bu">make</span>([]Element, <span class="bu">cap</span>+<span class="dv">1</span>),</span>
<span id="cb5-12"><a href="#cb5-12"></a>		<span class="dv">0</span>,</span>
<span id="cb5-13"><a href="#cb5-13"></a>		<span class="dv">0</span>,</span>
<span id="cb5-14"><a href="#cb5-14"></a>	}</span>
<span id="cb5-15"><a href="#cb5-15"></a>}</span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="kw">func</span> (q *ArrayQueue) Len() <span class="dt">int</span> {</span>
<span id="cb5-18"><a href="#cb5-18"></a>	<span class="kw">return</span> <span class="bu">len</span>(q.array)</span>
<span id="cb5-19"><a href="#cb5-19"></a>}</span>
<span id="cb5-20"><a href="#cb5-20"></a></span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="kw">func</span> (q *ArrayQueue) Enqueue(e Element) <span class="dt">error</span> {</span>
<span id="cb5-22"><a href="#cb5-22"></a>	<span class="kw">if</span> (q.tail+<span class="dv">1</span>)%q.Len() == q.head {</span>
<span id="cb5-23"><a href="#cb5-23"></a>		<span class="kw">return</span> OverflowError</span>
<span id="cb5-24"><a href="#cb5-24"></a>	}</span>
<span id="cb5-25"><a href="#cb5-25"></a></span>
<span id="cb5-26"><a href="#cb5-26"></a>	q.array[q.tail] = e</span>
<span id="cb5-27"><a href="#cb5-27"></a>	q.tail = (q.tail + <span class="dv">1</span>) % q.Len()</span>
<span id="cb5-28"><a href="#cb5-28"></a>	<span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb5-29"><a href="#cb5-29"></a>}</span>
<span id="cb5-30"><a href="#cb5-30"></a></span>
<span id="cb5-31"><a href="#cb5-31"></a><span class="kw">func</span> (q *ArrayQueue) Dequeue() (e Element, err <span class="dt">error</span>) {</span>
<span id="cb5-32"><a href="#cb5-32"></a>	<span class="kw">if</span> q.tail == q.head {</span>
<span id="cb5-33"><a href="#cb5-33"></a>		<span class="kw">return</span> <span class="ot">nil</span>, UnderflowError</span>
<span id="cb5-34"><a href="#cb5-34"></a>	}</span>
<span id="cb5-35"><a href="#cb5-35"></a></span>
<span id="cb5-36"><a href="#cb5-36"></a>	e = q.array[q.head]</span>
<span id="cb5-37"><a href="#cb5-37"></a>	q.head = (q.head + <span class="dv">1</span>) % q.Len()</span>
<span id="cb5-38"><a href="#cb5-38"></a>	<span class="kw">return</span></span>
<span id="cb5-39"><a href="#cb5-39"></a>}</span></code></pre></div>
<ol class="incremental">
<li><p><span class="todo TODO">TODO</span> 双向队列</p>
<p>可以分别对 head 和 tail 进行压栈和弹栈操作。这种数据结构称为双端队列 (deque)</p>
<p>待实现</p></li>
<li><p>双栈实现法</p>
<p>参考 <a href="https://www.geeksforgeeks.org/queue-using-stacks/">https://www.geeksforgeeks.org/queue-using-stacks/</a></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">package</span> queue</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">import</span> (</span>
<span id="cb6-4"><a href="#cb6-4"></a>	<span class="st">&quot;github.com/larryzju/ita/stack&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>)</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">type</span> BiStackQueue <span class="kw">struct</span> {</span>
<span id="cb6-8"><a href="#cb6-8"></a>	a, b stack.Stack</span>
<span id="cb6-9"><a href="#cb6-9"></a>	useA <span class="dt">bool</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>}</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">func</span> NewBiStackQueue(a, b stack.Stack) *BiStackQueue {</span>
<span id="cb6-13"><a href="#cb6-13"></a>	<span class="kw">return</span> &amp;BiStackQueue{a, b, <span class="ot">true</span>}</span>
<span id="cb6-14"><a href="#cb6-14"></a>}</span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="kw">func</span> (q *BiStackQueue) Enqueue(e Element) <span class="dt">error</span> {</span>
<span id="cb6-17"><a href="#cb6-17"></a>	<span class="kw">if</span> q.a.Push(e) == stack.OverflowError {</span>
<span id="cb6-18"><a href="#cb6-18"></a>		<span class="kw">return</span> OverflowError</span>
<span id="cb6-19"><a href="#cb6-19"></a>	}</span>
<span id="cb6-20"><a href="#cb6-20"></a>	<span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>}</span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="kw">func</span> (q *BiStackQueue) Dequeue() (e Element, err <span class="dt">error</span>) {</span>
<span id="cb6-24"><a href="#cb6-24"></a>	<span class="kw">if</span> e, err := q.b.Pop(); err == <span class="ot">nil</span> {</span>
<span id="cb6-25"><a href="#cb6-25"></a>		<span class="kw">return</span> e, <span class="ot">nil</span></span>
<span id="cb6-26"><a href="#cb6-26"></a>	}</span>
<span id="cb6-27"><a href="#cb6-27"></a></span>
<span id="cb6-28"><a href="#cb6-28"></a>	<span class="kw">for</span> {</span>
<span id="cb6-29"><a href="#cb6-29"></a>		ele, err := q.a.Pop()</span>
<span id="cb6-30"><a href="#cb6-30"></a>		<span class="kw">if</span> err == stack.UnderflowError {</span>
<span id="cb6-31"><a href="#cb6-31"></a>			<span class="kw">break</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>		}</span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a>		<span class="kw">if</span> q.b.Push(ele) != <span class="ot">nil</span> {</span>
<span id="cb6-35"><a href="#cb6-35"></a>			<span class="co">// assume b has equal or more space than a</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>			<span class="bu">panic</span>(<span class="st">&quot;no space in b&quot;</span>)</span>
<span id="cb6-37"><a href="#cb6-37"></a>		}</span>
<span id="cb6-38"><a href="#cb6-38"></a>	}</span>
<span id="cb6-39"><a href="#cb6-39"></a></span>
<span id="cb6-40"><a href="#cb6-40"></a>	<span class="kw">if</span> e, err = q.b.Pop(); err == <span class="ot">nil</span> {</span>
<span id="cb6-41"><a href="#cb6-41"></a>		<span class="kw">return</span> e, <span class="ot">nil</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>	}</span>
<span id="cb6-43"><a href="#cb6-43"></a></span>
<span id="cb6-44"><a href="#cb6-44"></a>	<span class="kw">return</span> <span class="ot">nil</span>, UnderflowError</span>
<span id="cb6-45"><a href="#cb6-45"></a>}</span></code></pre></div>
<p>假设 b 栈空间不小于 a 栈空间，且队列的可用空间与实际入队出队顺序有关</p></li>
</ol>
<h3 id="linked-list"><span class="todo TODO">TODO</span> Linked List</h3>
<p>与数组不同，可以动态扩展。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">package</span> list</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">type</span> Element <span class="kw">interface</span> {</span>
<span id="cb7-4"><a href="#cb7-4"></a>}</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">type</span> Node <span class="kw">interface</span> {</span>
<span id="cb7-7"><a href="#cb7-7"></a>	Element() Element</span>
<span id="cb7-8"><a href="#cb7-8"></a>}</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">type</span> List <span class="kw">interface</span> {</span>
<span id="cb7-11"><a href="#cb7-11"></a>	Search(Element) Node</span>
<span id="cb7-12"><a href="#cb7-12"></a>	InsertAfter(Node, Element) Node</span>
<span id="cb7-13"><a href="#cb7-13"></a>	Delete(Node) Element</span>
<span id="cb7-14"><a href="#cb7-14"></a>}</span></code></pre></div>
<p>双指针链表包含了 <code>prev</code> 与 <code>next</code> 两个指针。其中头结点 <code>head.prev</code> 为空，尾结点 <code>tail.next</code> 为空</p>
<p>实际实现中可以改造为</p>
<ol class="incremental">
<li>单链表</li>
<li>排序链表</li>
<li>循环链表： <code>head.prev == tail</code> , <code>tail.next == head</code></li>
</ol>
<p>为了实现简单，可以为 List 中添加一个 dummy object (sentinel)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">package</span> list</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">type</span> DoubleLinkedListNode <span class="kw">struct</span> {</span>
<span id="cb8-4"><a href="#cb8-4"></a>	value Element</span>
<span id="cb8-5"><a href="#cb8-5"></a>	next  *DoubleLinkedListNode</span>
<span id="cb8-6"><a href="#cb8-6"></a>	prev  *DoubleLinkedListNode</span>
<span id="cb8-7"><a href="#cb8-7"></a>}</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">func</span> (n *DoubleLinkedListNode) Element() Element {</span>
<span id="cb8-10"><a href="#cb8-10"></a>	<span class="kw">return</span> n.value</span>
<span id="cb8-11"><a href="#cb8-11"></a>}</span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">type</span> DoubleLinkedList <span class="kw">struct</span> {</span>
<span id="cb8-14"><a href="#cb8-14"></a>	Head *DoubleLinkedListNode</span>
<span id="cb8-15"><a href="#cb8-15"></a>}</span>
<span id="cb8-16"><a href="#cb8-16"></a></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="kw">func</span> NewDoubleLinkedList() *DoubleLinkedList {</span>
<span id="cb8-18"><a href="#cb8-18"></a>	head := &amp;DoubleLinkedListNode{value: <span class="ot">nil</span>, next: <span class="ot">nil</span>, prev: <span class="ot">nil</span>}</span>
<span id="cb8-19"><a href="#cb8-19"></a>	<span class="kw">return</span> &amp;DoubleLinkedList{Head: head}</span>
<span id="cb8-20"><a href="#cb8-20"></a>}</span>
<span id="cb8-21"><a href="#cb8-21"></a></span>
<span id="cb8-22"><a href="#cb8-22"></a><span class="kw">func</span> (lst *DoubleLinkedList) Search(e Element) Node {</span>
<span id="cb8-23"><a href="#cb8-23"></a>	p := lst.Head.next</span>
<span id="cb8-24"><a href="#cb8-24"></a>	<span class="kw">for</span> p != <span class="ot">nil</span> &amp;&amp; p.value != e {</span>
<span id="cb8-25"><a href="#cb8-25"></a>		p = p.next</span>
<span id="cb8-26"><a href="#cb8-26"></a>	}</span>
<span id="cb8-27"><a href="#cb8-27"></a>	<span class="kw">return</span> p</span>
<span id="cb8-28"><a href="#cb8-28"></a>}</span>
<span id="cb8-29"><a href="#cb8-29"></a></span>
<span id="cb8-30"><a href="#cb8-30"></a><span class="kw">func</span> (lst *DoubleLinkedList) InsertAfter(node Node, e Element) Node {</span>
<span id="cb8-31"><a href="#cb8-31"></a>	n := node.(*DoubleLinkedListNode)</span>
<span id="cb8-32"><a href="#cb8-32"></a>	en := &amp;DoubleLinkedListNode{e, n.next, n}</span>
<span id="cb8-33"><a href="#cb8-33"></a>	n.next = en</span>
<span id="cb8-34"><a href="#cb8-34"></a>	<span class="kw">return</span> en</span>
<span id="cb8-35"><a href="#cb8-35"></a>}</span>
<span id="cb8-36"><a href="#cb8-36"></a></span>
<span id="cb8-37"><a href="#cb8-37"></a><span class="kw">func</span> (lst *DoubleLinkedListNode) Delete(node Node) Element {</span>
<span id="cb8-38"><a href="#cb8-38"></a>	n := node.(*DoubleLinkedListNode)</span>
<span id="cb8-39"><a href="#cb8-39"></a>	n.prev.next = n.next</span>
<span id="cb8-40"><a href="#cb8-40"></a>	n.next.prev = n.prev</span>
<span id="cb8-41"><a href="#cb8-41"></a>	<span class="kw">return</span> n.value</span>
<span id="cb8-42"><a href="#cb8-42"></a>}</span></code></pre></div>
<h3 id="rooted-tree"><span class="todo TODO">TODO</span> Rooted Tree</h3>

			</div>
		</section>
	</body>
</html>
