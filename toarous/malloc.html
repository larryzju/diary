<!DOCTYPE html>
<html>
	<head>
		<title>malloc.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="overview">Overview</h1>
<h2 id="segment">segment</h2>
<p>A process has several segments of memory<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<ul class="incremental">
<li>Code (text) segmemnt, which contains the code to be executed</li>
<li>Data segment, which contains data the compiler knows about (globals and statics)</li>
<li>Stack segment, which contains (drumroll..) the stack</li>
</ul>
<h2 id="heap">heap</h2>
<p>Heap is memory block with a contiguous series of addresses. Program can expand or contract and use as its own accord (system break).</p>
<h2 id="system-break">system break</h2>
<p>The <code>brk()</code> system call is used to change the point where the data segment "breaks" (ends). And <code>sbrk(intptr_t increment)</code> increments the program's data space by <code>increment</code> bytes.</p>
<p>Program don't need to call <code>brk</code> or <code>sbrk</code> typically, though calling <code>sbrk(0)</code> can be interesting because it tells you where your heap currently ends</p>
<p>POSIX <code>sbrk</code> API is used to move the system break. But normally, program use a <strong>memory allocation system</strong> to handle chuncking up and keeping track of which memory is allocated and which is freed.</p>
<p>Call <code>sbrk</code> to increase the size of the heap. For typical architectures the heap will grow upwards and the stack grows downwards.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">void</span> *top_of_heap = sbrk(<span class="dv">0</span>);</span>
<span id="cb1-2"><a href="#cb1-2"></a>malloc(<span class="dv">16384</span>);</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="dt">void</span> *top_of_heap2 = sbrk(<span class="dv">0</span>);</span>
<span id="cb1-4"><a href="#cb1-4"></a>printf(<span class="st">&quot;The top of heap went from %p to %p </span><span class="sc">\n</span><span class="st">&quot;</span>, top_of_heap,</span>
<span id="cb1-5"><a href="#cb1-5"></a>top_of_heap2);</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">// Example output: The top of heap went from 0x4000 to 0xa000</span></span></code></pre></div>
<h2 id="posix-api">POSIX API</h2>
<p>C API for memory allocation</p>
<dl class="incremental">
<dt><code>malloc(size_t bytes)</code></dt>
<dd>reverse a contiguous block of memory
</dd>
<dt><code>realloc(void *space, size_t bytes)</code></dt>
<dd>resize an existing memory allocation
</dd>
<dt><code>calloc(size_t nmemb, size_t size)</code></dt>
<dd>initialize memory contents to zero
</dd>
<dt><code>free(void *ptr)</code></dt>
<dd>make it available for use in the subsequent calls to the other allocation functions
</dd>
</dl>
<h1 id="allocating">Allocating</h1>
<h2 id="naive-version">Naive version</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">void</span> *malloc(<span class="dt">size_t</span> size) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="co">// sbrk increase heap size with `size` bytes and return the previous system break</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="co">// return -1 on failure</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="dt">void</span> *p = sbrk(size);</span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="cf">if</span>(p == (<span class="dt">void</span>*)-<span class="dv">1</span>) <span class="cf">return</span> NULL;</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="cf">return</span> p;</span>
<span id="cb2-7"><a href="#cb2-7"></a>}</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="dt">void</span> free() {</span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="co">/* Do Nothing */</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>}</span></code></pre></div>
<p>Drawbacks:</p>
<ul class="incremental">
<li>system calls are slow compared to library calls. (we should reversed a large amount of memory and only occasionally ask for more from the system)</li>
<li>No reuse of freed memory. Process would exhaust memory quickly.</li>
</ul>
<h2 id="placement-strategies">Placement Strategies</h2>
<p>随着 <code>malloc</code> 的调用，heap 的空间被划分为大小不一的块。 申请新空间时，有几种不同的策略：</p>
<dl class="incremental">
<dt>perfect-fit strategy</dt>
<dd>找出符合要求的最小空闲块
</dd>
<dt>worst-fit strategy</dt>
<dd>使用最大空间的空闲块
</dd>
<dt>first-fit strategy</dt>
<dd>使用第一个空间足够的块
</dd>
<dt>next-fit strategy</dt>
<dd>first fit on the next fit block，添加了随机性
</dd>
</dl>
<p>以上方式都有可能会损失一部分的空间（多出来的空间既不会被 allocator 使用，也不会被分配给用户）</p>
<p>实现 Heap Allocator 主要需要考虑到</p>
<ul class="incremental">
<li>减少碎片化，提高内存使用率</li>
<li>性能</li>
<li>代码实现难度</li>
<li>特定使用场景有关</li>
</ul>
<p>一些经验<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>：</p>
<ul class="incremental">
<li>如果每次都取最小空闲块，反而导致剩余空间过小无法被利用（可以考虑设置一个阈值）</li>
<li>first-fit 除了按地址顺序外，还可以按最近使用顺序、空闲时长等排序</li>
<li>避免扫描全部块</li>
</ul>
<p>涉及到的数据结构：</p>
<ul class="incremental">
<li>max-heap</li>
<li>linked list</li>
<li>randomized skip-list in conjunction with singly linked list</li>
</ul>
<h2 id="sample-implementation">Sample Implementation</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">type</span> Block <span class="kw">struct</span> {</span>
<span id="cb3-2"><a href="#cb3-2"></a>        Metadata Metadata</span>
<span id="cb3-3"><a href="#cb3-3"></a>        Space    <span class="dt">uintptr</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>        BTag     BTag  <span class="co">// Boundary Tag</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>}</span></code></pre></div>
<ul class="incremental">
<li>Metadata 中记录了： Space 的大小，是否被使用</li>
<li>下一个块的位置可以由 <code>p + sizeof(meta) + p-&gt;size + sizeof(BTag)</code> 计算</li>
</ul>
<h3 id="first-fit-malloc">first fit malloc</h3>
<p>基本思路</p>
<ul class="incremental">
<li>从第一个块开始遍历，直到找到第一个未被使用，空间充足的块</li>
<li>若没有合适的块，则调用 <code>sbrk()</code> 扩大 heap 空间</li>
<li>使用前，劈成两块，使用前者，后者生成一个新的未使用空间</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="dt">size_t</span> block_size;</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="dt">int</span> is_free;</span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="dt">char</span> data[<span class="dv">0</span>];</span>
<span id="cb4-5"><a href="#cb4-5"></a>} block;</span>
<span id="cb4-6"><a href="#cb4-6"></a>block *p = sbrk(<span class="dv">100</span>);</span>
<span id="cb4-7"><a href="#cb4-7"></a>p-&gt;size = <span class="dv">100</span> - <span class="kw">sizeof</span>(*p) - <span class="kw">sizeof</span>(boundary_tag);</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">// Other block allocations</span></span></code></pre></div>
<p><em>images/malloc-split.png</em></p>
<h3 id="alignment-and-rounding-up-considerations">Alignment and rounding up considerations</h3>
<p>一般以 4 字节或 8 字节对齐内存以提高访问效率。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">int</span> s = (requested_bytes + tag_overhead_bytes + <span class="dv">15</span>) / <span class="dv">16</span></span></code></pre></div>
<h3 id="free">free</h3>
<p>基本思路：</p>
<ul class="incremental">
<li>标记块状态为“未被使用”</li>
<li>合并相邻的可用块（boundary tag 中包含了上一个块的位置信息）</li>
</ul>
<h3 id="performance">Performance</h3>
<ul class="incremental">
<li>malloc 最差情况为线性</li>
<li>free 为常数次（最多与前后两个块合并）</li>
</ul>
<h3 id="explicit-free-lists-allocators">Explicit Free Lists Allocators</h3>
<p>维护一个双向链表，保存未使用的 block 信息</p>
<ul class="incremental">
<li>减少分配时间</li>
<li>调整分配顺序</li>
</ul>
<p>需要调整 Block Metadata 和 Boundary Tag 内容（回收时需要更新）</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> {</span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="dt">size_t</span> info;</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="kw">struct</span> block *next;</span>
<span id="cb6-4"><a href="#cb6-4"></a>  <span class="dt">char</span> data[<span class="dv">0</span>];</span>
<span id="cb6-5"><a href="#cb6-5"></a>} block;</span></code></pre></div>
<figure>
<img src="./images/free-list.png" alt="" /><figcaption>Free list</figcaption>
</figure>
<h2 id="segregated-allocator">Segregated Allocator</h2>
<div class="line-block">A segregated allocator is one that divides the heap into different areas that are handled by different sub-allocators<br />
dependent on the size of the allocation request.</div>
<p>Buddy allocator</p>
<ul class="incremental">
<li>splits allocation into blocks of size <span class="math inline">\(2^n\)</span> (or Fibonacci split)</li>
<li>如果 <span class="math inline">\(2^n\)</span> 没有空间，则去下一级内寻找，将之一分为二</li>
<li>使用完成后合并并交还（合并时更快，因为是基于地址，而非 boundary tag）</li>
</ul>
<h1 id="todo"><span class="todo TODO">TODO</span> TODO</h1>
<h2 id="mmap">mmap</h2>
<h2 id="jemalloc">jemalloc</h2>
<h2 id="knapsack-problem-np-hard">Knapsack problem / NP hard</h2>
<h2 id="slub">SLUB</h2>
<h2 id="wikipedias-buddy-memory-allocation-page">Wikipedia's buddy memory allocation page</h2>
<h1 id="footnotes">Footnotes</h1>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://stackoverflow.com/questions/6338162/what-is-program-break-where-does-it-start-from-0x00">Stackoverflow: What is program break? Where does it start from, 0x00?</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="http://cs241.cs.illinois.edu/coursebook/Malloc#intro-to-allocating">Introduction to memory allocation</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

			</div>
		</section>
	</body>
</html>
