<!DOCTYPE html>
<html>
	<head>
		<title>isr.org</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="overview">Overview</h1>
<p>IDT (Interrupt Descriptor Table) maintains all handlers procedure information</p>
<ol class="incremental">
<li>ISR is short for Interrupt Service Routines which is the handler for the internal interrupt or exception.</li>
<li>IRQ for external interrupt or software interrupt</li>
</ol>
<h1 id="kinds">Kinds</h1>
<h2 id="exception">Exception</h2>
<p>Generated internally by the CPU and used to alert the running kernel of an event or situation</p>
<h2 id="irq">IRQ</h2>
<p>Interrupt Request (Hardware Interrupt), which is generated externally by the chipset and is signalled by latching onto the <code>INTR</code> pin.</p>
<h2 id="software-interrupt">Software Interrupt</h2>
<p>To indicate that process need the kernel's attention (system call) with <code>INT N</code> instruction.</p>
<p>Most OS kernel choose just one port for software interrupt. Fox example, <code>0x80</code></p>
<h1 id="pic">8259 PIC</h1>
<p>Programmable Interrupt Controller, which the external devices connect to this chip rather than connect directly to CPU. If there's an interrupt in PIC's pin, CPU will stores state information on the stack and jumps to a location pointed to by the IDT.</p>
<p>There're two PICs in cascade mode: master and slave (The IBM PC/AT 8259 PIC Architecture)</p>
<ul class="incremental">
<li>The slave PIC's output signal is connected to the master PIC's #2 input port.</li>
<li>master PIC's output signal is connected to CPU and tell CPU the interrupt occurred and send the interrupt number (<code>[0-256)</code>)</li>
<li>By default IRQ 0-7 are set to interrupts 08h-0Fh, IRQs 8-15 are set to interrupts 70-77h</li>
<li>Vector offset can be changed when re-initializing</li>
</ul>
<h2 id="how-does-it-work">How Does it work?</h2>
<ol class="incremental">
<li>External device notify the PIC that it needs servicing</li>
<li>PIC feed the CUP interrupt signal</li>
<li>CPU accept the interrupt</li>
<li>PIC supply the interrupt number to the process</li>
<li>CPU looks up the interrupt address and act accordingly.</li>
</ol>
<h2 id="ports">Ports</h2>
<table>
<thead>
<tr class="header">
<th>Chip - Purpose</th>
<th>I/O port</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Master PIC - Command</td>
<td>0x0020</td>
</tr>
<tr class="even">
<td>Master PIC - Data</td>
<td>0x0021</td>
</tr>
<tr class="odd">
<td>Slave PIC - Command</td>
<td>0x00a0</td>
</tr>
<tr class="even">
<td>Slave PIC - Data</td>
<td>0x00a1</td>
</tr>
</tbody>
</table>
<h2 id="instruction">Instruction</h2>
<table>
<thead>
<tr class="header">
<th>instruction</th>
<th>code</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>end of interrupt (EOI)</td>
<td>0x20</td>
<td>at the end of an IRQ-based interrupt routine</td>
</tr>
<tr class="even">
<td>initialise command</td>
<td>0x11</td>
<td>make the PIC wait for 3 extra &quot;initialisation words&quot; on the data port: ICW2, ICW3, ICW4</td>
</tr>
</tbody>
</table>
<h2 id="data">Data</h2>
<table>
<thead>
<tr class="header">
<th>data</th>
<th>descrition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ICW2</td>
<td>Its vector offset</td>
</tr>
<tr class="even">
<td>ICW3</td>
<td>Tell it how it is wired to master/slaves</td>
</tr>
<tr class="odd">
<td>ICW4</td>
<td>Gives additional information about the environment</td>
</tr>
</tbody>
</table>
<h2 id="steps">Steps</h2>
<h2 id="external-device-connection-rules"><span class="todo TODO">TODO</span> External Device Connection Rules</h2>
<ul class="incremental">
<li>keyboard: IRQ1</li>
</ul>
<h1 id="code-analysis">Code Analysis</h1>
<h2 id="idt">IDT</h2>
<p><code>kernel/core/idt.c</code> regists <code>[0-256)</code> handler</p>
<ol class="incremental">
<li>number</li>
<li>handler address</li>
<li>selector <code>0x08</code></li>
<li>flag <code>0x8E</code></li>
</ol>
<h3 id="flag">Flag</h3>
<p>Flag is set to <code>0x10001110</code> for the interrupt gate:</p>
<ol class="incremental">
<li>P bit = 1</li>
<li>DPL = 0</li>
</ol>
<h3 id="selector"><span class="todo TODO">TODO</span> Selector</h3>
<p><code>0x80</code> ?</p>
<h3 id="format">Format</h3>
<p>Refer to x86 IDT descriptor format <a href="x86.org::*Illustration">illustration</a></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/*</span>
<span class="co"> * IDT Entry</span>
<span class="co"> */</span>
<span class="kw">struct</span> idt_entry {
        <span class="dt">unsigned</span> <span class="dt">short</span> base_low;
        <span class="dt">unsigned</span> <span class="dt">short</span> sel;
        <span class="dt">unsigned</span> <span class="dt">char</span> zero;
        <span class="dt">unsigned</span> <span class="dt">char</span> flags;
        <span class="dt">unsigned</span> <span class="dt">short</span> base_high;
} __attribute__((packed));</code></pre></div>
<h2 id="isr">ISR</h2>
<p><code>kernel/core/isrs.c</code> define the <code>[0,32)</code> ISR and the code is similar to <code>kernel/core/irq.c</code>.</p>
<p>Refer to the <em>IRQ</em> section.</p>
<h3 id="error-code">error code</h3>
<p>Some of the exceptions don't provide error code to the handler.</p>
<div class="sourceCode"><pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="co">; Interrupt Service Routines</span>
<span class="ot">%macro ISR_NOERR 1</span>
        <span class="kw">global</span> _isr<span class="ot">%1</span>
        _isr<span class="ot">%1:</span>
                <span class="kw">cli</span>
                <span class="kw">push</span> <span class="dt">byte</span> <span class="dv">0</span>
                <span class="kw">push</span> <span class="dt">byte</span> <span class="ot">%1</span>
                <span class="kw">jmp</span> isr_common_stub
<span class="ot">%endmacro</span>

<span class="ot">%macro ISR_ERR 1</span>
        <span class="kw">global</span> _isr<span class="ot">%1</span>
        _isr<span class="ot">%1:</span>
                <span class="kw">cli</span>
                <span class="kw">push</span> <span class="dt">byte</span> <span class="ot">%1</span>
                <span class="kw">jmp</span> isr_common_stub
<span class="ot">%endmacro</span>

<span class="co">; Standard X86 interrupt service routines</span>
ISR_NOERR <span class="dv">0</span>
ISR_NOERR <span class="dv">1</span>
ISR_NOERR <span class="dv">2</span>
ISR_NOERR <span class="dv">3</span>
ISR_NOERR <span class="dv">4</span>
ISR_NOERR <span class="dv">5</span>
ISR_NOERR <span class="dv">6</span>
ISR_NOERR <span class="dv">7</span>
ISR_ERR   <span class="dv">8</span>
ISR_NOERR <span class="dv">9</span>
ISR_ERR   <span class="dv">10</span>
ISR_ERR   <span class="dv">11</span>
ISR_ERR   <span class="dv">12</span>
ISR_ERR   <span class="dv">13</span>
ISR_ERR   <span class="dv">14</span>
ISR_NOERR <span class="dv">15</span>
ISR_NOERR <span class="dv">16</span>
ISR_NOERR <span class="dv">17</span>
ISR_NOERR <span class="dv">18</span>
ISR_NOERR <span class="dv">19</span>
ISR_NOERR <span class="dv">20</span>
ISR_NOERR <span class="dv">21</span>
ISR_NOERR <span class="dv">22</span>
ISR_NOERR <span class="dv">23</span>
ISR_NOERR <span class="dv">24</span>
ISR_NOERR <span class="dv">25</span>
ISR_NOERR <span class="dv">26</span>
ISR_NOERR <span class="dv">27</span>
ISR_NOERR <span class="dv">28</span>
ISR_NOERR <span class="dv">29</span>
ISR_NOERR <span class="dv">30</span>
ISR_NOERR <span class="dv">31</span></code></pre></div>
<h2 id="irq-1">IRQ</h2>
<ul class="incremental">
<li>install <code>[32,48)</code> ISR by default (in <code>irq_install</code>)</li>
<li>extra 16 IRQ handler for the <code>[16,32)</code> ISR</li>
<li>register with <code>irq_install_handler</code>, unregister with <code>irq_uninstall_handler</code></li>
</ul>
<h3 id="handler">handler</h3>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">void</span> (*irq_handler_t) (<span class="kw">struct</span> regs *);

<span class="co">// irq_hander_t is the function pointer</span>
<span class="dt">static</span> irq_handler_t irq_routines[<span class="dv">16</span>] = { NULL };

<span class="dt">void</span>
irq_handler(<span class="kw">struct</span> regs *r) {
        <span class="co">// define a new funcion pointer handler</span>
        <span class="dt">void</span> (*handler)(<span class="kw">struct</span> regs *r);

        <span class="co">// the function pointer is the IRQ handler</span>
        handler = irq_routines[r-&gt;int_no - <span class="dv">32</span>];

        <span class="co">// skip if no handler was bound</span>
        <span class="cf">if</span> (handler) {
                handler(r);
        }

        <span class="co">// interrupt is trigger by PIC2, send EOI to PIC2 data</span>
        <span class="cf">if</span> (r-&gt;int_no &gt;= <span class="dv">40</span>) {
                outportb(<span class="bn">0xA0</span>, <span class="bn">0x20</span>);
        }

        <span class="co">// send EOI to PIC1 data</span>
        outportb(<span class="bn">0x20</span>, <span class="bn">0x20</span>);
}</code></pre></div>
<h3 id="initialise">initialise</h3>
<ol class="incremental">
<li><p>remap vector offset</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span>
irq_remap() {
        <span class="co">// PIC1 initialization</span>
        outportb(<span class="bn">0x20</span>, <span class="bn">0x11</span>);
        <span class="co">// PIC2 initialization</span>
        outportb(<span class="bn">0xA0</span>, <span class="bn">0x11</span>);
        <span class="co">// PIC1 ICW2 vector offset 0x20</span>
        outportb(<span class="bn">0x21</span>, <span class="bn">0x20</span>);
        <span class="co">// PIC2 ICW2 vector offset 0x28</span>
        outportb(<span class="bn">0xA1</span>, <span class="bn">0x28</span>);
        <span class="co">// PIC1 ICW3 wired: 0b00000100, PIC2 output connects to PIC1 input #2</span>
        outportb(<span class="bn">0x21</span>, <span class="bn">0x04</span>);
        <span class="co">// PIC2 ICW3 identity: 0x02</span>
        outportb(<span class="bn">0xA1</span>, <span class="bn">0x02</span>);
        <span class="co">// PIC1 ICW4: 8086/88 (MCS-80/85) mode</span>
        outportb(<span class="bn">0x21</span>, <span class="bn">0x01</span>);
        <span class="co">// PIC2 ICW4: 8086/88 (MCS-80/85) mode</span>
        outportb(<span class="bn">0xA1</span>, <span class="bn">0x01</span>);
        <span class="co">// clear mask</span>
        outportb(<span class="bn">0x21</span>, <span class="bn">0x0</span>);
        outportb(<span class="bn">0xA1</span>, <span class="bn">0x0</span>);
}</code></pre></div></li>
<li><p>set irq handler</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span>
irq_install() {
        irq_remap();
        idt_set_gate(<span class="dv">32</span>, (<span class="dt">unsigned</span>)_irq0, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">33</span>, (<span class="dt">unsigned</span>)_irq1, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">34</span>, (<span class="dt">unsigned</span>)_irq2, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">35</span>, (<span class="dt">unsigned</span>)_irq3, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">36</span>, (<span class="dt">unsigned</span>)_irq4, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">37</span>, (<span class="dt">unsigned</span>)_irq5, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">38</span>, (<span class="dt">unsigned</span>)_irq6, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">39</span>, (<span class="dt">unsigned</span>)_irq7, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">40</span>, (<span class="dt">unsigned</span>)_irq8, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">41</span>, (<span class="dt">unsigned</span>)_irq9, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">42</span>, (<span class="dt">unsigned</span>)_irq10, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">43</span>, (<span class="dt">unsigned</span>)_irq11, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">44</span>, (<span class="dt">unsigned</span>)_irq12, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">45</span>, (<span class="dt">unsigned</span>)_irq13, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">46</span>, (<span class="dt">unsigned</span>)_irq14, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        idt_set_gate(<span class="dv">47</span>, (<span class="dt">unsigned</span>)_irq15, <span class="bn">0x08</span>, <span class="bn">0x8E</span>);
        __asm__ __volatile__(<span class="st">&quot;sti&quot;</span>);
}</code></pre></div></li>
</ol>
<h3 id="c-function-wrapper">C function wrapper</h3>
<p>The <code>irq_handler</code> C function is wrappered by assemble codes</p>
<ol class="incremental">
<li><p><code>_irqN</code> definition</p>
<div class="sourceCode"><pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="ot">%macro IRQ_ENTRY 2</span>
        <span class="kw">global</span> _irq<span class="ot">%1</span>
        _irq<span class="ot">%1:</span>
                <span class="kw">cli</span>
                <span class="kw">push</span> <span class="dt">byte</span> <span class="dv">0</span>
                <span class="kw">push</span> <span class="dt">byte</span> <span class="ot">%2</span>
                <span class="kw">jmp</span> irq_common_stub
<span class="ot">%endmacro</span>

<span class="co">; Interrupt Requests</span>
IRQ_ENTRY <span class="dv">0</span>, <span class="dv">32</span>
IRQ_ENTRY <span class="dv">1</span>, <span class="dv">33</span>
IRQ_ENTRY <span class="dv">2</span>, <span class="dv">34</span>
IRQ_ENTRY <span class="dv">3</span>, <span class="dv">35</span>
IRQ_ENTRY <span class="dv">4</span>, <span class="dv">36</span>
IRQ_ENTRY <span class="dv">5</span>, <span class="dv">37</span>
IRQ_ENTRY <span class="dv">6</span>, <span class="dv">38</span>
IRQ_ENTRY <span class="dv">7</span>, <span class="dv">39</span>
IRQ_ENTRY <span class="dv">8</span>, <span class="dv">40</span>
IRQ_ENTRY <span class="dv">9</span>, <span class="dv">41</span>
IRQ_ENTRY <span class="dv">10</span>, <span class="dv">42</span>
IRQ_ENTRY <span class="dv">11</span>, <span class="dv">43</span>
IRQ_ENTRY <span class="dv">12</span>, <span class="dv">44</span>
IRQ_ENTRY <span class="dv">13</span>, <span class="dv">45</span>
IRQ_ENTRY <span class="dv">14</span>, <span class="dv">46</span>
IRQ_ENTRY <span class="dv">15</span>, <span class="dv">47</span></code></pre></div>
<p>Define a macro <code>IRQ_ENTRY</code> which accepts two parameter and expand to</p>
<div class="sourceCode"><pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="kw">global</span> _irq0
<span class="fu">irq0:</span>
   <span class="kw">cli</span>
   <span class="kw">push</span> <span class="dt">byte</span> <span class="dv">0</span>    <span class="co">; PIC port</span>
   <span class="kw">push</span> <span class="dt">byte</span> <span class="dv">32</span>   <span class="co">; IRQ ID</span>
   <span class="kw">jmp</span> irq_common_stub
...</code></pre></div></li>
<li><p>wrapper</p>
<p>Pass <code>struct *reg</code> parameter to C function <code>irq_handler</code></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// kernel/include/system.h</span>
<span class="co">/* Registers */</span>
<span class="kw">struct</span> regs {
        <span class="dt">unsigned</span> <span class="dt">int</span> gs, fs, es, ds;
        <span class="dt">unsigned</span> <span class="dt">int</span> edi, esi, ebp, esp, ebx, edx, ecx, eax;
        <span class="dt">unsigned</span> <span class="dt">int</span> int_no, err_code;
        <span class="dt">unsigned</span> <span class="dt">int</span> eip, cs, eflags, useresp, ss;
};      </code></pre></div>
<div class="sourceCode"><pre class="sourceCode nasm"><code class="sourceCode nasm"><span class="fu">irq_common_stub:</span>
        <span class="kw">pusha</span>     <span class="co">;; any other registers</span>
        <span class="kw">push</span> <span class="kw">ds</span>   <span class="co">;; be care for the order</span>
        <span class="kw">push</span> <span class="kw">es</span>
        <span class="kw">push</span> <span class="kw">fs</span>
        <span class="kw">push</span> <span class="kw">gs</span>
        <span class="kw">mov</span> <span class="kw">ax</span><span class="bn">, 0x10   </span><span class="co">;; selector ??</span>
        <span class="kw">mov</span> <span class="kw">ds</span>, <span class="kw">ax</span>
        <span class="kw">mov</span> <span class="kw">es</span>, <span class="kw">ax</span>
        <span class="kw">mov</span> <span class="kw">fs</span>, <span class="kw">ax</span>
        <span class="kw">mov</span> <span class="kw">gs</span>, <span class="kw">ax</span>
        <span class="kw">mov</span> <span class="kw">eax</span>, <span class="kw">esp</span>
        <span class="kw">push</span> <span class="kw">eax</span>
        <span class="co">; Call the C kernel hardware interrupt handler</span>
        <span class="kw">mov</span> <span class="kw">eax</span>, irq_handler
        <span class="kw">call</span> <span class="kw">eax</span>
        <span class="kw">pop</span> <span class="kw">eax</span>
        <span class="kw">pop</span> <span class="kw">gs</span>
        <span class="kw">pop</span> <span class="kw">fs</span>
        <span class="kw">pop</span> <span class="kw">es</span>
        <span class="kw">pop</span> <span class="kw">ds</span>
        <span class="kw">popa</span>
        <span class="kw">add</span> <span class="kw">esp</span>, <span class="dv">8</span>
        <span class="kw">iret</span></code></pre></div></li>
</ol>
<h1 id="reference">Reference</h1>
<ul class="incremental">
<li><a href="https://wiki.osdev.org/PIC#Programming_the_PIC_chips">8259 PIC wiki.osdev.org</a></li>
<li><a href="https://nasm.us/doc/nasmdoc4.html">The NASM Preprocessor</a></li>
</ul>

			</div>
		</section>
	</body>
</html>
