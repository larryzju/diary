<!DOCTYPE html>
<html>
	<head>
		<title>idt.md</title>
		<link rel="stylesheet" href="/diary/resources/css/main.css" />
		<link rel="stylesheet" href="/diary/resources/highlight/styles/default.css" />
		<script src="/diary/resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/resources/js/swgen.js"></script>
		<script src="/diary/resources/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<h1 id="section">版本</h1>

<p>以版本 <code>a331c106f6ce4caa22f859e453cd4774cb9e2d25</code> 为例说明</p>

<h1 id="idt">IDT</h1>

<p>IDT ( Interrupt Descriptor Table ) 指定了一个数组（最大有 256 个），数组元素的类型为 <code>struct idt_entry</code> （表示 80386 INTERRUPT GATE 数据类型）。</p>

<p>IDT 数组通过 <code>struct idt_ptr</code> 结构来指向，其中包括：起始位置 <code>base</code> 和长度 <code>limit</code></p>

<blockquote>
  <p>TODO:
为什么 idtp.limit 保存的大小是 <code>(sizeof(struct idt_entry) * 256 ) - 1</code></p>
</blockquote>

<h2 id="section-1">流程</h2>

<ol>
  <li><code>main()</code>  在 main.c</li>
  <li><code>idt_install()</code> 在 idt.c</li>
  <li><code>idt_load()</code> 在 start.asm 52 行</li>
  <li>调用 <code>lidt</code> 指令加载指针 <code>struct idt_ptr</code></li>
</ol>

<h1 id="exception-handler">Exception Handler</h1>

<p>IDT 表中 256 个中断号分为两部分：</p>

<ol>
  <li>前 32 个为系统保留 （NMI 中断和异常）</li>
  <li>用户自定义外部中断（通过 8259A 可编程中断控制器）在 [32,256)范围</li>
</ol>

<p>系统启动时将初始化前 32 个 NMI 中断处理过程（在 <code>isrs_install() 函数</code> 中）注册到相应的 IDT 注册号中，关键有以下两个值：</p>

<ol>
  <li>offset：指向处理的回调位置</li>
  <li>selector：选择 GDT 或 LDT 表中的指定 segment 位置</li>
</ol>

<h2 id="section-2">流程</h2>

<ol>
  <li><code>main()</code> 在 main.c</li>
  <li><code>isrs_install()</code> 在 isrs.c</li>
  <li><code>idt_set_gate()</code> 在 isrs.c，将 <code>_isr[0-32]</code> 中的定义的位置设置到相应 IDT 中断号的 offset，选择 GDT 中的第一号表作为 segment 表（0x08），参见 <a href="segment.md#selector">segment selector</a></li>
</ol>

<p>当有异常发生时，系统会进行中断处理:</p>

<ol>
  <li>查找中断表，调用相应的 <code>_isr[0-32]</code> 代码</li>
  <li><code>_isr[0-32]</code> 压栈相应的 err_code，并调用 <code>isr_common_stub</code></li>
  <li><code>isr_common_stub</code> 压栈各种寄存器，并调用 <code>fault_handler</code>（在isrs.c定义）</li>
  <li><code>fault_handler</code> 查找中断号，并打印文本信息</li>
</ol>

<h2 id="section-3">问题</h2>

<ul>
  <li>
    <p><code>struct regs</code> 中的最后一组内容信息 <code>eip</code>, <code>cs</code>, <code>eflags</code>, <code>useresp</code>, <code>ss</code> 是何时被压栈的？？？</p>
  </li>
  <li>
    <p>代码中 <code>_isr8</code>, <code>_isr10</code>, <code>_isr11</code>, <code>_isr12</code>, <code>_isr13</code>, <code>_isr14</code> 等实现中没有压栈 <code>err_code</code> 是否 BUG?</p>
  </li>
</ul>


			</div>
		</section>
	</body>
</html>
