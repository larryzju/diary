<!DOCTYPE html>
<html>
	<head>
		<title>csapp-digest.org</title>
		<link rel="stylesheet" href="/diary/_resources/css/main.css" />
		<script src="/diary/_resources/js/jquery-3.4.1.min.js"></script>
		<script src="/diary/_resources/js/swgen.js"></script>
	</head>
	<body>
		<nav id='content'>
		</nav>
		<section class="main-article-area">
			<div id='main'>
				<p>html5-fancy</p>
<h1 id="a-tour-of-computer-system">A Tour of Computer System</h1>
<p>A computer system consists of hardware and system software that work together to run application programs. Besides different among specific implements, the underlying concepts are the same. To be a &quot;power programmer&quot; we must understand the underlying computer system and its impact on your application programs.</p>
<p>常见的问题如数字格式、C 程序优化、链接、内存泄露、并行程序开发等。都将在后续展开。</p>
<h2 id="infomation-is-bits-context">Infomation is Bits + Context</h2>
<p>计算机中所有的信息都以一系列的位来表示。例如，源代码文件，以字节（8位）为单位保存在文件中。其编码由 ASCII 定义。</p>
<p>不同的位表示不同的意思的本质在于上下文（Context）。</p>
<div class="aside">
<p>C 语言于 1969-1973 年在贝尔实验室被创造。由 ANSI C 和 ISO 进行标准，著名书籍是 K&amp;R。C 语言有以下特点</p>
<ol class="incremental">
<li>与 UNIX 关联密切，可移植</li>
<li>small and simple</li>
<li>paratical purpose</li>
</ol>
</div>
<h2 id="programs-are-translated-by-other-programs-into-different-form">Programs Are Translated by Other Programs into different form</h2>
<p>程序以人类可读的程序语言写成（如 C 语言或汇编语言），需要将之翻译为机器可以识别的机器语言（二进制的可执行文件）。</p>
<p>通常的 C 源码需要经过 4 个步骤生成最终可执行文件，如下</p>
<table>
<tbody>
<tr class="odd">
<td>preprocessor(cpp)</td>
<td>用于展开头文件(.i)</td>
</tr>
<tr class="even">
<td>compiler(cc1)</td>
<td>翻译成汇编文件(.s)</td>
</tr>
<tr class="odd">
<td>assembler(as)</td>
<td>汇编生成 relocatable 文件(.o)</td>
</tr>
<tr class="even">
<td>linker(ld)</td>
<td>生成可执行文件</td>
</tr>
</tbody>
</table>
<div class="aside">
<p>GNU 项目由 Richard Stallman 于 1984 年发起，提供了诸多工具，如 emacs, gcc, gdb, as, linker 以及各种工具。linux 亦是基于 GNU 提供的工具构建的。</p>
</div>
<h2 id="it-pays-to-understand-how-compilation-system-work">It Pays to Understand How Compilation System Work</h2>
<p>编译器作了太多的事情，为此我们需要了解其细节，以便在以下方面进行优化：</p>
<ol class="incremental">
<li>优化性能：只有知道了编译器原理才能写出更好的高级语言。常见的问题如
<ul class="incremental">
<li>switch 与 if-else 的性能对比</li>
<li>函数调用开销有多大</li>
<li>while 和 for 的开销</li>
<li>pointer 和 array 的开销</li>
<li>解引用与直接访问本地变量的开销</li>
<li>算术顺序对性能的影响</li>
<li>I32 与 x86-64 的指令系统</li>
<li>内存管理</li>
</ul></li>
<li>Understand link-time error：如以下问题：
<ul class="incremental">
<li>找不到引用</li>
<li>static 与 global 变量</li>
<li>global 变量重名</li>
<li>静态库与动态库</li>
<li>库的顺序对正确的影响</li>
<li>运行时发生的错误</li>
</ul></li>
<li>Avoiding security holes：应限制从未知数据源获取数据，注意栈上的存储方式</li>
</ol>
<h2 id="processors-read-and-interrupt-instructions-stored-in-memory">Processors Read and Interrupt Instructions Stored in Memory</h2>
<p>正常执行程序时，通过 shell 调用可执行程序。实际在底层复杂无比，归纳起来过程如下：</p>
<ol class="incremental">
<li>shell 交互输入参数到内存</li>
<li>加载可执行文件内容到内存（DMA 技术）</li>
<li>执行</li>
<li>退出</li>
</ol>
<p>其中涉及到计算机的硬件组成。如下图所示：</p>
<p><img src="./img/hardware-org.png" /></p>
<p>硬件中包含几个核心部件，如 CPU，内存，IO 设备，总线等。</p>
<dl class="incremental">
<dt>总线</dt>
<dd>用于沟通各个组件，以 word 为单位（4字节或8字节）进行传送
</dd>
<dt>IO 设备</dt>
<dd>包括输入、输出、存储和网络，通过 controller/adapter<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> 接到 IO 总线上
</dd>
<dt>主存</dt>
<dd>DRAM (Dynamic Random Access Memory)，通过唯一的连续地址来访问
</dd>
<dt>处理器</dt>
<dd>CPU 核心（如 PC，寄存器，ALU单元），根据指令集<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>进行取指、择指、执行、下一条的循环过程，常见操作如 load,store,operate,jump 等
</dd>
</dl>
<h2 id="caches-matters">Caches Matters</h2>
<p>机器指令中的很大一部分工作都是在外部存储、内存、寄存器和外设之间移动数据。</p>
<p>而存储的容量与读写的效率成反比，而且差距还在增大。所以需要考虑如何优化拷贝的效率。</p>
<p>一个关键的问题称为 processor-memory gap：处理器性能与内存读取的鸿沟。通过添加 cache memory 来缓存近线数据来弥补数据的速度与容量的差距性。</p>
<h2 id="storage-devices-from-a-hierarchy">Storage Devices From a Hierarchy</h2>
<p><img src="img/memory-hierarchy.png" /></p>
<p>主流解决方案采用三级缓存，缓存使用 SRAM(static random access memory) 技术。</p>
<p>其中寄存器视为第 0 级缓存，自上向下速度越来越慢，而存储空间越来越大。</p>
<h2 id="the-operating-system-manages-the-hardware">The Operating System Manages the Hardware</h2>
<p>操作系统作为中间层，隔离了应用软件与硬件，其作用有两个：</p>
<ol class="incremental">
<li>保护硬件的正常运行</li>
<li>提供对硬件复杂性的封装，提供一致的、高效的接口</li>
</ol>
<p>操作系统对硬件作出抽象，其中主要包括</p>
<ul class="incremental">
<li>files</li>
<li>virtual memory</li>
<li>processor</li>
</ul>
<div class="aside">
<dl class="incremental">
<dt>Unix</dt>
<dd><p>诞生于 Multics 项目之后，由贝尔实验室 Ken Tompson 和 Dennis Ritchie 等在 DEC PDP-7 机器上实现，于 1973 年用 C 重写，并于 1974 年对外发布。</p>
<dl class="incremental">
<dt>BSD</dt>
<dd>伯克利版本 UNIX，加入了 Internet 支持和虚拟内存支持
</dd>
<dt>System V.</dt>
<dd>贝尔实验室后续版本
</dd>
<dt>Solaris</dt>
<dd>Sun 公司基于二者开发的版本
</dd>
</dl>
</dd>
<dt>Posix</dt>
<dd><p>IEEE 牵头制定的 UNIX 标准，包括系统调用的 C 接口，shell, utilities，thread 及 network programming。由 Richard Stallman 命名</p>
</dd>
</dl>
</div>
<h3 id="processes">Processes</h3>
<p>进程是对正在运行的程序的一个抽象描述。每个进程都有自己独立的计算、内存及 IO 资源。</p>
<p>操作系统通过上下文切换来时分复用，达到多个进程同时运行（concurrently）的效果。多核环境下，可以有真正的并行（parallelism）</p>
<p>上下文切换需要保存 PC 指针、Register file、Content of main memory 信息，涉及到操作系统与硬件的配合</p>
<h3 id="threads">Threads</h3>
<p>在一个进程中的上下文中可以有多个线程，线程共享代码和全局数据，因此更容易共享数据，效率较高</p>
<h3 id="virtual-memory">Virtual Memory</h3>
<p>在每个进程看来，自己独占了整个内存，称为 virtual address space。</p>
<p>实际上由操作系统在上下文切换时，通过硬件的转换机制伪造出相应的内存视图。可以看作用硬盘来保存进程的虚拟内存，而使用 main memory 作为缓存提高效率。</p>
<p>进程的内存分为多个区域，存储代码和数据，以及某些公共区域，如下图所示</p>
<p><img src="img/virutal-memory.png" /></p>
<p>其中：</p>
<ul class="incremental">
<li>code 在放在低地址的固定区域</li>
<li>C 中的全局变量存储</li>
<li>堆区域，在运行时通过 malloc 和 free 来动态扩展</li>
<li>shared libraries，用于动态链接</li>
<li>stack，保存函数调用时参数和返回传递，向下增长</li>
<li>kernel virtual memory 位于高地址，程序不可用</li>
</ul>
<h3 id="files">Files</h3>
<p>文件是对 I/O 设备的一种抽象。其本质是一堆字节，并提供了读写操作。</p>
<p>文件的作用是统一了 I/O 设备的视图，并提供不同设备、不同平台间的移植性。</p>
<p>Unix 中一切皆文件，因此也称作 Unix I/O</p>
<div class="aside">
<dl class="incremental">
<dt>Linux Project</dt>
<dd>Linus Torvalds 于 1991 年作为业余项目实现的一个类 UNIX 操作系统，受 Minix 启发，并兼容 Posix 标准。与 GNU 项目关系密切
</dd>
</dl>
</div>
<h2 id="system-communicate-with-other-system-using-network">System Communicate with Other System Using Network</h2>
<p>计算机系统并不只是以单机运行的。越来越多的价值从互联之中发掘。</p>
<p>计算机通过网络与其它计算机交换数据，网络也是一种 I/O 设备</p>
<h2 id="important-themes">Important Themes</h2>
<h3 id="concurrency-and-parallelism">Concurrency and Parallelism</h3>
<p>There are two simliar concepts about multiple execution implement ways</p>
<dl class="incremental">
<dt>Concurrency</dt>
<dd>To do more at the same time
</dd>
<dt>Parallelism</dt>
<dd>To do more and also fast at the same time
</dd>
</dl>
<p>There're 3 levels of parallelism abstract</p>
<ol class="incremental">
<li>Thread Level</li>
<li>Instruction Level</li>
<li>SIMD Level</li>
</ol>
<ol class="incremental">
<li><p>Thread Parallelism</p>
<p>Each Process can have multiple control flows. Operation System switch between threads (by backup and restore its context) rapidly in time shared manner to simulate parallel executions.</p>
<p>The origin aims of multiple threads is for the benefits of :</p>
<ul class="incremental">
<li>Multiple users</li>
<li>Single user with multiple tasks</li>
</ul>
<p>In the early days, the <strong>uniprocessor system</strong>'s multiple threads are just simulation for parallelism. The later <strong>multiprocessor system</strong> can run threads in real parallel manners.</p>
<p>There are 2 technologies in multiple processors system:</p>
<dl class="incremental">
<dt>multiple cores</dt>
<dd>each core has its own L1/L2 cache and resides in the same chip
</dd>
<dt>hyperthreading</dt>
<dd>each CPU has multiple copies of register and hardwares, can execute multiple tasks at same time
</dd>
</dl>
<p>Parallelism can be benefit for improve performances in aspects:</p>
<ol class="incremental">
<li>real multiple tasks</li>
<li>need new methods to program that can dig out the advantages of multiprocessor</li>
</ol></li>
<li><p>Instruction Parallelism</p>
<p>The most famous method is <strong>pipeline</strong> which execute instruction's setps in parrel and improve the performance faster than execute instruction for the whole cycles.</p>
<p>The technology to execution rates if faster than one instruction per cycle is called <strong>superscalar</strong></p></li>
<li><p>SIMD Parallelism</p>
<ul class="incremental">
<li>SIMD is short for Single Instruction Multiple Data.</li>
<li>Mostly used to speed up image, sound, video procses.</li>
<li>Need language (data type) and compiler supports.</li>
</ul></li>
</ol>
<h3 id="the-importance-of-abstraction-of-computer-system">The Importance of Abstraction of Computer System</h3>
<p><strong>Abstraction</strong> is one of the most important concept in Computer Science.</p>
<p>The import abstractions are:</p>
<dl class="incremental">
<dt>API</dt>
<dd>prototype which user doesn't need to delve into details
</dd>
<dt>Program Language</dt>
<dd>Abstraction concept like class, function
</dd>
<dt>ISA (Instruction Set Architecture)</dt>
<dd>Abstraction of sequential execution model for hardware implements (Different hardware can have different implement but share the machine code)
</dd>
<dt>File</dt>
<dd>Abstraction of I/O
</dd>
<dt>Virtual Memory</dt>
<dd>Abstraction Linear memory for program
</dd>
<dt>Process</dt>
<dd>Abstraction of a running program
</dd>
<dt>Virtual Machine</dt>
<dd>Abstraction of computer hardware
</dd>
</dl>
<h1 id="representing-and-manipulating-informations">Representing and Manipulating Informations</h1>
<h2 id="overview">Overview</h2>
<p>Computer information is represented in binary mode. The reason to express information with 2-vlaue bits is because its readily be represented, stored and transmitted.</p>
<p>We group bits and apply rules to interprete them for given meaning of bit pattern. That is called Data Type.</p>
<p>The reasons why we programmers should dive deep into the representation of data are listed below:</p>
<ol class="incremental">
<li>write correct and portable program for different platforms</li>
<li>improve performance</li>
<li>security cause</li>
<li>understand machine-level program</li>
</ol>
<p>Different types of number has three representations</p>
<ol class="incremental">
<li>unsigned integer</li>
<li>signed integer</li>
<li>floating-point</li>
</ol>
<p>For integer representations, it can be encoded for a comparatively small range of values, but do so precisely. While floating-point representations can encode a wide range of values, but only approximately.</p>
<p>Here's an example to show why we should be careful for the representation of data (floating-point arithmetic doesn't conform the association rule):</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">(<span class="fl">3.14</span> + <span class="fl">1e20</span>) - <span class="fl">1e20</span>            <span class="co">/* 0.0 */</span>
<span class="fl">3.14</span> + (<span class="fl">1e20</span> - <span class="fl">1e20</span>)            <span class="co">/* 3.14 */</span></code></pre></div>
<h3 id="c-standard">C standard<span class="tag" data-tag-name="c"></span></h3>
<p>For GNU c compiler</p>
<ol class="incremental">
<li><code>--ansi</code> or <code>--std=c89</code>: ANSI C(1989)/ISO C99(1990)</li>
<li><code>--std=gnu89</code>: GNU extends for ANSI C</li>
<li><code>--std=c99</code>: ISO C99(1999)</li>
<li><code>--std=gnu99</code>: GNU extends for ISO C99</li>
</ol>
<h2 id="information-storage">Information Storage</h2>
<p>We use <strong>bytes</strong> as the unit of memory which is consisted by 8 bits.</p>
<p>The virtual memory that program visits can be regarded as an array of bytes. Each bytes is indexed by <strong>address</strong>. Underlying the virtual memroy, it's made up of RAM, disk storage, special hardware, OS and provides the program with what appears to be a monolithic bytes array.</p>
<p><code>Pointer = Address + DataType</code></p>
<p>Actually, C compiler maintains pointer's type information, the machine-level program it generates has no information about data types.</p>
<p>Pointer are the central feature of C:</p>
<ol class="incremental">
<li>can be used to refer elements of data structure</li>
<li>combine value and type (provide flexible in program language)</li>
</ol>
<h3 id="hexadecimal-notation">Hexadecimal Notation</h3>
<p>Because of the representation in binary notation is too tedious. It's convinent to use hexadecimal notation to represent integer (such as <code>0xFA1D37BB</code>)</p>
<p>It's necessary to know how to convert among binary, decimal and hexadecimal:</p>
<dl class="incremental">
<dt>hex to bin</dt>
<dd>expand each hexadecimal to 4 bits binary
</dd>
<dt>bin to hex</dt>
<dd>split into groups of 4 bits (make the leftmost group be the one with fewer than 4bits and padding with leading zeros)
</dd>
<dt>hex to dec</dt>
<dd>multiplication methods
</dd>
<dt>dec to hex</dt>
<dd>division methods
</dd>
</dl>
<p>Some useful conversion or notation list below:</p>
<table>
<tbody>
<tr class="odd">
<td>2<sup>7</sup></td>
<td>128</td>
</tr>
<tr class="even">
<td>2<sup>8</sup></td>
<td>256</td>
</tr>
<tr class="odd">
<td>2<sup>10</sup></td>
<td>1024</td>
</tr>
<tr class="even">
<td>2<sup>16</sup></td>
<td>65536</td>
</tr>
</tbody>
</table>
<p>And <span class="math inline">2<sup><em>n</em></sup></span> in binary notation is a string starts with 1 followed by n zero.</p>
<h3 id="words">Words</h3>
<p>Bytes group to word. It's the nominal size of integer and pointer data.</p>
<p>The word is used to express virtual address. For 32bit platform, the memory address is in range from 0 to <span class="math inline">2<sup>32</sup> − 1</span> (4G bytes).</p>
<p>The 64bit platform extends the max available memory address to <span class="math inline">2<sup>64</sup> − 1</span>.</p>
<h3 id="data-sizes">Data Sizes</h3>
<p>The typeical data sizes (in C language) shows in the table below:</p>
<table>
<thead>
<tr class="header">
<th>data type</th>
<th>32 bit</th>
<th>64 bit</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>char</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr class="even">
<td>short int</td>
<td>2</td>
<td>2</td>
<td></td>
</tr>
<tr class="odd">
<td>int</td>
<td>4</td>
<td>4</td>
<td></td>
</tr>
<tr class="even">
<td>long int</td>
<td>4</td>
<td>8</td>
<td>the main different between 32bit and 64bit platforms</td>
</tr>
<tr class="odd">
<td>long long</td>
<td>8</td>
<td>8</td>
<td>defined in ISO C99 standard. supported by compiler in 32bit platform</td>
</tr>
<tr class="even">
<td>char*</td>
<td>4</td>
<td>8</td>
<td>word size of platform</td>
</tr>
<tr class="odd">
<td>float</td>
<td>4</td>
<td>4</td>
<td></td>
</tr>
<tr class="even">
<td>double</td>
<td>8</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table>
<p>The real data sizes depends on both the machine and the compiler.</p>
<p>It's very important to write portable code which is insentitive to the exact sizes of different data types.</p>
<p>For example, in history, <code>int</code> can be used to store a pointer in 32bit platform. But it's a fault error in 64bit platform.</p>
<h2 id="integer-representations">Integer Representations</h2>
<h2 id="integer-arithmetic">Integer Arithmetic</h2>
<h2 id="floating-point">Floating Point</h2>
<h1 id="footnotes">Footnotes</h1>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Controller 集成在设备或主板上，Adapater 是主板上的插槽的可插拔设备<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>指令集( Instruction set artichecture ) 相当于对外的接口，CPU 具体实现可以不同，称为 microarchitecture<a href="#fnref2">↩</a></p></li>
</ol>
</div>

			</div>
		</section>
	</body>
</html>
