#+TITLE: CSAPP 摘要
#+AUTHOR: Zhao WenBin
#+STATUS: 55/1078
#+OPTIONS: toc:2
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css">

* A Tour of Computer System

A computer system consists of hardware and system software that work together
to run application programs. Besides different among specific implements, the
underlying concepts are the same. To be a "power programmer" we must understand
the underlying computer system and its impact on your application programs.

常见的问题如数字格式、C 程序优化、链接、内存泄露、并行程序开发等。都将在后续展开。

** Infomation is Bits + Context

计算机中所有的信息都以一系列的位来表示。例如，源代码文件，以字节（8位）为单位保存在文件中。其编码由 ASCII 定义。

不同的位表示不同的意思的本质在于上下文（Context）。


#+BEGIN_aside
C 语言于 1969-1973 年在贝尔实验室被创造。由 ANSI C 和 ISO 进行标准，著名书籍是 K&R。C 语言有以下特点

1. 与 UNIX 关联密切，可移植
2. small and simple
3. paratical purpose
#+END_aside

** Programs Are Translated by Other Programs into different form

程序以人类可读的程序语言写成（如 C 语言或汇编语言），需要将之翻译为机器可以识别的机器语言（二进制的可执行文件）。

通常的 C 源码需要经过 4 个步骤生成最终可执行文件，如下

| preprocessor(cpp) | 用于展开头文件(.i)            |
| compiler(cc1)     | 翻译成汇编文件(.s)            |
| assembler(as)     | 汇编生成 relocatable 文件(.o) |
| linker(ld)        | 生成可执行文件                |

#+BEGIN_aside
GNU 项目由 Richard Stallman 于 1984 年发起，提供了诸多工具，如 emacs, gcc, gdb, as, linker 以及各种工具。linux 亦是基于 GNU 提供的工具构建的。
#+END_aside


** It Pays to Understand How Compilation System Work

编译器作了太多的事情，为此我们需要了解其细节，以便在以下方面进行优化：

1. 优化性能：只有知道了编译器原理才能写出更好的高级语言。常见的问题如
   - switch 与 if-else 的性能对比
   - 函数调用开销有多大
   - while 和 for 的开销
   - pointer 和 array 的开销
   - 解引用与直接访问本地变量的开销
   - 算术顺序对性能的影响
   - I32 与 x86-64 的指令系统
   - 内存管理
2. Understand link-time error：如以下问题：
   - 找不到引用
   - static 与 global 变量
   - global 变量重名
   - 静态库与动态库
   - 库的顺序对正确的影响
   - 运行时发生的错误
3. Avoiding security holes：应限制从未知数据源获取数据，注意栈上的存储方式











** Processors Read and Interrupt Instructions Stored in Memory

正常执行程序时，通过 shell 调用可执行程序。实际在底层复杂无比，归纳起来过程如下：

1. shell 交互输入参数到内存
2. 加载可执行文件内容到内存（DMA 技术）
3. 执行
4. 退出 

其中涉及到计算机的硬件组成。如下图所示：

[[./img/hardware-org.png]]

硬件中包含几个核心部件，如 CPU，内存，IO 设备，总线等。

- 总线 :: 用于沟通各个组件，以 word 为单位（4字节或8字节）进行传送
- IO 设备 :: 包括输入、输出、存储和网络，通过 controller/adapter[fn:1] 接到 IO 总线上
- 主存 :: DRAM (Dynamic Random Access Memory)，通过唯一的连续地址来访问
- 处理器 :: CPU 核心（如 PC，寄存器，ALU单元），根据指令集[fn:2]进行取指、择指、执行、下一条的循环过程，常见操作如 load,store,operate,jump 等

** Caches Matters

机器指令中的很大一部分工作都是在外部存储、内存、寄存器和外设之间移动数据。

而存储的容量与读写的效率成反比，而且差距还在增大。所以需要考虑如何优化拷贝的效率。

一个关键的问题称为 processor-memory gap：处理器性能与内存读取的鸿沟。通过添加 cache memory 来缓存近线数据来弥补数据的速度与容量的差距性。

** Storage Devices From a Hierarchy

[[file:img/memory-hierarchy.png]]

主流解决方案采用三级缓存，缓存使用 SRAM(static random access memory) 技术。

其中寄存器视为第 0 级缓存，自上向下速度越来越慢，而存储空间越来越大。

** The Operating System Manages the Hardware

操作系统作为中间层，隔离了应用软件与硬件，其作用有两个：

1. 保护硬件的正常运行
2. 提供对硬件复杂性的封装，提供一致的、高效的接口

操作系统对硬件作出抽象，其中主要包括

- files
- virtual memory
- processor

#+BEGIN_aside
- Unix :: 诞生于 Multics 项目之后，由贝尔实验室 Ken Tompson 和 Dennis Ritchie 等在 DEC PDP-7 机器上实现，于 1973 年用 C 重写，并于 1974 年对外发布。
  + BSD :: 伯克利版本 UNIX，加入了 Internet 支持和虚拟内存支持
  + System V. :: 贝尔实验室后续版本
  + Solaris :: Sun 公司基于二者开发的版本
- Posix :: IEEE 牵头制定的 UNIX 标准，包括系统调用的 C 接口，shell, utilities，thread 及 network programming。由 Richard Stallman 命名
#+END_aside

*** Processes

进程是对正在运行的程序的一个抽象描述。每个进程都有自己独立的计算、内存及 IO 资源。

操作系统通过上下文切换来时分复用，达到多个进程同时运行（concurrently）的效果。多核环境下，可以有真正的并行（parallelism）

上下文切换需要保存 PC 指针、Register file、Content of main memory 信息，涉及到操作系统与硬件的配合

*** Threads

在一个进程中的上下文中可以有多个线程，线程共享代码和全局数据，因此更容易共享数据，效率较高

*** Virtual Memory

在每个进程看来，自己独占了整个内存，称为 virtual address space。

实际上由操作系统在上下文切换时，通过硬件的转换机制伪造出相应的内存视图。可以看作用硬盘来保存进程的虚拟内存，而使用 main memory 作为缓存提高效率。

进程的内存分为多个区域，存储代码和数据，以及某些公共区域，如下图所示

[[file:img/virutal-memory.png]]

其中：

- code 在放在低地址的固定区域
- C 中的全局变量存储
- 堆区域，在运行时通过 malloc 和 free 来动态扩展
- shared libraries，用于动态链接
- stack，保存函数调用时参数和返回传递，向下增长
- kernel virtual memory 位于高地址，程序不可用

*** Files

文件是对 I/O 设备的一种抽象。其本质是一堆字节，并提供了读写操作。

文件的作用是统一了 I/O 设备的视图，并提供不同设备、不同平台间的移植性。

Unix 中一切皆文件，因此也称作 Unix I/O

#+BEGIN_aside
- Linux Project :: Linus Torvalds 于 1991 年作为业余项目实现的一个类 UNIX 操作系统，受 Minix 启发，并兼容 Posix 标准。与 GNU 项目关系密切
#+END_aside

** System Communicate with Other System Using Network

计算机系统并不只是以单机运行的。越来越多的价值从互联之中发掘。

计算机通过网络与其它计算机交换数据，网络也是一种 I/O 设备

** Important Themes
*** Concurrency and Parallelism

There are two simliar concepts about multiple execution implement ways
- Concurrency :: To do more at the same time
- Parallelism :: To do more and also fast at the same time

There're 3 levels of parallelism abstract
1. Thread Level
2. Instruction Level
3. SIMD Level

**** Thread Parallelism

Each Process can have multiple control flows. Operation System
switch between threads (by backup and restore its context) rapidly
in time shared manner to simulate parallel executions.

The origin aims of multiple threads is for the benefits of :
- Multiple users
- Single user with multiple tasks

In the early days, the *uniprocessor system*'s multiple threads are
just simulation for parallelism. The later *multiprocessor system* can
run threads in real parallel manners.  

There are 2 technologies in multiple processors system:
- multiple cores :: each core has its own L1/L2 cache and resides in the same chip
- hyperthreading :: each CPU has multiple copies of register and
                    hardwares, can execute multiple tasks at same time

Parallelism can be benefit for improve performances in aspects:
1. real multiple tasks
2. need new methods to program that can dig out the advantages of multiprocessor

**** Instruction Parallelism

The most famous method is *pipeline* which execute instruction's setps
in parrel and improve the performance faster than execute instruction
for the whole cycles.

The technology to execution rates if faster than one instruction per
cycle is called *superscalar*

**** SIMD Parallelism

- SIMD is short for Single Instruction Multiple Data.
- Mostly used to speed up image, sound, video procses.
- Need language (data type) and compiler supports.

*** The Importance of Abstraction of Computer System

*Abstraction* is one of the most important concept in Computer Science.

The import abstractions are:
- API :: prototype which user doesn't need to delve into details
- Program Language :: Abstraction concept like class, function
- ISA (Instruction Set Architecture) :: Abstraction of sequential
     execution model for hardware implements (Different hardware can
     have different implement but share the machine code)
- File :: Abstraction of I/O
- Virtual Memory :: Abstraction Linear memory for program
- Process :: Abstraction of a running program
- Virtual Machine :: Abstraction of computer hardware

* Representing and Manipulating Informations

** Overview

Computer information is represented in binary mode. The reason to
express information with 2-vlaue bits is because its readily be
represented, stored and transmitted.

We group bits and apply rules to interprete them for given meaning of
bit pattern. That is called Data Type.

The reasons why we programmers should dive deep into the
representation of data are listed below:
1. write correct and portable program for different platforms
2. improve performance
3. security cause
4. understand machine-level program

Different types of number has three representations
1. unsigned integer
2. signed integer
3. floating-point

For integer representations, it can be encoded for a comparatively
small range of values, but do so precisely. While floating-point
representations can encode a wide range of values, but only
approximately.

Here's an example to show why we should be careful for the
representation of data (floating-point arithmetic doesn't conform the
association rule):

#+BEGIN_SRC c
  (3.14 + 1e20) - 1e20            /* 0.0 */
  3.14 + (1e20 - 1e20)            /* 3.14 */
#+END_SRC


*** C standard                                                            :c:

For GNU c compiler
1. =--ansi= or =--std=c89=: ANSI C(1989)/ISO C99(1990)
2. =--std=gnu89=: GNU extends for ANSI C
3. =--std=c99=: ISO C99(1999)
4. =--std=gnu99=: GNU extends for ISO C99

** Information Storage

We use *bytes* as the unit of memory which is consisted by 8 bits.

The virtual memory that program visits can be regarded as an array of
bytes. Each bytes is indexed by *address*. Underlying the virtual
memroy, it's made up of RAM, disk storage, special hardware, OS and
provides the program with what appears to be a monolithic bytes array.

~Pointer = Address + DataType~ 

Actually, C compiler maintains pointer's type information, the
machine-level program it generates has no information about data
types.

Pointer are the central feature of C:
1. can be used to refer elements of data structure
2. combine value and type (provide flexible in program language)

*** Hexadecimal Notation

Because of the representation in binary notation is too tedious. It's
convinent to use hexadecimal notation to represent integer (such as
=0xFA1D37BB=)

It's necessary to know how to convert among binary, decimal and
hexadecimal:
- hex to bin :: expand each hexadecimal to 4 bits binary
- bin to hex :: split into groups of 4 bits (make the leftmost group
                be the one with fewer than 4bits and padding with
                leading zeros)
- hex to dec :: multiplication methods
- dec to hex :: division methods

Some useful conversion or notation list below:
| 2^7 | 128 |
| 2^8 | 256 |
| 2^10 | 1024 |
| 2^16 | 65536 |

And $2^n$ in binary notation is a string starts with 1 followed by n
zero.

*** Words

Bytes group to word. It's the nominal size of integer and pointer
data.

The word is used to express virtual address. For 32bit platform, the
memory address is in range from 0 to $2^32-1$ (4G bytes).

The 64bit platform extends the max available memory address to
$2^64-1$.

*** Data Sizes

The typeical data sizes (in C language) shows in the table below:
| data type | 32 bit | 64 bit | note                                                                 |
|-----------+--------+--------+----------------------------------------------------------------------|
| char      |      1 |      1 |                                                                      |
| short int |      2 |      2 |                                                                      |
| int       |      4 |      4 |                                                                      |
| long int  |      4 |      8 | the main different between 32bit and 64bit platforms                 |
| long long |      8 |      8 | defined in ISO C99 standard. supported by compiler in 32bit platform |
| char*     |      4 |      8 | word size of platform                                                |
| float     |      4 |      4 |                                                                      |
| double    |      8 |      8 |                                                                      |

The real data sizes depends on both the machine and the compiler.

It's very important to write portable code which is insentitive to the
exact sizes of different data types.

For example, in history, =int= can be used to store a pointer in 32bit
platform. But it's a fault error in 64bit platform.

** Integer Representations

** Integer Arithmetic

** Floating Point 


* [3/13] Virtual Memory

** DONE Overview

与 CPU 共享不同，CPU 共享最多因为进程数增大而变慢。内存共享可能会有其它问题
1. 某些进程得不到需要的内存
2. 内存内容被破坏

Modern systems provide an abstraction of main memory known as /virtual memory/ (VM).

Virtual memory is an elegant interaction to provide each process with a address space that
- large
- uniform
- private 

The aspects to interact with are
- hardware exception
- hardware address translation
- main memory
- disk file (swap)
- kernel software 

Virtual memory provides 3 important capabilities:
1. [swap] use main memory effciently by treating it as a cache for an
   address space stored on disk, keeping only athe active areas in
   main memory and transferring data back and forth between disk and
   memory as needed
2. [flat address] it simplifies memory management by providing each
   process with a uniform address space
3. [isolation] it protects the address space of each process from
   corruption by other processes

*** Why would a programmer need to understand it?

1. [central] pervades all levels of computer systems: hardware
   exception, assemblers, linkers, loaders, shared objects, files and
   processes
2. [powerful] =malloc=, =mmap=, share memory with other processes
3. [dangerous] segmentation fault or protection fault

*** Two angles to learn virtual memory

1. how does it work
2. how it is used and managed by application

** DONE Physical and Virtual Addressing

PA (physical address) is organized as an array of M contiguous
byte-size cells.

VA (virtual address) is converted to the appropriate physical address
before being sent to main memory.

Address translation is performed on the CPU chip called memory
management unit (MMU), using a lookup table stored in main memory
whose contents are managed by the operating system.

** DONE Address Spaces

/linear address space/: the address space that the addresses are consecutive.

Represent with the number of bits that are needed to represent the largest address:
- 32-bit
- 64-bit

Distinct data object (bytes) and their attributes (addresses). Each
object can have multiple independent addresses, each chosen from a
different address space.

| VA bits | Number of VA | Largest possible virtual address |
|---------+--------------+----------------------------------|
|       4 | 16           | 15                               |
|      14 | 16K          | 16K-1                            |
|      24 | 16M          | 16M-1                            |
|      46 | 64T          | 64T-1                            |
|      54 | 16P          | 16P-1                            |

** [1/6] TODO VM as a Tool for Caching

Cache the contiguous addressed disk space into virtual memory in unit of fix sized block:
- /virtual pages/ (VPs) for virtual memory
- /physical pages/ (PPs) for physical memory, also referered as /page frames/

Virtual pages is partitioned into 3 disjoint subsets:
- Unallocated :: pages have not yet been allocated by VM system (has no data associated with)
- Cached :: cached in physical memory
- UnCached :: allocated pages that are not cached in physical memory

#+CAPTION: VM as Cache
[[./img/9.3.vp-pp-mapping.jpg]]


*** DONE DRAM Cache Organization

**** Term

- *SRAM* cache denotes the L1, L2, and L3 cache memories between the CPU and main memory. 
- *DRAM* cache to denote the VM system's cache that caches virtual pages in main memory.

**** Compare

DRAM is important because of
1. read from disk is too slow (about 100,000 slower than a DRAM)
2. read the first byte from a disk sector is about 100,000 times slower than reading successive bytes in the sector

The bottom line is that the organization of the DRAM cache is driven entirely by the enormous cost of misses.

*** TODO Page Tables

*** TODO Page Hits

*** TODO Page Faults

*** TODO Allocating Page

*** TODO Locality to the Rescue Again

** TODO VM as a Tool for Memory Management

** TODO VM as a Tool for Memory Protection

** TODO Address Translation

** TODO Case Study: The Intel Core i7/Linux Memory System

** TODO Memory Mapping

** TODO Dynamic Memory Allocation

** TODO Garbage Collection

** TODO Common Memory-Related Bugs in C Programs

** TODO Summary



* Footnotes

[fn:1] Controller 集成在设备或主板上，Adapater 是主板上的插槽的可插拔设备
[fn:2] 指令集( Instruction set artichecture ) 相当于对外的接口，CPU 具体实现可以不同，称为 microarchitecture


