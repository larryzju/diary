#+TITLE: 《Go 语言编程》笔记
#+AUTHOR: 赵文彬

* 概述

Go 编程思想核心是维持语言的简洁，时刻警惕特性复杂化，与 C 语言相通。

** 简化

语言设计总体上持保守态度，有以下简化：

1. 反对函数和操作符重载（overload），因其有负担而无解决问题的能力
2. 反对继承、反对虚函数和虚函数重载
3. 放弃构造函数与析构函数

** 特征

1. ~go~ 关键字与协程
2. 推荐采用 erlang 风格的消息传递机制进行通信
3. 强制代码风格
4. 统一的错误处理（多返回，defer 机制等）
5. 非侵入性的接口（鸭子方法，静态编译）
6. 函数式编程，如匿名函数、闭包[fn:1]

* Footnotes

[fn:7] 类似于 python 中的 duck type，但由于 go 是编译语言，在使用时强制转换和检查，能保证更好的可用性和性能

[fn:6] C 语言中数组基于引用，但结构体中的数组基于值

[fn:5] 可以看出 java 不是完整的面向对象语言，在 ruby 等中强制要求所有类型都是对象

[fn:4] 在 C 语言中函数传参方式不同，决定函数是否能够修改外部变量内容

[fn:3] 编译时生成，每次自动加 1。用于生成枚举，多次调用时可以只写第一个，后续省略

[fn:2] 貌似 plan9 中的编译器也是如此。在 1.8 版本的 bin 目录下没有看到 6g, 6l 等文件？

[fn:1] 闭包在函数式编程中是一个重要想对概念，C++ 式的面向对象编程中把一组函数绑定到特定的数据类型上，而闭包可以说是把一组数据绑定到特定的函数上。


* 初始 go 语言

** Go 语言特性

- GC :: 自动内存管理，有指针而无操作，避免 C 中的野指针问题
- 更丰富的内置类型 :: 如 map, slices
- 函数多返回值 :: C 需要通过参数修改返回多个值
- 错误处理 :: defer 及 panic/recover 机制
- 匿名函数与闭包 :: 高阶函数式编程
- 类型和接口 :: 类型组合，非侵入式的接口
- 并发编程 :: goroutine 以及 channel，CSP（通信顺序进程）
- 反射 :: 动态操作对象，涉及序列化与反序列化
- 语言交互性 :: cgo 提供与 C 的互操作

** Hello World

- main 包中 main 函数为入口
- main 函数无返回，无参数传入（通过 =os.Args= ）
- go run/build 命令运行和编译
- go 命令只是一个前端，编译器与链接器为 6g, 6l 等 [fn:2]


** 工程管理

- 完全用目录结构和包名来推导工程结构和构建顺序（策略而非规则）
- 包括 src, pkg, bin 三个目录
- =xxx_test.go= 是针对 =xxx.go= 的单元测试文件
- =GOPATH= 环境变量为工程根目录
- =go test= 执行单元测试

** 其它资料

- [[https://github.com/wonderfo/wonderfogo/wiki][持续整理的 go 资料]]

* 顺序编程

** 变量

- 变量是对一块数据存储空间的命名
- =var= 关键字
- ~:=~ 定义及自动类型推导，用于局部变量
- 支持多重赋值
- 用 =_= 来表示匿名变量，通常丢弃该值

** 常量

- 编译期间就已知且不可改变的值
- 字面常量：无类型，视使用值域而定，保持精确度
- =const= 关键字，类似于 =var= ，可以是无类型的
- 预定义了 true, false, iota[fn:3] 等变量

** 类型

- 布尔值 :: bool，值为 =true= 或 =false=
- 整形 :: =[u]int{8,16,32,64}= 以及 =int=, =uint=, =uintptr=
- 浮点型 :: =float{32,64}=
- 复数类型 :: =complex{64,128}=
- 字符串 :: 不可修改，字符类型为 =rune= ，注意与 byte 的区别
- 字符类型 :: byte vs rune
- 数组 :: =[2*N]struct{x,y int 32}=, 注意数组是一个 **值类型** ，赋值与传参内容会被复制
- 切片 :: slices，底层是数组，可动态扩充空间，引用类型。常用方法为 copy,len,cap
- map :: =map[string] PersonInfo= 定义，通过 make 来申请，引用类型

** 流程控制

*** 条件语句

=if ... else=

*** 选择语句

- =switch ... case=
- switch 后表达式可选，退化成 =if...elseif...else= 分支
- 不需要加 break ，可以加入 fallthrough 跳过跳出

*** 循环语句

通过 =for= 语句实现，有三种方式

1. 无限循环
2. C 循环（三段式）
3. range 迭代

*** 跳转语句

=goto LABLE=

** 函数 

- 通过首字母大小写来体现可见性
- 不定参数 =...type= ，本质是数组切片
- 数组展开 =slices...= ，类似于 lisp apply 展开 list
- =interaface{}= 接口可以表示任意类型数据

** 闭包

可以包含自由（未绑定）变量的代码段，这些变量不在这个代码块内部或任何全局上下文中定义，而是在定义代码块的环境中定义。

要执行的代码块为自由变量提供绑定的计算环境（作用域）

** 错误处理

- error 接口 :: 有唯一的方法 Error
- defer :: atexit 回调，保证资源被清理干净
- panic/recover :: defer 会被先执行， recover 位于 defer 中

** 示例

- 演示了排序程序，以及命令行的交互实现
- =flag= 用于解析参数
- =os.Open=, =os.Create= 以及 =File.Close=, =File.WriteString= 操作文件
- =bufio.NewReader=, =bufio.ReadLine= 操作 IO
- =strconv.Atoi= 字符串转换
- =time.Now= 获取当前时间










* 面向对象编程

** 概述

- Go 没有继承、虚函数、构造/析构函数 ，this 掼
- 通过接口 (interface) 来盘活整个类型系统

** 类型系统

*** 概述

类型系统是程序语言中一个重要的部分，在 GO 中主要包括以下部分

1. 基础类型
2. 复合类型：如数组、结构体、指针等
3. 可以指向任意对象的类型（Any 类型）
4. 值语义与引用语义[fn:4]
5. 面向对象
6. 接口

*** Java 类型系统

以 java 为例，有两套独立的类型系统[fn:5]

1. 值类型：通过装箱才能作为对象，如 int 转换为 Integer 对象
2. 对象类型/引用类型：只允许在堆上创建（共享内存），以 Object 作为类型系统的根

只有对象类型才能实现接口

*** Go 语言类型系统

Go 语言类型系统有如下特征：

- 大多类型都是值语义 :: 意味要想修改变量的值，需要显式的传递指针
- 可以包含对应的操作方法 :: Reciever
- Any 类型 :: 即 =interface{}=

其值主义表现的非常彻底，包括数组、结构体、指针都基于值语义[fn:6]

Go 中有四个引用类型的特别类型：

1. slice
2. map
3. channel
4. interface










** 初始化

Go 中未显示初始化的变量都会被初始化为默认零值。结构体为例，构造的方法有四种：

1. =new(Rect)=
2. =&Rect{}=
3. =&Rect{0,0,100,200}=
4. =&Rect{width: 100, height: 200}=

** 匿名组合

“继承”匿名 struct 的方法，本质是语法糖。其中匿名 struct 中 field 访问获得提升

** 可见性

- 通过首字母大小写控制可见性
- 可见性针对包级别，比 scala 粗旷，但好理解

** 接口

接口是 go 语言中类型系统的基石

*** 侵入式接口

Go 语言之外，接口主要作为不同组件之间的契约关系存在，需要强制声明实现。称为“侵入式”。

侵入式接口有一个邮件个主要问题：

1. 提供哪些接口
2. 两个类实现了相同的接口，接口放在哪个包好？

*** 非侵入式接口

Go 语言中，一个类只要实现了接口要求的所有函数，则自动实现该接口[fn:7]。称为“非侵入式接口”。

其优势在于：

1. 不再需要绘制类库的继承树图（好事？坏事？）
2. 只需要关心应该提供哪些方法，无须纠结接口如何细分
3. 不需要为实现接口而导包，减少耦合

** 接口赋值

接口赋值分为两种：

1. 将对象实例赋值给接口
2. 将一个接口赋值给另一个接口

*** 注意

Go 会根据 =func ( a Integer ) Less ( b Integer ) bool= 自动生成：

#+BEGIN_SRC go
func ( a *Integer ) Less ( b Interger ) book {
    return (*a).Less(b)
}
#+END_SRC

反之则不成立（因为 =&a.Add()= 改变的只是函数的参数，并不对外部的对象产生影响。

** 接口查询 

用于检查对象是否实现了接口。注意这是在运行期进行的操作，有成本，且可能失败

#+BEGIN_SRC go
file, ok := obj.(*File)
#+END_SRC

接口查询的主要用途是：

1. 查询接口
2. 查询具体类型

*** 类型查询 

通过 =v.(type)= 语法来查询，配合 =switch= 语法。另外也可以通过反射进行类型查询 ，详见 =reflect.TypeOf= 方法

** 接口组合

与类型匿名组合类似，可看作其一种特殊用法。

用于整合不同接口，形成新的接口。

** Any 类型

go 语言中任何对象实例都满足 =interface{}= 接口。

对于 Any 类型，刚开始对其一无所知，但可以通过接口查询和类型查询了解它（自省特性？）


* TODO 并发编程
* 开发工具

- =github.com/nfs/gocode= 提供代码补全功能
- 由于多线程和多进程的引入 ，可视化调试手段功能有限，不如直接 =fmt.Println= 
